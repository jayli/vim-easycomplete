FUNCTION  easycomplete#util#LspType()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:1543
Called 170 times
Total time:   0.005975
 Self time:   0.005975

count  total (s)   self (s)
  170              0.001016   if string(a:c_type) =~ "^\\d\\{0,2}$"
  170              0.000339     if !exists("s:easycomplete_kinds")
                                  let s:easycomplete_kinds = [ '', 'text', 'method', 'function', 'constructor', 'field', 'variable', 'class', 'interface', 'module', 'property', 'unit', 'value', 'enum', 'keyword', 'snippet', 'color', 'file', 'reference', 'folder', 'enummember', 'constant', 'struct', 'event', 'operator', 'typeparameter', 'const' ]
  170              0.000068     endif
  170              0.000207     let l:kinds = s:easycomplete_kinds
  170              0.000081     try
  170              0.000443       let l:type_fullname = l:kinds[str2nr(a:c_type)]
  170              0.000262       let l:type_shortname = l:type_fullname[0]
                                catch
                                  let l:type_fullname = ""
                                  let l:type_shortname = ""
  170              0.000084     endtry
                              else
                                let l:type_fullname = a:c_type
                                if l:type_fullname == "var"
                                  let l:type_fullname = "variable"
                                endif
                                let l:type_shortname = l:type_fullname[0]
  170              0.000057   endif
  170              0.000327   if has_key(g:easycomplete_lsp_type_font, l:type_fullname)
  170              0.000300     let symble = g:easycomplete_lsp_type_font[l:type_fullname]
                              else
                                let symble = get(g:easycomplete_lsp_type_font, l:type_shortname, l:type_shortname)
  170              0.000053   endif
  170              0.000508   return { 'symble': symble, 'fullname': l:type_fullname, 'shortname': l:type_shortname }

FUNCTION  <SNR>49_AsyncRun()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:3057
Called 33 times
Total time:   0.003081
 Self time:   0.000251

count  total (s)   self (s)
   33   0.003067   0.000237   return call('easycomplete#util#AsyncRun', a:000)

FUNCTION  <SNR>49_SameCtx()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2587
Called 19 times
Total time:   0.000303
 Self time:   0.000303

count  total (s)   self (s)
   19              0.000091   if type(a:ctx1) != type({}) || type(a:ctx2) != type({})
                                return v:false
   19              0.000008   endif
   19              0.000053   if !has_key(a:ctx1, 'lnum') || !has_key(a:ctx2, 'lnum')
    2              0.000002     return v:false
   17              0.000005   endif
   17              0.000062   if a:ctx1["lnum"] == a:ctx2["lnum"] && a:ctx1["col"] == a:ctx2["col"] && a:ctx1["typing"] ==# a:ctx2["typing"]
    6              0.000005     return v:true
   11              0.000004   else
   11              0.000009     return v:false
                              endif

FUNCTION  2()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:1778
Called 200 times
Total time:   0.002547
 Self time:   0.002547

count  total (s)   self (s)
  200              0.000470   if &filetype != "vim" | return v:false | endif
  200              0.000441   let word = get(a:item, "label", "")
  200              0.000409   if empty(word) | return v:true | endif
  200              0.000256   if len(a:typing_word) == 1
  200              0.000359     let pos = stridx(word, a:typing_word)
  200              0.000207     if pos >= 0 && pos <= 5
  170              0.000142       return v:false
   30              0.000012     else
   30              0.000022       return v:true
                                endif
                              else
                                if s:FuzzySearchRegx(a:typing_word, word)
                                  return v:false
                                else
                                  return v:true
                                endif
                              endif

FUNCTION  easycomplete#sign#GetCurrentDiagnostics()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sign.vim:666
Called 26 times
Total time:   0.000727
 Self time:   0.000589

count  total (s)   self (s)
   26              0.000088   if !exists("g:easycomplete_diagnostics_cache")
                                return []
   26              0.000013   endif
   26   0.000441   0.000303   let cache = get(g:easycomplete_diagnostics_cache, easycomplete#util#GetCurrentFullName(), {})
   26              0.000038   if empty(cache)
    5              0.000006     return []
   21              0.000008   endif
   21              0.000042   if len(cache.params.diagnostics) == 0
   21              0.000014     return []
                              endif
                              return cache.params.diagnostics

FUNCTION  <SNR>56_LastDifference()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:1367
Called 2 times
Total time:   0.000621
 Self time:   0.000621

count  total (s)   self (s)
    2              0.000008   let l:line_count = min([len(a:old), len(a:new)])
    2              0.000005   if l:line_count == 0 | return [0, 0] | endif
  156              0.000100   for l:i in range(-1, -1 * l:line_count, -1)
  308              0.000297     if a:old[l:i] !=# a:new[l:i] | break | endif
  156              0.000061   endfor
    2              0.000003   if l:i <= -1 * l:line_count
    2              0.000003     let l:i = -1 * l:line_count
    2              0.000007     let l:old_line = strcharpart(a:old[l:i], a:start_char)
    2              0.000004     let l:new_line = strcharpart(a:new[l:i], a:start_char)
                              else
                                let l:old_line = a:old[l:i]
                                let l:new_line = a:new[l:i]
    2              0.000001   endif
    2              0.000004   let l:old_line_length = strchars(l:old_line)
    2              0.000004   let l:new_line_length = strchars(l:new_line)
    2              0.000006   let l:length = min([l:old_line_length, l:new_line_length])
    2              0.000002   let l:j = -1
    2              0.000003   while l:j >= -1 * l:length
                                if  strgetchar(l:old_line, l:old_line_length + l:j) != strgetchar(l:new_line, l:new_line_length + l:j)
                                  break
                                endif
                                let l:j -= 1
    2              0.000002   endwhile
    2              0.000003   return [l:i, l:j]

FUNCTION  easycomplete#util#HasLua()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:2131
Called 29 times
Total time:   0.000238
 Self time:   0.000238

count  total (s)   self (s)
   29              0.000179   if g:env_is_nvim && has("nvim-0.5.0")
   29              0.000032     return v:true
                              else
                                return v:false
                              endif

FUNCTION  <SNR>77_GetFileName()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/path.vim:210
Called 1 time
Total time:   0.000014
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000013   0.000007   return easycomplete#util#GetFileName(a:path)

FUNCTION  easycomplete#lsp#utils#to_char()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/utils.vim:199
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000003   let l:lines = getbufline(a:expr, a:lnum)
    1              0.000001   if l:lines == []
                                if type(a:expr) != v:t_string || !filereadable(a:expr)
                                  " invalid a:expr
                                  return a:col - 1
                                endif
                                " a:expr is a file that is not yet loaded as a buffer
                                let l:lines = readfile(a:expr, '', a:lnum)
    1              0.000000   endif
    1              0.000002   let l:linestr = l:lines[-1]
    1              0.000003   return strchars(strpart(l:linestr, 0, a:col - 1))

FUNCTION  easycomplete#LuaSnipSupports()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2396
Called 2 times
Total time:   0.000084
 Self time:   0.000017

count  total (s)   self (s)
    2   0.000083   0.000016   return s:LuaSnipSupports()

FUNCTION  <SNR>49_LazyFireTyping()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2814
Called 2 times
Total time:   0.000124
 Self time:   0.000110

count  total (s)   self (s)
    2              0.000009   if !exists('b:easycomplete_typing_timer') | let b:easycomplete_typing_timer = 0 | endif
    2              0.000003   if b:easycomplete_typing_timer > 0
    2              0.000002     if g:env_is_nvim
    2              0.000013       call s:easycomplete_toolkit.global_timer_stop()
                                else
                                  call timer_stop(b:easycomplete_typing_timer)
    2              0.000001     endif
    2              0.000004     let b:easycomplete_typing_timer = 0
    2              0.000001   endif
                              " TODO here 为什么 50 的延时会体感这么久
                              " 判断连续输入的两次字符是否是同一个
                              " 如果是则有可能是连续按键，加上延迟，防止连续输入时粘连
                              " 如果不是则立即触发，提高响应速度
    2              0.000005   if !exists("b:easycomplete_old_char")
                                let b:easycomplete_old_char = ""
    2              0.000001   endif
    2   0.000027   0.000013   let l:easycomplete_curr_char = s:GetCurrentChar()
    2              0.000005   if b:easycomplete_old_char ==# l:easycomplete_curr_char
                                let l:lazy_time = 70
    2              0.000001   else
    2              0.000002     let l:lazy_time = 0
    2              0.000001   endif
    2              0.000004   let b:easycomplete_old_char = l:easycomplete_curr_char
                            
    2              0.000002   if g:env_is_nvim
    2              0.000013     call s:easycomplete_toolkit.global_timer_start("easycomplete#typing", l:lazy_time)
    2              0.000006     let b:easycomplete_typing_timer = reltime()[0]
                              else
                                let b:easycomplete_typing_timer = timer_start(l:lazy_time, { -> easycomplete#typing() })
    2              0.000001   endif

FUNCTION  easycomplete#sources#path#completor()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/path.vim:2
Called 1 time
Total time:   0.000608
 Self time:   0.000063

count  total (s)   self (s)
    1   0.000205   0.000050   let l:typing_path = s:TypingAPath(a:ctx)
    1              0.000001   if !l:typing_path.is_path
    1   0.000399   0.000009     call easycomplete#complete(a:opt['name'], a:ctx, a:ctx['startcol'], [])
    1              0.000001     return v:true
                              endif
                              call easycomplete#util#timer_start( "easycomplete#sources#path#CompleteHandler", [a:ctx['typing'], a:opt['name'], a:ctx, a:ctx['startcol'], l:typing_path], 10 )
                              " 展开目录时，中断其他complete逻辑
                              " 中断其他 complete 逻辑，设计上的问题，这里要用异步调
                              " easycomplete#complete()
                              return v:false

FUNCTION  easycomplete#action#signature#handle()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/action/signature.vim:34
Called 2 times
Total time:   0.001111
 Self time:   0.000179

count  total (s)   self (s)
    2   0.000411   0.000038   let typed = s:GetTyped()
    2   0.000053   0.000042   if easycomplete#IsBacking()
                                if easycomplete#action#signature#FireCondition()
                                  call s:do()
                                else
                                  call s:close()
                                endif
    2              0.000001   else
    2              0.000009     if trim(getline(".")) == ""
    1   0.000118   0.000011       call s:close()
    2              0.000001     endif
    2              0.000017     if typed =~ ")$"
                                  call s:close()
    2   0.000459   0.000018     elseif easycomplete#action#signature#FireCondition()
                                  call s:do()
    2              0.000001     endif
                                " call s:close()
    2              0.000001   endif
    2              0.000003   let b:signature_timer = 0

FUNCTION  easycomplete#InsertEnter()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:3016
Called 1 time
Total time:   0.000214
 Self time:   0.000026

count  total (s)   self (s)
    1   0.000143   0.000009   call s:SnapShoot()
    1   0.000062   0.000008   call easycomplete#sign#DiagHoverFlush()
    1              0.000008   call timer_start(10, { ->easycomplete#popup#CloseLintPopup() })

FUNCTION  <SNR>52_fullfill()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:1288
Called 2154 times
Total time:   0.011085
 Self time:   0.011085

count  total (s)   self (s)
 2154              0.003963   let word_length = strdisplaywidth(a:word)
 2154              0.001986   if word_length >= a:length
 1600              0.001195     return a:word
  554              0.000214   endif
  554              0.000650   let inc = a:length - word_length
                              " if g:easycomplete_nerd_font
                              "   return repeat(" ", inc) . a:word
                              " else
  554              0.000976   return a:word . repeat(" ", inc)
                              " endif

FUNCTION  <SNR>59_SpecialTrim()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/ui.vim:235
Called 4 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
                              " 去掉字符串开头的非字母数字字符
    4              0.000041   let result = substitute(a:search_word, '^\W\+', '', '')
                              " 去掉字符串结尾的非字母数字字符
    4              0.000017   let result = substitute(result, '\W\+$', '', '')
    4              0.000005   return result

FUNCTION  easycomplete#util#GetUserData()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:228
Called 9752 times
Total time:   0.065208
 Self time:   0.065208

count  total (s)   self (s)
                              " let ret = get(a:item, "user_data_json", {})
 9752              0.014827   if has_key(a:item, "user_data_json")
 9557              0.011921     let ret = a:item["user_data_json"]
  195              0.000076   else
  195              0.000186     let ret = {}
 9752              0.003248   endif
 9752              0.008637   if !empty(ret)
 9557              0.005577     return ret
  195              0.000071   endif
  195              0.000251   if has_key(a:item, 'user_data')
                                let user_data_str = a:item["user_data"]
  195              0.000071   else
  195              0.000189     let user_data_str = ""
  195              0.000065   endif
  195              0.000288   if empty(user_data_str)
  195              0.000144     return {}
                              endif
                              try
                                let user_data = json_decode(user_data_str)
                                if empty(user_data)
                                  return {}
                                else
                                  return user_data
                                endif
                              catch /^Vim\%((\a\+)\)\=:\(E474\|E491\)/
                                return {}
                              endtry

FUNCTION  <SNR>56_ensure_start()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:853
Called 6 times
Total time:   0.012206
 Self time:   0.000318

count  total (s)   self (s)
    6   0.000192   0.000051   let l:path = easycomplete#lsp#utils#get_buffer_path(a:buf)
                            
    6   0.000291   0.000169   if easycomplete#lsp#utils#is_remote_uri(l:path)
                                let l:msg = s:new_rpc_error('ignoring start server due to remote uri', { 'server_name': a:server_name, 'uri': l:path})
                                call s:errlog("[ERR]s:ensure_start", l:msg)
                                call a:cb(l:msg)
                                return
    6              0.000003   endif
                            
    6              0.000015   let l:server = s:servers[a:server_name]
    6              0.000011   let l:server_info = l:server['server_info']
    6              0.000009   if l:server['lsp_id'] > 0
    6   0.000097   0.000055     let l:msg = s:new_rpc_success('server already started', { 'server_name': a:server_name })
                                " call s:errlog("[LOG]", l:msg)
    6   0.009364   0.006798     call a:cb(l:msg)
    6              0.000003     return
                              endif
                            
                              if has_key(l:server_info, 'tcp')
                                let l:tcp = l:server_info['tcp'](l:server_info)
                                let l:lsp_id = easycomplete#lsp#client#start({ 'tcp': l:tcp, 'on_stderr': function('s:on_stderr', [a:server_name]), 'on_exit': function('s:on_exit', [a:server_name]), 'on_notification': function('s:on_notification', [a:server_name]), 'on_request': function('s:on_request', [a:server_name]), })
                              elseif has_key(l:server_info, 'cmd')
                                let l:cmd_type = type(l:server_info['cmd'])
                                if l:cmd_type == v:t_list
                                  let l:cmd = l:server_info['cmd']
                                else
                                  let l:cmd = l:server_info['cmd'](l:server_info)
                                endif
                            
                                if empty(l:cmd)
                                  let l:msg = s:new_rpc_error('ignore server start since cmd is empty', { 'server_name': a:server_name })
                                  call s:errlog("[ERR]ignore server start since cmd is empty", l:msg)
                                  call a:cb(l:msg)
                                  return
                                endif
                                call s:errlog("[LOG]", 'Starting server', a:server_name, l:cmd)
                                " call s:console("0", l:server_info)
                                let l:lsp_id = easycomplete#lsp#client#start({ 'cmd': l:cmd, 'on_stderr': function('s:on_stderr', [a:server_name]), 'on_exit': function('s:on_exit', [a:server_name]), 'on_notification': function('s:on_notification', [a:server_name]), 'on_request': function('s:on_request', [a:server_name]), })
                              endif
                            
                              if l:lsp_id > 0
                                let l:server['lsp_id'] = l:lsp_id
                                let b:lsp_job_id = l:lsp_id
                                let l:msg = s:new_rpc_success('started lsp server successfully', { 'server_name': a:server_name, 'lsp_id': l:lsp_id })
                                " call s:errlog("[LOG]", l:msg)
                                call a:cb(l:msg)
                              else
                                let l:msg = s:new_rpc_error('failed to start server', { 'server_name': a:server_name, 'cmd': l:cmd })
                                " call s:errlog("[LOG]", l:msg)
                                let b:lsp_job_id = 0
                                call a:cb(l:msg)
                              endif
                              " TODO Jayli
                              " l:lsp_id 需要被记录到全局变量中，以便buf关闭时一起关闭
                              " lsp server 跟 buf 是一一绑定的关系，跟window没关系
                              " 关闭的时候需要考虑多个 window 绑定一个 bufnr 的情况，要判断一下是否还存在
                              " 别的 bufnr 是当前 window的 buf
                              call easycomplete#util#SetCurrentBufJob(l:lsp_id)
                              " call s:console('add new job ' . fnamemodify(expand('%'), ':p'))

FUNCTION  <lambda>21834()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 8 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# 'textDocument/publishDiagnostics'

FUNCTION  <lambda>21835()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 2 times
Total time:   0.000682
 Self time:   0.000014

count  total (s)   self (s)
                            return Callback(x['server'], x['response'])

FUNCTION  <lambda>21836()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 8 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# '$/vimlsp/lsp_server_exit' 

FUNCTION  easycomplete#lint()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2680
Called 3 times
Total time:   0.020724
 Self time:   0.000023

count  total (s)   self (s)
    3   0.020723   0.000022   call easycomplete#action#diagnostics#do()

FUNCTION  <SNR>77_GetPathName()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/path.vim:214
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000005   let path =  simplify(a:path)
    2              0.000008   let pathname = matchstr(path,"^.*\\/")
    2              0.000002   return pathname

FUNCTION  easycomplete#FireCondition()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:778
Called 2 times
Total time:   0.001656
 Self time:   0.000020

count  total (s)   self (s)
    2   0.001655   0.000019   return s:NormalTrigger() || s:SemanticTrigger()

FUNCTION  <SNR>49_OrigionalPosition()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:732
Called 12 times
Total time:   0.001661
 Self time:   0.000076

count  total (s)   self (s)
   12   0.001657   0.000071   return easycomplete#CheckContextSequence(g:easycomplete_firstcomplete_ctx)

FUNCTION  <SNR>49_FastBSTimerReset()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:940
Called 2 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000021   let b:fast_bs_timer = 0

FUNCTION  <SNR>52_TrimBelowHeight()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:920
Called 47 times
Total time:   0.000483
 Self time:   0.000483

count  total (s)   self (s)
   47              0.000073   let l:real_below_space = a:below_space
   47              0.000061   let h = g:easycomplete_pum_maxheight
   47              0.000041   if g:easycomplete_winborder
   47              0.000111     let l:real_below_space = a:below_space > h - 2 ? h - 2 : a:below_space
                              else
                                let l:real_below_space = a:below_space > h ? h : a:below_space
   47              0.000017   endif
   47              0.000041   return l:real_below_space

FUNCTION  easycomplete#GetCurrentLspContext()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:261
Called 4 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    4              0.000015   if exists("b:easycomplete_current_lsp_context")
    4              0.000006     return b:easycomplete_current_lsp_context
                              endif
                              let l:ctx_name = ''
                              if empty(g:easycomplete_source)
                                return {}
                              endif
                              for item in keys(g:easycomplete_source)
                                if s:CompleteSourceReady(item)
                                  if has_key(get(g:easycomplete_source, item), "gotodefinition")
                                    let l:ctx_name = item
                                    break
                                  endif
                                endif
                              endfor
                              let b:easycomplete_current_lsp_context = get(g:easycomplete_source, l:ctx_name, {})
                              return b:easycomplete_current_lsp_context

FUNCTION  <SNR>49_StopFirstCompleteRenderingTimer()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1979
Called 12 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
   12              0.000015   if s:first_render_timer > 0
    1              0.000002     call timer_stop(s:first_render_timer)
    1              0.000001     let s:first_render_timer = 0
   12              0.000004   endif

FUNCTION  <SNR>49_CompleteSourceReady()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1286
Called 180 times
Total time:   0.002674
 Self time:   0.002674

count  total (s)   self (s)
  180              0.000368   if has_key(g:easycomplete_source, a:name)
  180              0.000475     let completor_source = get(g:easycomplete_source, a:name)
  180              0.000313     if has_key(completor_source, 'whitelist')
  180              0.000366       let whitelist = get(completor_source, 'whitelist')
  180              0.000585       if index(whitelist, &filetype) >= 0 || index(whitelist, "*") >= 0
   30              0.000029         return v:true
  150              0.000067       else
  150              0.000135         return v:false
                                  endif
                                else
                                  return v:true
                                endif
                              else
                                return v:false
                              endif

FUNCTION  easycomplete#ShowCompleteInfoInFirstRendering()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2206
Called 1 time
Total time:   0.000435
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000008   if !(g:easycomplete_pum_noselect)
    1              0.000011     call timer_start(2, { -> s:ShowCompleteInfoWithoutTimer() })
    1   0.000410   0.000007     if easycomplete#util#GetCurrentPluginName() == "ts"
                                  call timer_start(1, { -> easycomplete#sources#ts#CompleteChanged() })
    1              0.000000     endif
    1              0.000000   endif

FUNCTION  <SNR>52_MaxLength()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:1164
Called 26 times
Total time:   0.073076
 Self time:   0.073076

count  total (s)   self (s)
   26              0.000036   let max_length = 0
 1103              0.001561   for item in a:lines
 1077              0.001385     let remove_style_wrapper = item
 1077              0.008556     let remove_style_wrapper = substitute(remove_style_wrapper, "\\s⊥\[^⊥\]⊥\\s", " x ", "g")
 1077              0.007437     let remove_style_wrapper = substitute(remove_style_wrapper, "\\s∫\[^∫\]∫\\s", " x ", "g")
 1077              0.007049     let remove_style_wrapper = substitute(remove_style_wrapper, "\\s∮\[^∮\]∮\\s", " x ", "g")
 1077              0.007981     let remove_style_wrapper = substitute(remove_style_wrapper, "\\sΦ\[^Φ\]Φ\\s", " x ", "g")
 1077              0.006961     let remove_style_wrapper = substitute(remove_style_wrapper, "\\s♧\[^♧\]♧\\s", " x ", "g")
 1077              0.007022     let remove_style_wrapper = substitute(remove_style_wrapper, "\\s♤\[^♤\]♤\\s", " x ", "g")
 1077              0.011415     let curr_length = strdisplaywidth(substitute(remove_style_wrapper, "\[§ϟ‰]", "", "g"))
 1077              0.001117     if curr_length > max_length
   26              0.000049       let max_length = curr_length
 1077              0.000392     endif
 1103              0.009967   endfor
   26              0.000036   return max_length

FUNCTION  easycomplete#lsp#client#send_notification()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/client.vim:322
Called 2 times
Total time:   0.000329
 Self time:   0.000018

count  total (s)   self (s)
    2   0.000328   0.000017   return s:lsp_send(a:client_id, a:opts, s:send_type_notification)

FUNCTION  <SNR>49_SemanticTrigger()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:783
Called 1 time
Total time:   0.001232
 Self time:   0.000339

count  total (s)   self (s)
    1              0.000001   let flag = v:false
   31              0.000035   for name in keys(g:easycomplete_source)
   30   0.001112   0.000219     if s:CompleteSourceReady(name) && s:SemanticTriggerForPluginName(name)
                                  let flag = v:true
                                  break
   30              0.000011     endif
   31              0.000030   endfor
    1              0.000001   return flag

FUNCTION  <SNR>49_flush()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2466
Called 3 times
Total time:   0.011494
 Self time:   0.001824

count  total (s)   self (s)
    3              0.000115   let g:easycomplete_menuitems = []
    3              0.000006   let g:easycomplete_stunt_menuitems = []
    3              0.000005   let g:easycomplete_first_complete_hit = 0
    3   0.000082   0.000020   call s:ResetCompletedItem()
    3   0.000246   0.000018   call s:ResetCompleteCache()
    3   0.009120   0.000022   call s:ResetCompleteTaskQueue()
    3              0.000009   let g:easycomplete_firstcomplete_ctx = {}
                              " call s:SnapShoot()
    3              0.000019   let g:easycomplete_completechanged_event = {}
    3              0.000004   if s:first_render_timer > 0
                                call timer_stop(s:first_render_timer)
                                let s:first_render_timer = 0
    3              0.000001   endif
   93              0.000090   for sub in keys(g:easycomplete_source)
   90              0.001251     let g:easycomplete_source[sub].complete_result = []
   93              0.000039   endfor
    3              0.000009   let g:easycomplete_completedone_insert_mode = mode()
    3   0.000145   0.000099   if easycomplete#util#InsertMode() && complete_check()
                                call timer_start(50, { -> s:HideComplete(col("."))})
    3              0.000001   endif
    3              0.000004   if g:easycomplete_showmode
    3   0.000024   0.000021     set showmode
    3              0.000002   endif
    3              0.000003   if g:env_is_nvim
    3   0.000253   0.000020     call s:CloseCompletionMenu()
    3              0.000001   endif
    3              0.000005   let s:easycomplete_start_pos = 0
    3              0.000004   let b:old_changedtick = 0

FUNCTION  easycomplete#sign#GetDiagnosticsInfo()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sign.vim:632
Called 1 time
Total time:   0.000049
 Self time:   0.000025

count  total (s)   self (s)
    1   0.000030   0.000006   let lint_list = easycomplete#sign#GetCurrentDiagnostics()
    1              0.000001   let l:count = 0
    1              0.000001   let ret = {}
    1              0.000002   while l:count < len(lint_list)
                                let item = lint_list[l:count]
                                let info_line = item.range.start.line + 1
                                let info_col_start = item.range.start.character + 1
                                let info_col_end= item.range.end.character + 1
                                if info_line == a:line && (a:colnr >= info_col_start && a:colnr <= info_col_end)
                                  let ret = item
                                  break
                                endif
                                let l:count += 1
    1              0.000002   endwhile
    1              0.000001   return ret

FUNCTION  <SNR>64_GetDiagnosticsInfoByLine()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sign.vim:650
Called 1 time
Total time:   0.000048
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000036   0.000006   let lint_list = easycomplete#sign#GetCurrentDiagnostics()
    1              0.000001   let l:count = 0
    1              0.000001   let ret = {}
    1              0.000002   while l:count < len(lint_list)
                                let item = lint_list[l:count]
                                let info_line = item.range.start.line + 1
                                if info_line == a:line
                                  let ret = item
                                  break
                                endif
                                let l:count += 1
    1              0.000001   endwhile
    1              0.000001   return ret

FUNCTION  <SNR>57_createSinkCallback()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:245
Called 9 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    9              0.000012   if !a:data['end']
    6              0.000011     let a:data['end'] = (a:t == 2)
    6              0.000023     if a:data['end'] && has_key(a:data, 'clean') && type(a:data['clean']) == type(function('s:noop'))
                                  call a:data['clean']()
    6              0.000003     endif
    9              0.000004   endif

FUNCTION  <SNR>49_SameBeginning()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2609
Called 11 times
Total time:   0.000207
 Self time:   0.000207

count  total (s)   self (s)
   11              0.000008   try
   11              0.000032     if !has_key(a:ctx1, "lnum") || !has_key(a:ctx2, "lnum")
                                  return v:false
   11              0.000004     endif
                              catch
                                call s:errlog("[ERR]", 'SameBeginning', v:exception)
                                " for E715
                                return v:false
   11              0.000008   endtry
   11              0.000079   if a:ctx1["startcol"] == a:ctx2["startcol"] && a:ctx1["lnum"] == a:ctx2["lnum"] && match(a:ctx2["typing"], a:ctx1["typing"]) == 0
   11              0.000009     return v:true
                              else
                                return v:false
                              endif

FUNCTION  <SNR>49_NormalizeSort()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2227
Called 3 times
Total time:   0.003875
 Self time:   0.000048

count  total (s)   self (s)
                              " 实测 Lua 比 python 快了 30 倍
                              " Lua 3   0.001079   0.000039
                              " Py  3   0.036487   0.020912
    3              0.000019   if g:env_is_nvim && has("nvim-0.5.0")
    3   0.003849   0.000022     return s:NormalizeSortLua(a:items)
                              elseif has("python3")
                                return s:NormalizeSortPY(a:items)
                              else
                                return s:NormalizeSortVIM(a:items)
                              endif

FUNCTION  easycomplete#StoreCompleteSourceItems()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1921
Called 3 times
Total time:   0.026113
 Self time:   0.000981

count  total (s)   self (s)
    3   0.021300   0.000043   let norm_menu_list = s:NormalizeMenulist(a:result, a:plugin_name)
    3              0.000006   if a:plugin_name == "tn"
                                let sort_menu_list = norm_menu_list
    3              0.000002   else
    3   0.003899   0.000025     let sort_menu_list = s:NormalizeSort(norm_menu_list)
    3              0.000002   endif
    3              0.000896   let g:easycomplete_source[a:plugin_name].complete_result = deepcopy(sort_menu_list)

FUNCTION  easycomplete#util#ConfigRoot()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:2397
Called 6 times
Total time:   0.000269
 Self time:   0.000269

count  total (s)   self (s)
    6              0.000252   let config_dir = expand('~/.config/vim-easycomplete')
    6              0.000011   return config_dir

FUNCTION  <SNR>62_lsp_send()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/client.vim:219
Called 5 times
Total time:   0.000720
 Self time:   0.000389

count  total (s)   self (s)
    5              0.000017   let l:ctx = get(s:clients, a:id, {})
    5              0.000007   if empty(l:ctx)
                                return -1
    5              0.000002   endif
                            
    5              0.000009   let l:request = { 'jsonrpc': '2.0' }
                            
    5              0.000007   if (a:type == s:send_type_request)
    3              0.000008     let l:ctx['request_sequence'] = l:ctx['request_sequence'] + 1
    3              0.000006     let l:request['id'] = l:ctx['request_sequence']
    3              0.000009     let l:ctx['requests'][l:request['id']] = l:request
    3              0.000005     if has_key(a:opts, 'on_notification')
    3              0.000011       let l:ctx['on_notifications'][l:request['id']] = a:opts['on_notification']
    3              0.000001     endif
    5              0.000002   endif
                            
    5              0.000007   if has_key(a:opts, 'id')
                                let l:request['id'] = a:opts['id']
    5              0.000002   endif
    5              0.000007   if has_key(a:opts, 'method')
    5              0.000011     let l:request['method'] = a:opts['method']
    5              0.000002   endif
    5              0.000006   if has_key(a:opts, 'params')
    5              0.000008     let l:request['params'] = a:opts['params']
    5              0.000002   endif
    5              0.000006   if has_key(a:opts, 'result')
                                let l:request['result'] = a:opts['result']
    5              0.000002   endif
    5              0.000006   if has_key(a:opts, 'error')
                                let l:request['error'] = a:opts['error']
    5              0.000002   endif
                            
    5              0.000061   let l:json = json_encode(l:request)
    5              0.000024   let l:payload = 'Content-Length: ' . len(l:json) . "\r\n\r\n" . l:json
                            
    5   0.000365   0.000034   call easycomplete#job#send(a:id, l:payload)
                            
    5              0.000008   if (a:type == s:send_type_request)
    3              0.000005     let l:id = l:request['id']
    3              0.000006     if get(a:opts, 'sync', 0) !=# 0
                                  let l:timeout = get(a:opts, 'sync_timeout', -1)
                                  if easycomplete#lsp#utils#_wait(l:timeout, {-> !has_key(l:ctx['requests'], l:request['id'])}, 1) == -1
                                    throw 'lsp#client: timeout'
                                  endif
    3              0.000001     endif
    3              0.000003     return l:id
    2              0.000001   else
    2              0.000001     return 0
                              endif

FUNCTION  <SNR>49_ResetCompletedItem()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2505
Called 7 times
Total time:   0.000181
 Self time:   0.000118

count  total (s)   self (s)
    7   0.000149   0.000086   if pumvisible() || easycomplete#pum#visible()
    3              0.000003     return
    4              0.000002   endif
    4              0.000019   let g:easycomplete_completed_item = {}

FUNCTION  <SNR>67_StopVisualAsyncRun()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/popup.vim:563
Called 41 times
Total time:   0.000286
 Self time:   0.000286

count  total (s)   self (s)
   41              0.000129   if exists('s:popup_visual_delay') && s:popup_visual_delay > 0
   41              0.000102     call timer_stop(s:popup_visual_delay)
   41              0.000019   endif

FUNCTION  easycomplete#util#StopAsyncRun()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:70
Called 33 times
Total time:   0.000494
 Self time:   0.000494

count  total (s)   self (s)
   33              0.000100   if exists('g:easycomplete_popup_timer') && g:easycomplete_popup_timer > 0
   31              0.000024     if g:env_is_nvim
   31              0.000179       call s:util_toolkit.stop_async_run()
                                else
                                  call timer_stop(g:easycomplete_popup_timer)
   31              0.000012     endif
   33              0.000013   endif
   33              0.000044   let g:easycomplete_popup_timer = 0

FUNCTION  <SNR>56_Noop()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:254
Called 3 times
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)

FUNCTION  <SNR>62_is_server_instantiated_notification()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/client.vim:289
Called 5 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    5              0.000011   return !has_key(a:notification, 'request')

FUNCTION  easycomplete#action#completion#do()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/action/completion.vim:8
Called 1 time
Total time:   0.005642
 Self time:   0.000047

count  total (s)   self (s)
    1   0.000168   0.000008   if empty(easycomplete#installer#GetCommand(a:opt['name']))
                                call easycomplete#complete(a:opt['name'], a:ctx, a:ctx['startcol'], [])
                                return v:true
    1              0.000000   endif
                            
    1   0.000241   0.000008   let l:info = easycomplete#util#FindLspServers()
    1   0.000106   0.000006   let l:ctx = easycomplete#context()
    1              0.000002   if empty(l:info['server_names'])
                                call easycomplete#complete(a:opt['name'], l:ctx, l:ctx['startcol'], [])
                                return v:true
    1              0.000000   endif
    1   0.005112   0.000010   call easycomplete#action#completion#LspRequest(l:info, a:opt['name'])
    1              0.000001   return v:true

FUNCTION  <SNR>40_NormalizeLogMsg()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:758
Called 6 times
Total time:   0.000413
 Self time:   0.000413

count  total (s)   self (s)
    6              0.000010   let l:args = a:000
    6              0.000006   let l:res = ""
    6              0.000010   if empty(a:000)
                                let l:res = ""
    6              0.000011   elseif len(a:000) == 1
                                if type(a:1) == type("")
                                  let l:res = a:1
                                elseif index([2,7,0], type(a:000))
                                  let l:res = string(a:1)
                                else
                                  let l:res = a:1
                                endif
    6              0.000003   else
   20              0.000025     for item in l:args
   14              0.000028       if type(item) == type("")
    8              0.000018         let l:res = l:res . " " . item
    6              0.000010       elseif type(item) == type(1)
    2              0.000008         let l:res = l:res . " " . string(item)
    4              0.000002       else
    4              0.000043         let l:res = l:res . " " . json_encode(item)
   14              0.000006       endif
   20              0.000054     endfor
    6              0.000003   endif
    6              0.000007   return l:res

FUNCTION  <SNR>62_lsp_is_error()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/client.vim:275
Called 30 times
Total time:   0.000300
 Self time:   0.000300

count  total (s)   self (s)
   30              0.000067   let l:vt = type(a:obj_or_response)
   30              0.000043   if l:vt == type('')
                                return len(a:obj_or_response) > 0
   30              0.000059   elseif l:vt == type({})
   30              0.000057     return has_key(a:obj_or_response, 'error')
                              endif
                              return 0

FUNCTION  <SNR>52_reset()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:1089
Called 26 times
Total time:   0.015943
 Self time:   0.000296

count  total (s)   self (s)
   26              0.000046   if !(g:easycomplete_pum_noselect)
   21   0.015347   0.000094     call s:select(1)
    5              0.000003   else
    5   0.000420   0.000026     call s:select(0)
   26              0.000010   endif

FUNCTION  <SNR>49_SnapShoot()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1363
Called 25 times
Total time:   0.003798
 Self time:   0.000513

count  total (s)   self (s)
   25              0.000047   if empty(a:000)
   25   0.003504   0.000219     let l:ctx = easycomplete#context()
                              else
                                let l:ctx = a:1
   25              0.000010   endif
   25              0.000174   let g:easycomplete_typing_ctx = deepcopy(l:ctx)

FUNCTION  <SNR>52_hl()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:101
Called 2 times
Total time:   0.000292
 Self time:   0.000292

count  total (s)   self (s)
    2              0.000004   if empty(s:easycomplete_hl_exec_cmd)
                                if easycomplete#util#IsGui()
                                  let dev = "gui"
                                else
                                  let dev = "cterm"
                                endif
                                let fuzzymatch_hl_group      = s:HLExists("EasyFuzzyMatch") ? "EasyFuzzyMatch" : "PmenuMatch"
                                let pmenu_kind_hl_group      = s:HLExists("EasyPmenuKind") ? "EasyPmenuKind"   : "PmenuKind"
                                let pmenu_extra_hl_group     = s:HLExists("EasyPmenuExtra") ? "EasyPmenuExtra" : "PmenuExtra"
                                let function_hl_group        = s:HLExists("EasyFunction") ? "EasyFunction"     : "Conditional"
                                let snippet_hl_group         = s:HLExists("EasySnippet") ? "EasySnippet"       : "Number"
                                let tabnine_hl_group         = s:HLExists("EasyTabNine") ? "EasyTabNine"       : "Character"
                                let pmenu_hl_group           = s:HLExists("EasyPmenu") ? "EasyPmenu"           : "Pmenu"
                                let keyword_hl_group         = s:HLExists("EasyKeyword") ? "EasyKeyword"       : "Define"
                                let module_hl_group          = s:HLExists("EasyModule") ? "EasyModule"         : "Function"
                                let pmenu_cursor_has_reverse = s:HasReverseHighlight("PmenuSel")
                                if s:HLExists("EasyFuzzyMatch")
                                  let fuzzymatch_bold_str = s:HasBold("EasyFuzzyMatch") ? "gui=bold" : ""
                                else
                                  let fuzzymatch_bold_str = s:HasBold("PmenuMatch") ? "gui=bold" : ""
                                endif
                                let pmenu_cursor_hl_group_fg = pmenu_cursor_has_reverse ? s:bgcolor("PmenuSel") : s:fgcolor("PmenuSel")
                                let pmenu_cursor_hl_group_bg = pmenu_cursor_has_reverse ? s:fgcolor("PmenuSel") : s:bgcolor("PmenuSel")
                            
                                if pmenu_cursor_hl_group_fg == "NONE"
                                  let pmenu_cursor_hl_group_fg = pmenu_cursor_has_reverse ? s:bgcolor("Pmenu") : s:fgcolor("Pmenu")
                                endif
                                if pmenu_cursor_hl_group_bg == "NONE"
                                  let pmenu_cursor_hl_group_bg = pmenu_cursor_has_reverse ? s:fgcolor("Pmenu") : s:bgcolor("Pmenu")
                                endif
                                if pmenu_cursor_hl_group_fg == "NONE"
                                  let pmenu_cursor_hl_group_fg = pmenu_cursor_has_reverse ? s:bgcolor("Normal") : s:fgcolor("Normal")
                                endif
                                if pmenu_cursor_hl_group_bg == "NONE"
                                  let pmenu_cursor_hl_group_bg = pmenu_cursor_has_reverse ? s:fgcolor("Normal") : s:bgcolor("Normal")
                                endif
                            
                                let fuzzymatch_fg = pmenu_cursor_has_reverse ? s:bgcolor(fuzzymatch_hl_group) : s:fgcolor(fuzzymatch_hl_group)
                                if fuzzymatch_fg == "NONE"
                                  let fuzzymatch_fg = pmenu_cursor_has_reverse ? s:bgcolor("Constant") : s:fgcolor("Constant")
                                endif
                            
                                let s:easycomplete_hl_exec_cmd = [ 'syntax region CustomFuzzyMatch matchgroup=Conceal start=/\%(§§\)\@!§/ matchgroup=Conceal end=/\%(§§\)\@!§/ concealends oneline keepend', 'syntax region CustomExtra      matchgroup=Conceal start=/\%(‰‰\)\@!‰/ matchgroup=Conceal end=/\%(‰‰\)\@!‰/ concealends oneline', 'syntax region CustomKind       matchgroup=Conceal start=/ϟ\([^ϟ]ϟ\)\@=/  matchgroup=Conceal end=/\(ϟ[^ϟ]\)\@<=ϟ/ concealends oneline', 'syntax region CustomFunction   matchgroup=Conceal start=/⊥\([^⊥]⊥\)\@=/  matchgroup=Conceal end=/\(⊥[^⊥]\)\@<=⊥/ concealends oneline', 'syntax region CustomSnippet    matchgroup=Conceal start=/∫\([^∫]∫\)\@=/  matchgroup=Conceal end=/\(∫[^∫]\)\@<=∫/ concealends oneline', 'syntax region CustomTabNine    matchgroup=Conceal start=/∮\([^∮]∮\)\@=/  matchgroup=Conceal end=/\(∮[^∮]\)\@<=∮/ concealends oneline', 'syntax region CustomKeyword    matchgroup=Conceal start=/♧\([^♧]♧\)\@=/  matchgroup=Conceal end=/\(♧[^♧]\)\@<=♧/ concealends oneline', 'syntax region CustomModule     matchgroup=Conceal start=/♤\([^♤]♤\)\@=/  matchgroup=Conceal end=/\(♤[^♤]\)\@<=♤/ concealends oneline', 'syntax region CustomNormal     matchgroup=Conceal start=/Φ\([^Φ]Φ\)\@=/  matchgroup=Conceal end=/\(Φ[^Φ]\)\@<=Φ/ concealends oneline', "hi CustomFuzzyMatch " . dev . "fg=" . fuzzymatch_fg . " " . fuzzymatch_bold_str, "hi CustomPmenuSel " . dev . "fg=" . pmenu_cursor_hl_group_fg . " " . dev . "bg=" . pmenu_cursor_hl_group_bg, "hi link CustomKind     " . pmenu_kind_hl_group, "hi link CustomExtra    " . pmenu_extra_hl_group, "hi link CustomFunction " . function_hl_group, "hi link CustomSnippet  " . snippet_hl_group, "hi link CustomTabNine  " . tabnine_hl_group, "hi link CustomNormal   " . pmenu_hl_group, "hi link CustomKeyword  " . keyword_hl_group, "hi link CustomModule   " . module_hl_group, "hi link Error Pmenu", ]
                                      " \ "hi Search guibg=NONE guifg=NONE ctermbg=NONE ctermfg=NONE",
    2              0.000001   endif
    2              0.000158   call win_execute(s:pum_window, join(s:easycomplete_hl_exec_cmd, "\n"))

FUNCTION  easycomplete#sources#vim#completor()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/vim.vim:18
Called 1 time
Total time:   0.005660
 Self time:   0.000007

count  total (s)   self (s)
    1   0.005660   0.000007   return easycomplete#DoLspComplete(a:opt, a:ctx)

FUNCTION  <SNR>49_CloseCompleteInfo()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1423
Called 17 times
Total time:   0.006690
 Self time:   0.000398

count  total (s)   self (s)
   17              0.000039   if g:env_is_nvim
   17   0.006584   0.000292     call easycomplete#popup#MenuPopupChanged([])
                              else
                                call easycomplete#popup#close("popup")
   17              0.000007   endif

FUNCTION  <lambda>329()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 8 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# 'textDocument/publishDiagnostics'

FUNCTION  <SNR>56_send_request_dispose()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:341
Called 3 times
Total time:   0.000111
 Self time:   0.000033

count  total (s)   self (s)
                              " dispose function may not have been created so check before calling
    3              0.000008   if has_key(a:ctx, 'dispose')
    3   0.000097   0.000019     call a:ctx['dispose']()
    3              0.000001   endif

FUNCTION  <lambda>90431()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 8 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# 'textDocument/publishDiagnostics'

FUNCTION  <lambda>90432()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 2 times
Total time:   0.000667
 Self time:   0.000014

count  total (s)   self (s)
                            return Callback(x['server'], x['response'])

FUNCTION  <lambda>90433()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 8 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# '$/vimlsp/lsp_server_exit' 

FUNCTION  <SNR>49_BackChecking()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:627
Called 25 times
Total time:   0.004372
 Self time:   0.001360

count  total (s)   self (s)
   25   0.003368   0.000506   let curr_ctx = easycomplete#context()
   25              0.000155   let old_ctx = deepcopy(g:easycomplete_typing_ctx)
                              " call s:SnapShoot(curr_ctx)
   25              0.000091   if empty(curr_ctx) || empty(old_ctx) | return v:false | endif
   25              0.000114   if get(curr_ctx, 'lnum') == get(old_ctx,'lnum') && strlen(get(old_ctx,'typed',"")) >= 2
   21              0.000049     if curr_ctx['typed'] ==# old_ctx['typed'][:-2]
                                  " 单行后退非到达首字母的后退
   11              0.000010       return v:true
   10              0.000004     endif
   10   0.000252   0.000103     if s:TrimEnd(curr_ctx['typed']) ==# s:TrimEnd(old_ctx['typed']) && strlen(curr_ctx['typed']) < strlen(old_ctx['typed'])
                                  " 单行回退只删除空格或者删除tab
                                  return v:true
   10              0.000004     endif
   10              0.000028     if curr_ctx['typed'] ==# old_ctx['typed'] && strlen(curr_ctx['line']) == strlen(old_ctx['line']) - 1
                                  " 单行在 Normal 模式下按下 s 键
                                  return v:true
   10              0.000003     endif
    4              0.000025   elseif get(curr_ctx,'lnum') == get(old_ctx,'lnum') && strlen(old_ctx['typed']) == 1 && strlen(curr_ctx['typed']) == 0
                                " 单行后退到达首字母的后退
    1              0.000002     return v:true
    3              0.000007   elseif old_ctx['lnum'] == curr_ctx['lnum'] + 1 && old_ctx['col'] == 1
                                " 隔行后退
                                return v:true
    3              0.000001   else
    3              0.000003     return v:false
   10              0.000004   endif
   10              0.000008   return v:false

FUNCTION  easycomplete#CompleteChanged()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1376
Called 24 times
Total time:   0.008862
 Self time:   0.002078

count  total (s)   self (s)
                              " 在 SecondMatchAction 时，这里获得的是changed之前的item
                              " 因此这里起作用的逻辑主要是菜单不变的情况下，只移动cursor，CompleteShow
                              " 是不会触发 showinfo 的动作的
                              " 还有一种情况会触发CompleteChanged，就是 SecondCompleteRendering
                              " 的时机，这时就要根据 noselect 配置来判断是否默认显示 info
   24              0.000037   if g:easycomplete_ghost_text
                                " 选中第一项和未选中时的 deleteHint 去掉
   24   0.000645   0.000124     if easycomplete#CompleteCursored()
   20   0.000109   0.000079       if easycomplete#IsBacking()
                                    " Do Nothing
    9   0.000057   0.000045       elseif easycomplete#pum#PumSelectedIndex() > 1
                                    call easycomplete#util#DeleteHint()
   20              0.000009       endif
    4              0.000080     elseif !empty(g:easycomplete_ghost_text_str)
                                  " 选择一圈后回到初始状态，未选中任何选项
                                  call easycomplete#util#timer_start("easycomplete#util#ShowHint", [g:easycomplete_ghost_text_str], 1)
   24              0.000010     endif
   24              0.000010   endif
   24   0.001410   0.000237   let item = deepcopy(easycomplete#GetCursordItem())
   24   0.000496   0.000349   call easycomplete#SetCompletedItem(item)
   24              0.000034   if empty(item)
    4   0.000894   0.000022     call s:CloseCompleteInfo()
    4              0.000003     return
   20              0.000008   endif
                              " call s:SnapShoot()
                              " 改成异步，避免按住tab时连续触发completechanged会频繁大量调用
   20   0.000564   0.000090   call s:StopAsyncRun()
   20   0.000888   0.000135   call s:AsyncRun("easycomplete#ShowCompleteInfoByItem", [item], 50)
   20   0.002967   0.000164   let l:event = g:env_is_vim ? v:event : easycomplete#pum#CompleteChangedEvnet()
                              " Hack 所有异步获取 document 时，需要暂存 event
   20              0.000248   let g:easycomplete_completechanged_event = deepcopy(l:event)

FUNCTION  <SNR>56_request_on_notification()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:1175
Called 3 times
Total time:   0.063952
 Self time:   0.000071

count  total (s)   self (s)
    3              0.000010   if a:ctx['cancelled'] | return | endif " caller already unsubscribed so don't bother notifying
    3              0.000006   let a:ctx['done'] = 1
    3   0.063547   0.000034   call a:ctx['next'](extend({ 'server_name': a:ctx['server_name'] }, a:data))
    3   0.000385   0.000017   call a:ctx['complete']()

FUNCTION  <SNR>56_send_notification()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:1063
Called 2 times
Total time:   0.000368
 Self time:   0.000039

count  total (s)   self (s)
    2              0.000007   let l:lsp_id = s:servers[a:server_name]['lsp_id']
    2              0.000006   let l:data = copy(a:data)
    2              0.000004   if has_key(l:data, 'on_notification')
                                let l:data['on_notification'] = '---funcref---'
    2              0.000001   endif
                              " call s:errlog("[LOG]", 'notification --->', l:lsp_id, a:server_name)
    2   0.000345   0.000016   call easycomplete#lsp#client#send_notification(l:lsp_id, a:data)

FUNCTION  easycomplete#ui#HighlightArgs()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/ui.vim:89
Called 2 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    2              0.000001   try
    2              0.000037     let val = 'hi ' . substitute(split(execute('hi ' . a:name), '\n')[0], '\<xxx\>', '', '')
                              catch /411/
                                return ""
    2              0.000001   endtry
    2              0.000002   return val

FUNCTION  <SNR>49_ShowCompleteInfoInSecondRendering()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2196
Called 9 times
Total time:   0.003989
 Self time:   0.000137

count  total (s)   self (s)
    9              0.000011   if !(g:easycomplete_pum_noselect)
    9              0.000032     call timer_start(2, { -> s:ShowCompleteInfoWithoutTimer() })
    9   0.003907   0.000055     if easycomplete#util#GetCurrentPluginName() == "ts"
                                  call timer_start(1, { -> easycomplete#sources#ts#CompleteChanged() })
    9              0.000004     endif
    9              0.000003   endif

FUNCTION  <SNR>56_request_send()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:432
Called 3 times
Total time:   0.000520
 Self time:   0.000036

count  total (s)   self (s)
    3              0.000008   if a:ctx['cancelled'] | return | endif " caller already unsubscribed so don't bother sending request
    3   0.000510   0.000026   let a:ctx['request_id'] = s:send_request(a:ctx['server_name'], a:ctx['request'])

FUNCTION  easycomplete#pum#CursoredItem()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:439
Called 147 times
Total time:   0.002378
 Self time:   0.002092

count  total (s)   self (s)
  147   0.001261   0.000975   if !s:pumvisible() | return {} | endif
  147              0.000237   if s:selected_i == 0 | return {} | endif
                              " Treesitter 开启时当前输入的 syntax token
                              " 破损的情况下会很卡，会出现报错，给 insertword
                              " 加上了定时器的关闭，缓解这个问题。
  147              0.000243   if s:selected_i > len(s:curr_items)
                                return {}
  147              0.000050   endif
  147              0.000213   return s:curr_items[s:selected_i - 1]

FUNCTION  easycomplete#lsp#client#send_request()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/client.vim:318
Called 3 times
Total time:   0.000432
 Self time:   0.000023

count  total (s)   self (s)
    3   0.000430   0.000021   return s:lsp_send(a:client_id, a:opts, s:send_type_request)

FUNCTION  easycomplete#util#FuncExists()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:406
Called 21 times
Total time:   0.000666
 Self time:   0.000666

count  total (s)   self (s)
   21              0.000018   try
   21              0.000290     call funcref(a:func_name)
   20              0.000225   catch /^Vim\%((\a\+)\)\=:E700/
   20              0.000091     return v:false
   21              0.000019   endtry
    1              0.000001   return v:true

FUNCTION  easycomplete#util#GetInfoByCompleteItem()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:259
Called 30 times
Total time:   0.395221
 Self time:   0.215253

count  total (s)   self (s)
   30   0.000503   0.000331   let t_plugin_name = s:GetPluginNameFromUserData(a:item)
   30              0.000042   if t_plugin_name == "tn"
                                let l:info = s:GetTabNineItemInfo(a:item)
                                return l:info
   30              0.000014   endif
   30   0.000834   0.000205   let t_sha = easycomplete#util#GetSha256(a:item)
   30              0.000025   let info = ""
 9358              0.007032   for item in a:all_menu
 9357              0.016472     if type(item) != type({})
                                  continue
 9357              0.002610     endif
 9357              0.017154     let i_plugin_name = get(item, 'plugin_name', '')
 9357   0.079834   0.049503     let i_plugin_name = s:GetPluginNameFromUserData(item)
 9357   0.206097   0.057261     let i_sha = easycomplete#util#GetSha256(item)
 9357              0.012113     if i_sha ==# t_sha && i_plugin_name ==# t_plugin_name
   29              0.000036       if has_key(item, "info")
   29              0.000069         let info = get(item, "info", [])
   29              0.000011       endif
   29              0.000013       break
 9328              0.002625     endif
 9358              0.018042   endfor
   30              0.000045   let max_height = 50
   30              0.000051   if type(info) == type("")
   30              0.000033     let info = [info]
   30              0.000011   endif
   30              0.000049   if len(info) > max_height
                                let info = info[0:50] + ["..."]
   30              0.000010   endif
   30              0.000023   return info

FUNCTION  easycomplete#util#GetLspPluginName()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:1699
Called 13 times
Total time:   0.005761
 Self time:   0.000154

count  total (s)   self (s)
   13   0.005708   0.000101   let plugin = call("easycomplete#util#GetLspPlugin", a:000)
   13              0.000031   let plugin_name = get(plugin, 'name', "")
   13              0.000012   return plugin_name

FUNCTION  <SNR>56_get_versioned_text_document_identifier()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:626
Called 2 times
Total time:   0.000089
 Self time:   0.000039

count  total (s)   self (s)
    2   0.000088   0.000038   return { 'uri': easycomplete#lsp#utils#get_buffer_uri(a:buf), 'version': a:buffer_info['version'], }

FUNCTION  <SNR>49_ShowCompleteInfoWithoutTimer()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1453
Called 10 times
Total time:   0.138729
 Self time:   0.000820

count  total (s)   self (s)
   10   0.000350   0.000085   if !easycomplete#CompleteCursored()
                                call s:CloseCompleteInfo()
                                return
   10              0.000005   endif
   10              0.000008   if g:env_is_nvim
   10   0.000247   0.000091     let item = easycomplete#pum#CursoredItem()
                              else
                                let item = complete_info()["items"][complete_info()['selected']]
   10              0.000003   endif
   10              0.000014   if empty(item)
                                call s:CloseCompleteInfo()
                                return
   10              0.000003   endif
   10   0.137127   0.000171   let info = easycomplete#util#GetInfoByCompleteItem(copy(item), g:easycomplete_menuitems)
   10              0.000026   let async = empty(info) ? v:true : v:false
   10   0.000316   0.000114   if easycomplete#util#ItemIsFromLS(item) && (async || index(["rb"], easycomplete#util#GetLspPluginName()) >= 0)
                                call s:StopAsyncRun()
                                call s:AsyncRun('easycomplete#action#documentation#LspRequest', [item], 2)
   10              0.000004   else
   10              0.000017     if type(info) == type("")
                                  let info = [info]
   10              0.000004     endif
                                " call s:ShowCompleteInfo(info)
   10   0.000413   0.000084     call easycomplete#popup#DoPopup(info, 0)
   10              0.000005   endif

FUNCTION  easycomplete#util#LspServerReady()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:2102
Called 3 times
Total time:   0.001651
 Self time:   0.000142

count  total (s)   self (s)
    3   0.000066   0.000047   let opt = easycomplete#GetCurrentLspContext()
    3   0.000477   0.000031   if empty(opt) || empty(easycomplete#installer#GetCommand(opt['name']))
                                " 当前并未曾注册过 LSP
                                return v:false
    3              0.000001   endif
    3   0.000638   0.000022   let l:info = easycomplete#util#FindLspServers()
    3   0.000444   0.000016   let l:ctx = easycomplete#context()
    3              0.000006   if empty(l:info['server_names'])
                                " LSP 启动失败
                                return v:false
    3              0.000001   endif
    3              0.000003   return v:true

FUNCTION  <SNR>12_Highlight_Matching_Pair()
    Defined: /usr/local/lib/nvim-macos-x86_64/share/nvim/runtime/plugin/matchparen.vim:45
Called 53 times
Total time:   0.003778
 Self time:   0.003197

count  total (s)   self (s)
   53              0.000254   if !exists("w:matchparen_ids")
                                let w:matchparen_ids = []
   53              0.000030   endif
                              " Remove any previous match.
   53   0.000899   0.000317   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   53              0.000192   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   53              0.000019   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   53              0.000119   let c_lnum = line('.')
   53              0.000089   let c_col = col('.')
   53              0.000045   let before = 0
                            
   53              0.000111   let text = getline(c_lnum)
   53              0.000214   let c_before = text->strpart(0, c_col - 1)->slice(-1)
   53              0.000142   let c = text->strpart(c_col - 1)->slice(0, 1)
   53              0.000614   let plist = split(&matchpairs, '.\zs[:,]')
   53              0.000125   let i = index(plist, c)
   53              0.000044   if i < 0
                                " not found, in Insert mode try character before the cursor
   53              0.000142     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   48              0.000093       let before = strlen(c_before)
   48              0.000045       let c = c_before
   48              0.000074       let i = index(plist, c)
   53              0.000025     endif
   53              0.000035     if i < 0
                                  " not found, nothing to do
   53              0.000039       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let save_cursor = getcurpos()
                                call cursor(c_lnum, c_col - before)
                                defer setpos('.', save_cursor)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              elseif exists("b:ts_highlight") && &syntax != 'on'
                                let s_skip = "match(v:lua.vim.treesitter.get_captures_at_cursor(), '" .. 'string\|character\|singlequote\|escape\|symbol\|comment' .. "') != -1"
                              else
                                " do not attempt to match when the syntax item where the cursor is
                                " indicates there does not exist a matching parenthesis, e.g. for shells
                                " case statement: "case $var in foobar)"
                                "
                                " add the check behind a filetype check, so it only needs to be
                                " evaluated for certain filetypes
                                if ['sh']->index(&filetype) >= 0 && synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "shSnglCase"}) >= 0
                                  return
                                endif
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom
                                if !g:matchparen_disable_cursor_hl
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[m_lnum, m_col]], 10))
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>57_subscribeListener()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:310
Called 3 times
Total time:   0.006921
 Self time:   0.000024

count  total (s)   self (s)
    3   0.005519   0.003458   call a:source(0, function('s:subscribeSourceCallback', [a:data]))
    3              0.000011   return function('s:subscribeDispose', [a:data])

FUNCTION  <SNR>49_LuaSnipSupports()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2415
Called 2 times
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
    2              0.000010   if !exists("g:easycomplete_snips_enable") || (exists("g:easycomplete_snips_enable") && g:easycomplete_snips_enable == 1)
    2              0.000005     if g:env_is_vim | return v:false | endif
    2              0.000036     let ls = v:lua.require("easycomplete.luasnip")
    2              0.000013     return ls.luasnip_installed()
                              else
                                return v:false
                              endif

FUNCTION  easycomplete#util#distinct()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:959
Called 1 time
Total time:   0.002704
 Self time:   0.002704

count  total (s)   self (s)
    1              0.000001   if g:env_is_nvim
    1              0.002695     let result_items = s:easycomplete_toolkit.distinct_keywords(a:menu_list)
                              else
                                let result_items = s:distinct_keywords(a:menu_list)
    1              0.000001   endif
    1              0.000001   return result_items

FUNCTION  easycomplete#popup#SignatureVisible()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/popup.vim:337
Called 26 times
Total time:   0.000172
 Self time:   0.000172

count  total (s)   self (s)
   26              0.000076   if g:easycomplete_popup_win["float"] && s:float_type == "signature"
                                return v:true
   26              0.000015   else
   26              0.000025     return v:false
                              endif
                            
                              " if empty(s:float_type) || empty(g:easycomplete_popup_win["float"])
                              "   return v:false
                              " else
                              "   return v:true
                              " endif

FUNCTION  <SNR>49_TabnineSupports()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2388
Called 12 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
   12              0.000031   return g:easycomplete_tabnine_enable && easycomplete#sources#tn#available()

FUNCTION  easycomplete#action#diagnostics#render()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/action/diagnostics.vim:27
Called 3 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
    3              0.000029   if s:response_ready == 1
                                call easycomplete#sign#render()
    3              0.000003   else
    3              0.000035     call timer_start(1000, { -> easycomplete#sign#render() })
    3              0.000002   endif

FUNCTION  easycomplete#sign#ClearSign()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sign.vim:110
Called 6 times
Total time:   0.001507
 Self time:   0.001507

count  total (s)   self (s)
                              " let lsp_server = server_info['server_names'][0]
                              " file:///...
    6              0.000008   try
    6              0.001460     exec "sign unplace * group=g999 file=" . expand("%:p")
                              catch
    6              0.000007   endtry

FUNCTION  easycomplete#lsp#send_request()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:257
Called 3 times
Total time:   0.007288
 Self time:   0.000099

count  total (s)   self (s)
    3              0.000029   let l:ctx = { 'server_name': a:server_name, 'request': copy(a:request), 'cb': has_key(a:request, 'on_notification') ? a:request['on_notification'] : function('s:Noop'), }
                            
    3   0.005750   0.003464   let l:ctx['dispose'] = easycomplete#lsp#callbag#pipe( easycomplete#lsp#request(a:server_name, a:request), easycomplete#lsp#callbag#subscribe({   'next':{d->l:ctx['cb'](d)},   'error':{e->s:send_request_error(l:ctx, e)},   'complete':{->s:send_request_dispose(l:ctx)}, }))

FUNCTION  easycomplete#ui#CmdlineCR()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/ui.vim:156
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000016   if (!exists("b:cs_searched") || b:cs_searched == v:false) && (getcmdtype() == '/' || getcmdtype() == '?')
                                let b:cs_searched = v:true
    1              0.000001   endif
    1              0.000004   return "\<CR>"

FUNCTION  easycomplete#util#BadBoy_Vim()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:1749
Called 200 times
Total time:   0.003677
 Self time:   0.001130

count  total (s)   self (s)
  200   0.003607   0.001060   return s:BadBoy.Vim(a:item, a:typing_word)

FUNCTION  easycomplete#util#DeleteHint()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:12
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000005   if g:env_is_vim | return | endif
    2              0.000014   call s:tabnine_toolkit.delete_hint()

FUNCTION  <SNR>78_HandleLspCallback()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/action/completion.vim:40
Called 1 time
Total time:   0.061921
 Self time:   0.000066

count  total (s)   self (s)
                              " call s:console('<--', 'lsp response', a:data)
    1   0.000008   0.000006   if easycomplete#IsBacking() | return | endif
    1   0.000101   0.000005   let l:ctx = easycomplete#context()
    1              0.000001   let l:word = l:ctx["typing"]
    1   0.000024   0.000009   if easycomplete#lsp#client#is_error(a:data) || !has_key(a:data, 'response') || !has_key(a:data['response'], 'result')
                                call easycomplete#complete(a:plugin_name, l:ctx, l:ctx['startcol'], [])
                                if a:plugin_name == "py"
                                  call s:log('Lsp Error', 'Please delete global pyls `rm /usr/local/bin/pyls` and reinstall pyls.')
                                else
                                  echom "lsp error response"
                                endif
                                return
    1              0.000000   endif
                            
    1   0.027503   0.000010   let l:result = s:GetLspCompletionResult(a:server_name, a:data, a:plugin_name, l:word)
    1              0.000002   let l:matches = l:result['matches']
    1              0.000001   let l:startcol = l:ctx['startcol']
                            
                              " TODO #398
                              " call s:console(v:lua.require("easycomplete.util").get_plain_items(l:matches))
    1   0.018761   0.000010   let l:matches = s:MatchResultFilterPipe(a:plugin_name, l:matches, l:ctx)
    1   0.015506   0.000008   call easycomplete#complete(a:plugin_name, l:ctx, l:startcol, l:matches)

FUNCTION  easycomplete#lsp#callbag#subscribe()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:296
Called 3 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
    3              0.000004   let l:data = {}
    3              0.000010   if a:0 > 0 && type(a:1) == type({}) " a:1 { next, error, complete }
    3              0.000013     if has_key(a:1, 'next') | let l:data['next'] = a:1['next'] | endif
    3              0.000010     if has_key(a:1, 'error') | let l:data['error'] = a:1['error'] | endif
    3              0.000010     if has_key(a:1, 'complete') | let l:data['complete'] = a:1['complete'] | endif
                              else " a:1 = next, a:2 = error, a:3 = complete
                                if a:0 >= 1 | let l:data['next'] = a:1 | endif
                                if a:0 >= 2 | let l:data['error'] = a:2 | endif
                                if a:0 >= 3 | let l:data['complete'] = a:3 | endif
    3              0.000001   endif
    3              0.000011   return function('s:subscribeListener', [l:data])

FUNCTION  easycomplete#sign#DiagHoverFlush()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sign.vim:78
Called 6 times
Total time:   0.000338
 Self time:   0.000154

count  total (s)   self (s)
    6   0.000244   0.000060   if easycomplete#ok('g:easycomplete_diagnostics_hover')
    6              0.000010     if g:easycomplete_diagnostics_popup == 1
                                  call easycomplete#popup#close("float")
                                  let g:easycomplete_diagnostics_popup = 0
    6              0.000004     endif
    6              0.000003   endif
    6              0.000011   let g:easycomplete_diagnostics_last_ln = 0
    6              0.000019   if exists("b:easycomplete_echo_lint_msg") && b:easycomplete_echo_lint_msg == 1
                                " 有 lint msg 的残留则清空，否则不应该做动作
                                echo ""
                                let b:easycomplete_echo_lint_msg = 0
    6              0.000003   endif

FUNCTION  <SNR>31_record()
    Defined: ~/.local/share/nvim/site/pack/packer/start/ctrlp.vim/autoload/ctrlp/mrufiles.vim:59
Called 3 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    3              0.000007 	if s:locked | retu | en
    3              0.000006 	let bufnr = a:bufnr + 0
    3              0.000006 	let bufname = bufname(bufnr)
    3              0.000006 	if bufnr > 0 && !empty(bufname)
                            		cal filter(s:mrbs, 'v:val != bufnr')
                            		cal insert(s:mrbs, bufnr)
                            		cal s:addtomrufs(bufname)
    3              0.000001 	en

FUNCTION  <SNR>78_MatchResultFilterPipe()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/action/completion.vim:88
Called 1 time
Total time:   0.018751
 Self time:   0.000064

count  total (s)   self (s)
    1   0.000011   0.000006   let lsp_ctx = easycomplete#GetCurrentLspContext()
    1              0.000002   if has_key(lsp_ctx, "filter")
                                let Fun_name = lsp_ctx["filter"]
    1              0.000000   else
    1              0.000003     if type(get(lsp_ctx, "constructor")) != type('')
                                  let fn_name = a:plugin_name
                                  let Fun_name = "easycomplete#sources#" . fn_name . "#filter"
    1              0.000000     else
    1              0.000002       let constructor_str = lsp_ctx["constructor"]
    1              0.000009       let Fun_name = substitute(constructor_str, "#constructor$", "#filter", "g")
    1              0.000000     endif
    1              0.000000   endif
    1   0.000035   0.000025   if !easycomplete#util#FuncExists(Fun_name)
                                return a:matches
    1              0.000000   endif
    1   0.018681   0.000009   return call(funcref(Fun_name), [a:matches, a:ctx])

FUNCTION  <SNR>49_GetCompleteCache()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2546
Called 11 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
   11              0.000055   return {'menu_items':get(g:easycomplete_menucache, a:word, []), 'start_pos':g:easycomplete_menucache["_#_2"] }

FUNCTION  <SNR>56_is_step_error()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:443
Called 27 times
Total time:   0.000727
 Self time:   0.000283

count  total (s)   self (s)
   27   0.000715   0.000270   return easycomplete#lsp#client#is_error(a:s.result[0]['response'])

FUNCTION  <SNR>40_GetPluginNameFromUserData()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:213
Called 9387 times
Total time:   0.030504
 Self time:   0.030504

count  total (s)   self (s)
 9387              0.013269   if has_key(a:item, "plugin_name")
 9387              0.013314     return get(a:item, "plugin_name", "")
                              endif
                              let user_data = easycomplete#util#GetUserData(a:item)
                              let plugin_name = get(user_data, "plugin_name", "")
                              return plugin_name

FUNCTION  <SNR>56_ensure_conf()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:837
Called 6 times
Total time:   0.010514
 Self time:   0.000146

count  total (s)   self (s)
    6              0.000012   let l:server = s:servers[a:server_name]
    6              0.000010   let l:server_info = l:server['server_info']
    6              0.000012   if has_key(l:server_info, 'workspace_config')
                                let l:workspace_config = l:server_info['workspace_config']
                                call s:send_notification(a:server_name, { 'method': 'workspace/didChangeConfiguration', 'params': {   'settings': l:workspace_config, } })
    6              0.000003   endif
    6   0.000136   0.000100   let l:msg = s:new_rpc_success('configuration sent', { 'server_name': a:server_name })
    6   0.008639   0.006811   call a:cb(l:msg)

FUNCTION  <SNR>49_ResetCompleteTaskQueue()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2330
Called 4 times
Total time:   0.012276
 Self time:   0.003630

count  total (s)   self (s)
    4              0.000159   let g:easycomplete_complete_taskqueue = []
    4   0.000613   0.000122   let l:ctx = easycomplete#context()
  124              0.000199   for name in keys(g:easycomplete_source)
  120   0.007118   0.001212     if s:CompleteSourceReady(name) && (s:NormalTrigger() || s:SemanticTriggerForPluginName(name))
   10   0.000313   0.000115       call s:SetCompleteTaskQueue(name, l:ctx, 1, 0)
  110              0.000047     else
  110   0.003067   0.001017       call s:SetCompleteTaskQueue(name, l:ctx, 0, 0)
  120              0.000061     endif
  124              0.000358   endfor

FUNCTION  easycomplete#action#completion#LspRequest()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/action/completion.vim:26
Called 1 time
Total time:   0.005102
 Self time:   0.000055

count  total (s)   self (s)
                              " call s:console("--> request")
    1              0.000003   let l:server_name = a:info['server_names'][0]
    1   0.005098   0.000051   call easycomplete#lsp#send_request(l:server_name, { 'method': 'textDocument/completion', 'params': {   'textDocument': easycomplete#lsp#get_text_document_identifier(),   'position': easycomplete#lsp#get_position(),   'context': { 'triggerKind': 1 } }, 'on_notification': function('s:HandleLspCallback', [l:server_name, a:plugin_name]) })

FUNCTION  easycomplete#sign#render()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sign.vim:427
Called 3 times
Total time:   0.004642
 Self time:   0.000916

count  total (s)   self (s)
    3              0.000563   let buflinenr = len(getbufline(bufnr(''),1,'$'))
    3              0.000018   if exists("a:1")
                                call easycomplete#sign#cache(a:1)
    3              0.000004   endif
    3   0.002101   0.000036   call easycomplete#sign#hold()
    3   0.000679   0.000091   call easycomplete#sign#ClearSign()
    3   0.000173   0.000080   let diagnostics = easycomplete#sign#GetCurrentDiagnostics()
    3   0.000036   0.000025   if easycomplete#sign#DiagnosticsIsEmpty(diagnostics)
    3   0.000677   0.000026     call easycomplete#sign#unhold()
    3   0.000136   0.000022     call easycomplete#sign#flush()
    3   0.000224   0.000021     call easycomplete#sign#DiagHoverFlush()
    3              0.000002     return
                              endif
                              let current_cache = g:easycomplete_diagnostics_cache[easycomplete#util#GetCurrentFullName()]
                              let uri = current_cache['params']['uri']
                              let l:count = 1
                              while l:count <= len(diagnostics)
                                let item = diagnostics[l:count-1]
                                let line = item['range']['start']['line'] + 1
                                let severity = get(item, "severity", 4)
                                if line > buflinenr
                                  " lsp 有时返回 buf 行数 + 1 行报错，比如提示缺少 endfunction，这里选择直
                                  " 接丢弃，目前没发现有严重超行显示的报错干扰编程的情况
                                  let l:count += 1
                                  continue
                                  let line = 1
                                endif
                                " sign place 1 line=10 name=error_holder file=/Users/bachi/ttt/ttt.vim
                                let fn = easycomplete#util#TrimFileName(uri)
                                let cmd = printf('sign place %s group=g999 line=%s name=%s file=%s', l:count, line, s:GetSignStyle(severity), fn )
                                call execute(cmd)
                                let l:count += 1
                                if l:count > 500 | break | endif
                              endwhile
                            
                              call easycomplete#sign#LintCurrentLine()
                              call easycomplete#sign#LintPopup()
                              call easycomplete#sign#unhold()

FUNCTION  easycomplete#util#IsCursorNextToLeftParen()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:1839
Called 170 times
Total time:   0.000895
 Self time:   0.000895

count  total (s)   self (s)
  170              0.000257   let line = getline('.')
  170              0.000187   let col = col('.')
  170              0.000216   if col > strlen(line)
  170              0.000119     return v:false
                              endif
                              let next_char = line[col - 1]
                              return next_char == '('

FUNCTION  <SNR>49_SnipSupports()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2404
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000002   if !exists("g:easycomplete_snips_enable")
                                let g:easycomplete_snips_enable = 1
    1              0.000000   endif
    1              0.000003   if g:easycomplete_snips_enable == 1 && exists("g:UltiSnipsDebugServerEnable")
                                return v:true
    1              0.000000   else
    1              0.000001     return v:false
                              endif

FUNCTION  easycomplete#util#GetSha256()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:222
Called 9387 times
Total time:   0.149464
 Self time:   0.088340

count  total (s)   self (s)
 9387   0.121936   0.060811   let user_data = easycomplete#util#GetUserData(a:item)
 9387              0.016896   let sha_code = get(user_data, "sha256", "")
 9387              0.006178   return sha_code

FUNCTION  <SNR>52_OpenFloatWindow()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:685
Called 4 times
Total time:   0.001882
 Self time:   0.000653

count  total (s)   self (s)
    4   0.001676   0.000447   let winid = nvim_open_win(a:buf, v:false, a:opts)
    4              0.000095   call setwinvar(winid, '&winhl', a:hl)
    4              0.000015   call setwinvar(winid, '&scrolloff', 0)
    4              0.000010   call setwinvar(winid, '&spell', 0)
    4              0.000009   call setwinvar(winid, '&number', 0)
    4              0.000009   call setwinvar(winid, '&wrap', 0)
    4              0.000015   call setwinvar(winid, '&signcolumn', "no")
                              " call setwinvar(winid, '&hlsearch', 0)
    4              0.000009   call setwinvar(winid, '&list', 0)
    4              0.000010   call setwinvar(winid, '&conceallevel', 3)
    4              0.000008   if exists("&pumblend")
    4              0.000011     call setwinvar(winid, '&winblend', &pumblend)
    4              0.000002   endif
    4              0.000004   return winid

FUNCTION  easycomplete#lsp#utils#is_remote_uri()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/utils.vim:36
Called 6 times
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
    6              0.000116   return a:uri =~# '^\w\+::' || a:uri =~# '^[a-z][a-z0-9+.-]*://'

FUNCTION  easycomplete#sources#vim#filter()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/vim.vim:27
Called 1 time
Total time:   0.018671
 Self time:   0.002113

count  total (s)   self (s)
    1              0.000001   let ctx = a:ctx
    1              0.000001   let matches = a:matches
    1              0.000005   if ctx['typed'] =~ "s:\\w\\{-}$"
                                " hack for vim-language-server:
                                "   s:<Tab> 和 s:abc<Tab> 匹配回来的 insertText 不应该带上 "s:"
                                "   g:b:l:a:v: 都是正确的，只有 s: 不正确
                                "   需要修改 word 为 insertText.slice(2)
                                let matches = map(copy(matches), function("s:VimHack_S_ColonMap"))
    1              0.000000   endif
    1              0.000006   if ctx['typed'] =~ '\(\w\+\.\)\{-1,}$' " VimDotTyping bugfix for #92
                                call filter(matches, function("s:VimHack_S_DotFilter"))
    1              0.000000   endif
    1   0.005527   0.000755   let matches = map(copy(matches), function("s:VimHack_A_DotMap"))
    1   0.013122   0.001336   let matches = map(copy(matches), function("easycomplete#util#FunctionSurffixMap"))
    1              0.000001   return matches

FUNCTION  <SNR>57_createComplete()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:265
Called 3 times
Total time:   0.000368
 Self time:   0.000062

count  total (s)   self (s)
    3              0.000003   if !a:data['end']
    3              0.000004     let a:data['end'] = 1
    3   0.000357   0.000051     call a:data['sink'](2, easycomplete#lsp#callbag#undefined())
    3              0.000001   endif

FUNCTION  easycomplete#util#ProfileStop()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:951
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
                              exec "profile pause"

FUNCTION  <SNR>49_TrimEnd()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:623
Called 20 times
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
   20              0.000142   return substitute(a:str, "^\\(.\\{\-}\\)\\s\\+$","\\1","g")

FUNCTION  easycomplete#popup#MenuPopupChanged()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/popup.vim:55
Called 37 times
Total time:   0.013685
 Self time:   0.003259

count  total (s)   self (s)
   37   0.004817   0.000335   let l:event = g:env_is_vim ? v:event : easycomplete#pum#CompleteChangedEvnet()
                              " 这两个 if 如果默认选中第一项的逻辑
                              " 一次 typingmatch 会触发多次MenuPopupChanged，一般会2次或者3次
                              " 这里应该避免多次相同事件同时发生
   37   0.002029   0.000334   let curr_item = easycomplete#GetCursordItem()
   37   0.000419   0.000323   if !empty(s:GetMenuInfoWinid()) && s:SamePositionAsLastTime() && easycomplete#util#SameItem(s:item, curr_item) && easycomplete#FirstSelectedWithOptDefaultSelected()
                                return
   37              0.000014   endif
                            
   37              0.000062   if g:env_is_nvim && empty(curr_item)
    6   0.000373   0.000037     call easycomplete#popup#close("popup")
   31   0.003087   0.000340   elseif g:env_is_nvim && easycomplete#FirstSelectedWithOptDefaultSelected() && !easycomplete#zizzing()
   21              0.000265     let s:item = deepcopy(curr_item)
   21   0.000882   0.000157     call easycomplete#popup#DoPopup(a:info, 1)
   10              0.000022   elseif g:env_is_vim && empty(l:event) && easycomplete#FirstSelectedWithOptDefaultSelected()
                                let s:item = deepcopy(curr_item)
                                call easycomplete#popup#DoPopup(a:info, 1)
   10   0.000093   0.000044   elseif g:env_is_nvim && !easycomplete#pum#visible() && empty(a:info)
                                call easycomplete#popup#close("popup")
   10              0.000004   else
   10              0.000030     if empty(l:event) && empty(g:easycomplete_completechanged_event) | return | endif
   10              0.000107     let s:event = empty(l:event) ? copy(g:easycomplete_completechanged_event) : copy(l:event)
   10              0.000119     let s:item = has_key(l:event, 'completed_item') ? copy(l:event.completed_item) : copy(easycomplete#GetCompletedItem())
                            
   10   0.000357   0.000062     call easycomplete#popup#DoPopup(a:info, g:easycomplete_popup_delay)
   37              0.000015   endif
   37              0.000048   let s:info = a:info

FUNCTION  <SNR>52_FullfillMarkedAbbr()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:1282
Called 1077 times
Total time:   0.007468
 Self time:   0.007468

count  total (s)   self (s)
 1077              0.002659   let added_spaces = a:max_length - strdisplaywidth(a:abbr)
 1077              0.003448   let res = (empty(a:abbr_marked) ? a:abbr : a:abbr_marked) . repeat(" ", added_spaces)
 1077              0.000754   return res

FUNCTION  easycomplete#InsertCharPre()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2847
Called 12 times
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
                              " backspace不会走到这里
   12              0.000086   let g:easycomplete_insert_char = v:char

FUNCTION  easycomplete#CursorHoldI()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2756
Called 5 times
Total time:   0.000513
 Self time:   0.000135

count  total (s)   self (s)
    5   0.000096   0.000060   if easycomplete#IsBacking()
                                " do nothting
    4   0.000376   0.000032   elseif easycomplete#tabnine#ready()
                                call s:LazyTabNineSuggestFire(30)
    5              0.000004   endif

FUNCTION  easycomplete#StopSecondCompleteGhostTimer()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2176
Called 25 times
Total time:   0.000270
 Self time:   0.000270

count  total (s)   self (s)
   25              0.000080   if !exists("g:easycomplete_second_complete_ghost_timer")
                                let g:easycomplete_second_complete_ghost_timer = 0
   25              0.000009   endif
   25              0.000034   if g:easycomplete_second_complete_ghost_timer > 0
    9              0.000025     call timer_stop(g:easycomplete_second_complete_ghost_timer)
    9              0.000014     let g:easycomplete_second_complete_ghost_timer = 0
   25              0.000009   endif

FUNCTION  <SNR>49_FirstCompleteRendering()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1986
Called 1 time
Total time:   0.034798
 Self time:   0.006165

count  total (s)   self (s)
    1   0.000011   0.000005   if easycomplete#util#NotInsertMode()
                                call s:flush()
                                return
    1              0.000000   endif
    1   0.000012   0.000006   call s:StopFirstCompleteRenderingTimer()
                              " 如果 copilot.nvim 已经给了提示，那么就暂停展示 pum
    1              0.000003   if exists("g:copilot_ready") && g:copilot_ready && copilot#copilot_snippet_ready()
                                call s:flush()
                                return
    1              0.000000   endif
    1   0.000104   0.000004   let l:ctx = easycomplete#context()
    1              0.000001   let typing_word = l:ctx["typing"]
    1              0.000001   if b:is_path_complete
                                let typing_word = easycomplete#util#GetFileName(l:ctx["typed"])
    1              0.000000   endif
    1              0.000001   let should_stop_render = 0
    1              0.000000   try
    1   0.000107   0.000005     if s:OrigionalPosition()
                                  " 如果 LSP 结果返回时没有前进 typing，就返回结果过滤呈现即可
    1              0.000001       let source_result = a:menuitems
                                elseif !empty(typing_word) && l:ctx["typed"] =~ "[a-zA-Z0-9#]$"
                                  " FirstTyping 已经发起 LSP Action，结果返回之前又前进 Typing，直接执行
                                  " easycomplete#typing() → s:CompleteTypingMatch()，叠加之前请求 LSP 的返
                                  " 回值后进行重新过滤呈现
                                  let source_result = a:menuitems + g:easycomplete_stunt_menuitems
                                else
                                  if (g:env_is_vim && !pumvisible()) || (g:env_is_nvim && !easycomplete#pum#visible())
                                    let should_stop_render = 1
                                  endif
    1              0.000000     endif
                            
    1              0.000002     if !should_stop_render && len(source_result) > 0
    1              0.000001       if b:is_path_complete
                                    let filtered_menu = deepcopy(source_result)
    1              0.000000       else
                                    " distinct 只去重 bufkeyword 和 dict
    1   0.004431   0.001727         let tmp_result = easycomplete#util#distinct(deepcopy(source_result))
    1              0.000003         let tt = reltime()
                                    " 过滤出 350 个字符是 17ms
    1   0.013130   0.000931         let filtered_menu = easycomplete#util#CompleteMenuFilter(tmp_result, typing_word, 350)
                                    " call s:console(reltimestr(reltime(tt)),len(filtered_menu))
    1              0.000001       endif
    1   0.004124   0.002088       let filtered_menu = map(filtered_menu, function("easycomplete#util#PrepareInfoPlaceHolder"))
    1              0.000002       let g:easycomplete_stunt_menuitems = filtered_menu
    1              0.000008       let result = filtered_menu[0 : g:easycomplete_maxlength]
    1              0.000002       if len(result) <= 10
                                    let result = easycomplete#util#uniq(result)
    1              0.000000       endif
                            
    1              0.000003       if len(result) == 1 && result[0]["word"] == typing_word && easycomplete#util#GetPluginNameFromUserData(result[0]) == "buf"
                                    let result = []
    1              0.000000       endif
                            
                                  " tabnine
    1   0.000034   0.000005       if easycomplete#sources#tn#available()
                                    let tabnine_result = easycomplete#sources#tn#GetGlobalSourceItems()
                                    let result = tabnine_result + copy(result)
    1              0.000000       endif
                            
                                  " Info: 调用 complete 有两种方法
                                  "    第一种是直接执行 complete, complete(a:start_pos, result)
                                  "    第二种是通过<Plug>Complete,easycomplete#_complete(a:start_pos, result)
                                  " 第一种优势是不会造成 mode() 的切换，避免 CmdlineEnter 和 CmdlineLeave
                                  " 事件发生，杜绝 statusline 的闪烁，缺点是不通过cmd队列来显示的话，容易
                                  " 在连续快速敲击键盘时渲染菜单动作的进程挤占，带来不必要的菜单render视觉破损
                                  " 第二种优势是通过事件队列来管理，菜单高速连续切换显示时比较流畅，但在首
                                  " 次FirstComplete当匹配菜单内容过大、计算量过重时，带来的延时会造成明显
                                  " 的 CmdlineEnter 和 CmdlineLeave，带来 statusline 闪烁。
                                  " 因此在 FirstComplete 时采用方法一，SecondComplete 采用方法二
    1   0.000030   0.000020       call easycomplete#tabnine#flush()
    1   0.011153   0.000008       noa call s:complete(a:start_pos, result)
    1   0.000038   0.000008       call easycomplete#util#timer_start("easycomplete#ShowCompleteInfoInFirstRendering", [], 45)
    1   0.000009   0.000006       call s:SetFirstCompeleHit()
    1              0.000001       if g:easycomplete_ghost_text
    1   0.000102   0.000013         let ghost_text = s:GetGhostText(a:start_pos, s:get(result,0,"word"))
    1   0.000051   0.000006         call easycomplete#util#ShowHint(ghost_text)
    1              0.000003         let g:easycomplete_ghost_text_str = ghost_text
    1              0.000000       endif
    1   0.001328   0.001254       call s:AddCompleteCache(s:GetTypingWord(), deepcopy(g:easycomplete_stunt_menuitems))
    1              0.000000     endif
    1   0.000061   0.000006     call s:LetCompleteTaskQueueAllDone()
                              catch
                                call s:errlog('[ERR]', 'FirstCompleteRendering', v:exception)
    1              0.000001   endtry

FUNCTION  <SNR>57_shareTalkbackCallback()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:349
Called 162 times
Total time:   0.005527
 Self time:   0.003848

count  total (s)   self (s)
  162              0.000137   if a:t == 2
                                let l:i = 0
                                let l:found = 0
                                while l:i < len(a:data['sinks'])
                                  if a:data['sinks'][l:i] == a:sink
                                    let l:found = 1
                                    break
                                  endif
                                  let l:i += 1
                                endwhile
                            
                                if l:found
                                  call remove(a:data['sinks'], l:i)
                                endif
                            
                                if empty(a:data['sinks'])
                                  call a:data['sourceTalkback'](2, easycomplete#lsp#callbag#undefined())
                                endif
  162              0.000067   else
  162   0.002843   0.001164     call a:data['sourceTalkback'](a:t, a:d)
  162              0.000066   endif

FUNCTION  easycomplete#util#ModifyInfoByMaxwidth()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:593
Called 28 times
Total time:   0.001623
 Self time:   0.001529

count  total (s)   self (s)
   28              0.000030   let border = " "
   28              0.000032   let maxwidth = a:maxwidth - 2
                            
   28              0.000047   if type(a:info) == type("")
   14              0.000021     if strlen(a:info) == 0
   14              0.000009       return ""
                                endif
                                if trim(a:info) =~ "^-\\+$"
                                  return a:info
                                endif
                                " 字符串长度小于 maxwidth
                                if strlen(a:info) <= maxwidth
                                  return border . a:info . border
                                endif
                                let span = maxwidth
                                let cursor = 0
                                let t_info = []
                                let t_line = ""
                            
                                " 字符串长度大于 maxwidth
                                while cursor <= (strlen(a:info) - 1)
                                  let t_line = t_line . a:info[cursor]
                                  if (cursor) % (span) == 0 && cursor != 0
                                    call add(t_info, border . t_line . border)
                                    let t_line = ""
                                  endif
                                  let cursor += 1
                                endwhile
                                if !empty(t_line)
                                  call add(t_info, border . t_line . border)
                                endif
                                " t_info is Array
                                return t_info
   14              0.000006   endif
                            
   14              0.000014   let t_maxwidth = 0 " 实际最大宽度
   14              0.000025   if type(a:info) == type([])
   14              0.000012     let t_info = []
   28              0.000030     for item in a:info
   14              0.000036       let modified_info_item = easycomplete#util#ModifyInfoByMaxwidth(item, maxwidth)
   14              0.000026       if type(modified_info_item) == type("")
   14              0.000022         if strlen(modified_info_item) > t_maxwidth
                                      let t_maxwidth = strlen(modified_info_item)
   14              0.000006         endif
   14              0.000034         call add(t_info, modified_info_item)
   14              0.000006       endif
   14              0.000022       if type(modified_info_item) == type([])
                                    let t_maxwidth = maxwidth
                                    let t_info = t_info + modified_info_item
   14              0.000005       endif
   28              0.000028     endfor
                            
                                " 构造分割线
   28              0.000051     for i in range(len(t_info))
   14              0.000022       let item = t_info[i]
                                  " 构造分割线
   14              0.000113       if trim(item) =~ "^-\\+$"
                                    if t_maxwidth < maxwidth
                                      let t_maxwidth += 1
                                    elseif t_maxwidth == maxwidth
                                      let t_maxwidth += 2
                                    endif
                                    let t_info[i] = repeat("─", t_maxwidth)
                                    break
   14              0.000005       endif
   28              0.000021     endfor
                            
                                " hack for vim popup menu scrollbar
   14              0.000019     if len(t_info) >= 2
                                  if t_info[-1] ==# ""
                                    unlet t_info[len(t_info)-1]
                                  endif
   14              0.000005     endif
   14              0.000012     return t_info
                              endif

FUNCTION  <lambda>25660()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 8 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# 'textDocument/publishDiagnostics'

FUNCTION  <lambda>25661()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 2 times
Total time:   0.000730
 Self time:   0.000030

count  total (s)   self (s)
                            return Callback(x['server'], x['response'])

FUNCTION  <SNR>56_update_file_content()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:705
Called 2 times
Total time:   0.000067
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000006   if !has_key(s:file_content, a:buf)
                                let s:file_content[a:buf] = {}
    2              0.000001   endif
    2   0.000049   0.000013   call s:errlog("[LOG]", 's:update_file_content()', a:buf)
    2              0.000007   let s:file_content[a:buf][a:server_name] = a:new

FUNCTION  easycomplete#sign#flush()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sign.vim:94
Called 24 times
Total time:   0.004801
 Self time:   0.000980

count  total (s)   self (s)
                              " call easycomplete#sign#DiagHoverFlush()
   24              0.000075   if !exists("g:easycomplete_diagnostics_cache")
                                let g:easycomplete_diagnostics_cache = {}
   24              0.000012   endif
   24   0.000327   0.000217   if empty(get(g:easycomplete_diagnostics_cache, easycomplete#util#GetCurrentFullName(), {}))
    6   0.000092   0.000064     let g:easycomplete_diagnostics_cache[easycomplete#util#GetCurrentFullName()] = {}
    6              0.000004     return
   18              0.000007   endif
   18   0.003807   0.000199   let server_info = easycomplete#util#FindLspServers()
   18              0.000073   if get(g:, 'easycomplete_sources_ts', 0) != 1 && empty(server_info['server_names'])
                                return
   18              0.000007   endif
   18   0.000263   0.000187   let g:easycomplete_diagnostics_cache[easycomplete#util#GetCurrentFullName()] = {}

FUNCTION  <SNR>52_InitBuffer()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:1150
Called 26 times
Total time:   0.003125
 Self time:   0.003125

count  total (s)   self (s)
   26              0.000051   if empty(s:pum_buffer)
                                let pum_buffer = s:CreateEmptyBuffer()
                                let s:pum_buffer = pum_buffer
   26              0.000011   endif
   26              0.002968   call nvim_buf_set_lines(s:pum_buffer, 0, -1, v:false, a:lines)

FUNCTION  easycomplete#util#NormalizeLspInfo()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:2082
Called 170 times
Total time:   0.005447
 Self time:   0.001957

count  total (s)   self (s)
  170   0.005391   0.001900   return s:NormalizeLspInfo(a:info)

FUNCTION  <lambda>26852()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 8 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# '$/vimlsp/lsp_server_exit' 

FUNCTION  easycomplete#util#errlog()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:2417
Called 6 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    6              0.000009   let args = a:000
    6              0.000039   call timer_start(1, { -> easycomplete#util#call("s:errlog", args)})

FUNCTION  <SNR>52_GetBufSize()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:1158
Called 26 times
Total time:   0.073441
 Self time:   0.000364

count  total (s)   self (s)
   26   0.073267   0.000191   let buffer_width = s:MaxLength(a:lines) + 1
   26              0.000062   let buffer_height = len(a:lines)
   26              0.000090   return {"width": buffer_width, "height": buffer_height}

FUNCTION  easycomplete#popup#DoPopup()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/popup.vim:414
Called 41 times
Total time:   0.001351
 Self time:   0.000698

count  total (s)   self (s)
   41   0.000496   0.000210   call s:StopVisualAsyncRun()
   41   0.000827   0.000460   call s:StartPopupAsyncRun(function("s:popup"), [a:info], a:delay)

FUNCTION  <SNR>52_CursorTop()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:653
Called 156 times
Total time:   0.000563
 Self time:   0.000563

count  total (s)   self (s)
  156              0.000508   return win_screenpos(win_getid())[0] + winline() - 1

FUNCTION  <SNR>52_CursorBottom()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:658
Called 73 times
Total time:   0.000687
 Self time:   0.000370

count  total (s)   self (s)
   73   0.000660   0.000343   return &lines - s:CursorTop()

FUNCTION  easycomplete#util#TrimFileName()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:1508
Called 18 times
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
   18              0.000132   return substitute(a:str, "^file:\/\/", "", "i")

FUNCTION  <SNR>49_BackingCompleteHandler()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:886
Called 12 times
Total time:   0.015875
 Self time:   0.002266

count  total (s)   self (s)
   12              0.000016   let g:easycomplete_backing = 1
   12              0.000861   let g:easycomplete_stunt_menuitems = []
   12   0.000282   0.000052   call s:zizz()
   12   0.001270   0.000056   let ctx = easycomplete#context()
                            
   12   0.000302   0.000094   if empty(ctx["typing"]) || empty(ctx['char']) || !s:SameBeginning(g:easycomplete_firstcomplete_ctx, ctx)
    1   0.000175   0.000017     noa call s:CloseCompletionMenu()
    1   0.005252   0.000040     call s:flush()
   11              0.000005   else
   11              0.000017     let g:easycomplete_stunt_menuitems = []
   11              0.000018     if !empty(g:easycomplete_menuitems)
   11   0.001652   0.000141       let g:easycomplete_stunt_menuitems = s:GetCompleteCache(s:GetTypingWordByGtx())['menu_items']
   11   0.001281   0.000118       let start_pos = col('.') - strlen(s:GetTypingWordByGtx())
   11              0.000103       let result = g:easycomplete_stunt_menuitems[0 : g:easycomplete_maxlength]
   11              0.000010       if g:env_is_nvim
   11              0.000023         if g:easycomplete_ghost_text && len(result) > 0
   11   0.000422   0.000076           let ghost_text = s:GetGhostText(start_pos, result[0]["word"])
   11   0.000358   0.000063           call easycomplete#util#ShowHint(ghost_text)
   11              0.000023           let g:easycomplete_ghost_text_str = ghost_text
   11              0.000005         endif
   11   0.003278   0.000106         noa call easycomplete#util#timer_start("easycomplete#pum#complete", [start_pos, result], 30)
   11   0.000179   0.000078         call easycomplete#sources#tn#SetGlobalSourceItems([])
   11              0.000072         noa call timer_start(31, { -> s:CloseCompleteInfo() && s:ShowCompleteInfoWithoutTimer()})
                                    " TODO here 这里的 easycomplete_pum_done 没执行？
                                    " pumvisible时的正常退回默认会关闭pum，关闭动作会触发completedone事件
                                    " 这里在nvim中模拟completedone事件
   11              0.000015         if !empty(result)
   11              0.000019           doautocmd <nomodeline> User easycomplete_pum_done
                                    else
                                      doautocmd <nomodeline> User easycomplete_pum_done
                                      call s:CloseCompleteInfo()
   11              0.000004         endif
                                  else
                                    noa silent! call complete(start_pos, result)
   11              0.000004       endif
   11              0.000004     endif
   12              0.000004   endif

FUNCTION  easycomplete#IsBacking()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:619
Called 31 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
   31              0.000065   return g:easycomplete_backing

FUNCTION  easycomplete#pum#WinScrolled()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:251
Called 2 times
Total time:   0.000465
 Self time:   0.000090

count  total (s)   self (s)
    2   0.000015   0.000010   if !s:pumvisible() | return | endif
    2              0.000006   if has_key(v:event, bufwinid(bufnr("")))
                                " 编辑窗口的移动
                                let cursor_left = s:CursorLeft()
                                let typing_word = easycomplete#util#GetTypingWord()
                                let new_startcol = getcurpos()[2] - strlen(typing_word)
                                let new_startcol = s:original_ctx["startcol"]
                                let lines = getbufline(s:pum_buffer, 1, "$")
                                let buffer_size = s:GetBufSize(lines)
                                let pum_pos = s:ComputePumPos(new_startcol, buffer_size)
                                let opts = deepcopy(s:default_pum_pot)
                                call extend(opts, pum_pos)
                                if new_startcol - v:event[bufwinid(bufnr(""))].leftcol <= 1
                                  let new_startcol = 1
                                  call timer_start(10, { -> s:RenderScroll() })
                                endif
                                call nvim_win_set_config(s:pum_window, opts)
                                let curr_item = easycomplete#pum#CursoredItem()
                                if !empty(curr_item)
                                  call easycomplete#ShowCompleteInfoByItem(curr_item)
                                endif
    2              0.000001   endif
                              " 当从 cmdline 触发时没有调用 WinScrolled，是因为cmdline激活状态时主屏渲染停滞
                              " 所以要注意在 select() 函数中手动触发一下RenderScrollThumb
    2              0.000003   if has_key(v:event, s:pum_window)
                                " pum 窗口的移动和滚动都会调用这里
    2   0.000384   0.000014     call s:RenderScrollThumb()
    2              0.000001   endif

FUNCTION  easycomplete#SnipSupports()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2392
Called 1 time
Total time:   0.000015
 Self time:   0.000005

count  total (s)   self (s)
    1   0.000014   0.000005   return s:SnipSupports()

FUNCTION  easycomplete#util#CompleteMenuFilter()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:1187
Called 17 times
Total time:   0.113820
 Self time:   0.113609

count  total (s)   self (s)
   17              0.000062   let word = a:word
   17              0.000038   if strlen(word) == 0
                                let l:result_menu = a:all_menu[0 : a:maxlength]
                                call sort(l:result_menu, "easycomplete#util#SortTextComparatorByLength")
                                for item in l:result_menu
                                  let item.abbr = easycomplete#util#parseAbbr(item.abbr)
                                endfor
                                return l:result_menu
   17              0.000011   endif
   17   0.000281   0.000149   if index(easycomplete#util#str2list(word), char2nr('.')) >= 0
                                let word = substitute(word, "\\.", "\\\\\\\\.", "g")
   17              0.000007   endif
   17              0.000031   if exists('*matchfuzzy')
   17              0.000028     let tt = reltime()
   17              0.000017     if g:env_is_nvim
                                  " 性能：576 个元素，n 是 550 耗时 2ms
   17              0.029238       let all_items = s:util_toolkit.trim_array_to_length(a:all_menu, a:maxlength + 130)
                                else
                                  " 性能：576 个元素，n 是 550  耗时 13ms
                                  let all_items = s:TrimArrayToLength(a:all_menu, a:maxlength + 130)
   17              0.000009     endif
                                " TODO here vim 里针对 g: 的匹配有 hack，word 前面减了两个字符，导致abbr
                                " 和 word 不是一一对应的，通过word fuzzy 匹配的位置无法正确应用在 abbr 上
                                " 这里只 hack 了 vim，其他类型的文件未测试
   17              0.000065     let key_name = (&filetype == "vim") ? "abbr" : "word"
   17              0.011965     let matching_res = all_items->matchfuzzypos(word, {'key': key_name, 'matchseq': 1, "limit": a:maxlength})
   17              0.000030     if g:env_is_nvim
                                  " 350 个元素，10ms
   17   0.071599   0.071520       let l:ret = s:util_toolkit.complete_menu_filter(matching_res, word)
   17              0.000036       return l:ret
                                else
                                  return s:CompleteMenuFilterVim(matching_res, word)
                                endif
                              else " for nvim(<=0.5.0)
                                " 完整匹配
                                let original_matching_menu = []
                                " 非完整匹配
                                let otherwise_matching_menu = []
                                " 模糊匹配结果
                                let otherwise_fuzzymatching = []
                            
                                " dam: 性能均衡参数，用来控制完整匹配和模糊匹配的次数均衡
                                " 通常情况下 dam 越大，完整匹配次数越多，模糊匹配次数就越少，速度越快
                                " 精度越好，但下面这两种情况往往会大面积存在
                                " - 大量同样前缀的单词拥挤在一起的情况，dam 越大越好
                                " - 相同前缀词较少的情况，完整匹配成功概率较小，尽早结束完整匹配性能
                                "   最好，这时 dam 越小越好
                                " 折中设置 dam 为 100, 时间复杂度控制在O(n)
                                let dam = 100
                                let regx_com_times = 0
                                let count_index = 0
                                let all_items = a:all_menu
                                let all_items_length = len(all_items)
                                let word_length = strlen(a:word)
                            
                                " 先找到全部匹配的列表
                                let l:count = 0
                                while count_index < dam && l:count < all_items_length
                                  let item = all_items[l:count]
                                  let item_word = get(item, 'matching_word', s:GetItemWord(item))
                                  if a:word[0] != "_" && item_word[0] == "_"
                                    let item_word = substitute(item_word, "_\\+", "", "")
                                  endif
                                  let l:count += 1
                                  if strlen(item_word) < word_length | continue | endif
                                  let regx_com_times += 1
                                  if stridx(toupper(item_word), toupper(word)) == 0
                                    call add(original_matching_menu, item)
                                    let count_index += 1
                                  elseif s:FuzzySearchRegx(word, item_word)
                                    call add(otherwise_fuzzymatching, item)
                                  else
                                    call add(otherwise_matching_menu, item)
                                  endif
                                endwhile
                            
                                if l:count + len(otherwise_fuzzymatching) > a:maxlength
                                  let maxlength = l:count + len(otherwise_fuzzymatching)
                                else
                                  let maxlength = a:maxlength
                                endif
                                " 再把模糊匹配的结果找出来
                                while l:count < all_items_length
                                  let item = all_items[l:count]
                                  let item_word = get(item, 'matching_word', s:GetItemWord(item))
                                  if a:word[0] != "_" && item_word[0] == "_"
                                    let item_word = substitute(item_word, "_\\+", "", "")
                                  endif
                                  let l:count += 1
                                  if strlen(item_word) < word_length | continue | endif
                                  if count_index > maxlength | break | endif
                                  if s:FuzzySearchRegx(word, item_word)
                                    call add(otherwise_fuzzymatching, item)
                                    let count_index += 1
                                  else
                                    call add(otherwise_matching_menu, item)
                                  endif
                                endwhile
                                if len(easycomplete#GetStuntMenuItems()) == 0
                                  call sort(original_matching_menu, "easycomplete#util#SortTextComparatorByLength")
                                endif
                                let result = original_matching_menu + otherwise_fuzzymatching
                                let filtered_menu = result
                                return filtered_menu
                              endif

FUNCTION  <SNR>52_RenderScrollBar()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:702
Called 26 times
Total time:   0.002287
 Self time:   0.000936

count  total (s)   self (s)
   26   0.000313   0.000206   if !s:pumvisible() || !s:HasScrollbar()
    5   0.000061   0.000024     call s:CloseScrollBar()
    5              0.000003     return
   21              0.000008   endif
                              " ScrollThumb 和 ScrollBar 共用一个 buffer
   21              0.000028   if empty(s:scrollbar_buffer)
                                let s:scrollbar_buffer = s:CreateEmptyBuffer()
                                let buflines = s:GetScrollBufflines()
                                call nvim_buf_set_lines(s:scrollbar_buffer, 0, -1, v:false, buflines)
   21              0.000007   endif
   21   0.001144   0.000128   let pos = s:ComputeScrollBarPos()
   21              0.000067   let scrollbar_opts = deepcopy(s:default_scroll_bar_pot)
   21              0.000052   call extend(scrollbar_opts, pos)
   21              0.000027   if empty(s:scrollbar_window)
    1              0.000002     let hl = "Normal:PmenuSbar,NormalNC:PmenuSbar,CursorLine:PmenuSbar,Search:EasyNone,NonText:PmenuSbar"
    1   0.000216   0.000026     let s:scrollbar_window = s:OpenFloatWindow(s:scrollbar_buffer, scrollbar_opts, hl)
   20              0.000008   else
                                " update scroll window
   20              0.000077     call nvim_win_set_config(s:scrollbar_window, scrollbar_opts)
   21              0.000008   endif

FUNCTION  <SNR>49_GetTypingWord()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2639
Called 210 times
Total time:   0.013640
 Self time:   0.001800

count  total (s)   self (s)
  210   0.013557   0.001717   return easycomplete#util#GetTypingWord()

FUNCTION  easycomplete#tabnine#LoadingStop()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/tabnine.vim:76
Called 25 times
Total time:   0.001383
 Self time:   0.000216

count  total (s)   self (s)
   25   0.001315   0.000148   if easycomplete#tabnine#ready()
                                call s:tabnine_toolkit.loading_stop()
   25              0.000008   endif

FUNCTION  easycomplete#util#timer_start()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:1133
Called 16 times
Total time:   0.003314
 Self time:   0.003314

count  total (s)   self (s)
   16              0.000017   if g:env_is_nvim
   16              0.003204     call s:util_toolkit.defer_fn(a:function_name, a:args, a:timeout)
                              else
                                call timer_start(a:timeout, { -> call(function(a:function_name), a:args) })
   16              0.000007   endif

FUNCTION  <SNR>56_new_rpc_success()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:1154
Called 30 times
Total time:   0.000184
 Self time:   0.000184

count  total (s)   self (s)
   30              0.000170   return { 'response': {     'message': a:message,     'data': extend({ '__data__': 'vim-lsp'}, a:data),   } }

FUNCTION  <SNR>67_GetMenuInfoWinid()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/popup.vim:88
Called 37 times
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
   37              0.000079   return g:easycomplete_popup_win["popup"]

FUNCTION  easycomplete#GetCursordItem()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:563
Called 61 times
Total time:   0.002867
 Self time:   0.000922

count  total (s)   self (s)
   61   0.001548   0.000335   if easycomplete#CompleteCursored()
   51              0.000042     if g:env_is_nvim
   51   0.001143   0.000410       return easycomplete#pum#CursoredItem()
                                else
                                  let l:item = complete_info()["items"][complete_info()['selected']]
                                  return l:item
                                endif
   10              0.000004   endif
   10              0.000010   return {}

FUNCTION  <SNR>49_CompleteTypingMatch()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:282
Called 11 times
Total time:   0.111830
 Self time:   0.009026

count  total (s)   self (s)
   11   0.000102   0.000076   if (empty(v:completed_item) && s:zizzing()) && !(s:VimColonTyping() || s:VimDotTyping())
                                return
   11              0.000004   endif
                            
   11              0.000032   let l:char = strpart(getline('.'), col('.') - 2, 1)
                            
                              " 非 ASCII 码时终止
   11              0.000019   if char2nr(l:char) < 33
                                call s:CloseCompletionMenu()
                                call s:flush()
                                return
   11              0.000004   endif
   11              0.000014   if char2nr(l:char) > 126
                                call timer_start(4, { -> s:CloseCompletionMenu() })
                                call s:flush()
                                return
   11              0.000004   endif
   11              0.000024   if !get(g:, 'easycomplete_first_complete_hit')
                                return
   11              0.000004   endif
                            
   11              0.000055   let word = exists('a:1') ? a:1 : s:GetTypingWord()
   11              0.000014   let local_menuitems = []
   11              0.000020   if !empty(g:easycomplete_stunt_menuitems)
   11              0.000018     let local_menuitems = g:easycomplete_stunt_menuitems
                              else
                                let local_menuitems = g:easycomplete_menuitems
   11              0.000004   endif
   11   0.097391   0.007290   let filtered_menu = easycomplete#util#CompleteMenuFilter(local_menuitems, word, 250)
   11   0.000499   0.000092   if easycomplete#sources#tn#available()
                                let tn_result = easycomplete#sources#tn#GetGlobalSourceItems()
   11              0.000004   else
   11              0.000012     let tn_result = []
   11              0.000004   endif
                              " 正常匹配为空，tabnine 结果也为空
   11              0.000025   if len(filtered_menu) == 0 && len(tn_result) == 0
                                " call s:log(">>>>>>>>>>>>>" . "匹配结果是空，导致pum关闭", "cword:", expand("<cword>"))
                                " 正常SecondComplete中无匹配词了就关掉 pum 了
                                if has('nvim')
                                  call s:CloseCompletionMenu()
                                  call s:CloseCompleteInfo()
                                else
                                  call s:CloseCompletionMenu()
                                endif
                                let g:easycomplete_stunt_menuitems = []
                                return
   11              0.000004   endif
                            
                              " 如果正常匹配为空，但还存在旧的 TN 占位符，则物理匹配旧的占位符
   11              0.000018   if len(filtered_menu) == 0 && len(tn_result) != 0
                                if &filetype == "vim"
                                  let word = split(word, "#")[-1]
                                endif
                                let tn_result = easycomplete#util#CompleteMenuFilter(tn_result, word, 500)
                                if len(tn_result) == 0
                                  if has('nvim')
                                    call s:CloseCompletionMenu()
                                    call s:CloseCompleteInfo()
                                  else
                                    call s:CloseCompletionMenu()
                                  endif
                                  call easycomplete#sources#tn#SetGlobalSourceItems([])
                                else
                                  let start_pos = col('.') - strlen(word)
                                  " call s:SecondCompleteRendering(start_pos, tn_result)
                                  " 这里如果执行了匹配，tabnine 还会在 20ms
                                  " 后有一个返回，导致闪烁，因此这里也需要加一个延迟，而不应该直接
                                  " 执行 Rendering，和 SecondComplete中的逻辑一样
                                  call easycomplete#sources#tn#SetGlobalSourceItems(tn_result)
                                  let b:easycomplete_tn_match_done = 0
                                  call easycomplete#util#timer_start("easycomplete#UpdateTNPlaceHolder", [word], 20)
                                endif
                                let g:easycomplete_stunt_menuitems = []
                                return
   11              0.000004   endif
                            
                              " 如果在 VIM 中输入了':'和'.'，一旦没有匹配项，就直接清空
                              " g:easycomplete_menuitems，匹配状态复位
                              " 注意：这里其实区分了 跟随匹配 和 Tab 匹配两个不同的动作
                              " - 跟随匹配内容尽可能少，能匹配不出东西就保持空，尽可能少的干扰
                              " - Tab 匹配内容尽可能多，能多匹配就多匹配，交给用户去选择
   11              0.000031   if (len(filtered_menu) == 0) && (s:VimDotTyping() || s:VimColonTyping())
                                call s:CloseCompletionMenu()
                                call s:flush()
                                return
   11              0.000003   endif
   11              0.000037   let s:easycomplete_start_pos = col('.') - strlen(word)
                              " 为了防止抖动，加上判断 tabnine 是否存在占位，如果有则立即刷新 SecondComplete
                              " 如果没有则等 30 ms，尽量等 tabnine 有返回后再刷新，但 tabnine 不一定有返回
                              " 但可以尽可能多的缓解抖动问题
   11              0.000017   let l:fire_complete_immediately = v:true
   11   0.000545   0.000056   if easycomplete#sources#tn#available()
                                let l:tn_ph = easycomplete#sources#tn#GetGlobalSourceItems()
                                if empty(l:tn_ph)
                                  let l:fire_complete_immediately = v:false
                                endif
   11              0.000003   endif
   11              0.000010   if l:fire_complete_immediately
   11   0.012211   0.000430     call s:SecondComplete(s:easycomplete_start_pos, filtered_menu, g:easycomplete_menuitems, word)
                              else
                                call easycomplete#util#timer_start("easycomplete#SecondComplete", [   s:easycomplete_start_pos, filtered_menu, g:easycomplete_menuitems, word ], 25)
   11              0.000004   endif

FUNCTION  GetVimIndentIntern()
    Defined: /usr/local/lib/nvim-macos-x86_64/share/nvim/runtime/indent/vim.vim:41
Called 1 time
Total time:   0.000334
 Self time:   0.000334

count  total (s)   self (s)
                              " If the current line has line continuation and the previous one too, use
                              " the same indent.  This does not skip empty lines.
    1              0.000006   let cur_text = getline(v:lnum)
    1              0.000015   let cur_has_linecont = cur_text =~ s:lineContPat
    1              0.000004   if cur_has_linecont && v:lnum > 1 && getline(v:lnum - 1) =~ s:lineContPat
                                return indent(v:lnum - 1)
    1              0.000001   endif
                            
                              " Find a non-blank line above the current line.
    1              0.000003   let lnum = prevnonblank(v:lnum - 1)
                            
                              " The previous line, ignoring line continuation
    1              0.000004   let prev_text_end = lnum > 0 ? getline(lnum) : ''
                            
                              " If the current line doesn't start with '\' or '"\ ' and below a line that
                              " starts with '\' or '"\ ', use the indent of the line above it.
    1              0.000001   if !cur_has_linecont
    1              0.000009     while lnum > 0 && getline(lnum) =~ s:lineContPat
                                  let lnum = lnum - 1
    1              0.000002     endwhile
    1              0.000001   endif
                            
                              " At the start of the file use zero indent.
    1              0.000001   if lnum == 0
                                return 0
    1              0.000000   endif
                            
                              " the start of the previous line, skipping over line continuation
    1              0.000002   let prev_text = getline(lnum)
    1              0.000001   let found_cont = 0
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' or '"\ '
                              " after a line that doesn't (or g:vim_indent_cont if it exists).
    1              0.000003   let ind = indent(lnum)
                            
                              " In heredoc indenting works completely differently.
    1              0.000005   if has('syntax_items') 
    1              0.000005     let syn_here = synIDattr(synID(v:lnum, 1, 1), "name")
    1              0.000005     if syn_here =~ 'vimLetHereDocStop'
                                  " End of heredoc: use indent of matching start line
                                  let lnum = v:lnum - 1
                                  while lnum > 0
                            	let attr = synIDattr(synID(lnum, 1, 1), "name")
                            	if attr != '' && attr !~ 'vimLetHereDoc'
                            	  return indent(lnum)
                            	endif
                            	let lnum -= 1
                                  endwhile
                                  return 0
    1              0.000001     endif
    1              0.000004     if syn_here =~ 'vimLetHereDoc'
                                  if synIDattr(synID(lnum, 1, 1), "name") !~ 'vimLetHereDoc'
                            	" First line in heredoc: increase indent
                            	return ind + shiftwidth()
                                  endif
                                  " Heredoc continues: no change in indent
                                  return ind
    1              0.000000     endif
    1              0.000000   endif
                            
    1              0.000006   if cur_text =~ s:lineContPat && v:lnum > 1 && prev_text !~ s:lineContPat
                                let found_cont = 1
                                if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
                                  let ind = ind + shiftwidth() * 3
                                endif
    1              0.000007   elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
    1              0.000001   else
                                " A line starting with :au does not increment/decrement indent.
                                " A { may start a block or a dict.  Assume that when a } follows it's a
                                " terminated dict.
                                " ":function" starts a block but "function(" doesn't.
    1              0.000008     if prev_text !~ '^\s*au\%[tocmd]' && prev_text !~ '^\s*{.*}'
    1              0.000030       let i = match(prev_text, '\(^\||\)\s*\(export\s\+\)\?\({\|\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\|finall\%[y]\|def\|el\%[seif]\)\>\|fu\%[nction][! ]\)')
    1              0.000001       if i >= 0
                                    let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items') && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\|PatSep\)$'
                            	  let ind -= shiftwidth()
                            	endif
    1              0.000000       endif
    1              0.000000     endif
    1              0.000000   endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
    1              0.000009   let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
    1              0.000002   if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
    1              0.000000   endif
                            
                              " For a line starting with "}" find the matching "{".  Align with that line,
                              " it is either the matching block start or dictionary start.
                              " Use the mapped "%" from matchit to find the match, otherwise we may match
                              " a { inside a comment or string.
    1              0.000004   if cur_text =~ '^\s*}'
                                if maparg('%') != ''
                                  exe v:lnum
                                  silent! normal %
                                  if line('.') < v:lnum
                            	let ind = indent('.')
                                  endif
                                else
                                  " todo: use searchpair() to find a match
                                endif
    1              0.000001   endif
                            
                              " Look back for a line to align with
    1              0.000002   while lnum > 1
                                " Below a line starting with "}" find the matching "{".
    1              0.000003     if prev_text =~ '^\s*}'
                                  if maparg('%') != ''
                            	exe lnum
                            	silent! normal %
                            	if line('.') < lnum
                            	  let lnum = line('.')
                            	  let ind = indent(lnum)
                            	  let prev_text = getline(lnum)
                            	else
                            	  break
                            	endif
                                  else
                            	" todo: use searchpair() to find a match
                            	break
                                  endif
    1              0.000005     elseif prev_text =~ s:lineContPat
                                  " looks like a continuation like, go back one line
                                  let lnum = lnum - 1
                                  let ind = indent(lnum)
                                  let prev_text = getline(lnum)
    1              0.000001     else
    1              0.000001       break
                                endif
    1              0.000002   endwhile
                            
                              " Below a line starting with "]" we must be below the end of a list.
                              " Include a "}" and "},} in case a dictionary ends too.
    1              0.000005   if prev_text_end =~ '^\s*\(},\=\s*\)\=]'
                                let ind = ind - shiftwidth()
    1              0.000000   endif
                            
    1              0.000029   let ends_in_comment = has('syntax_items') && synIDattr(synID(lnum, len(getline(lnum)), 1), "name") =~ '\(Comment\|String\)$'
                            
                              " A line ending in "{" or "[" is most likely the start of a dict/list literal,
                              " indent the next line more.  Not for a continuation line or {{{.
    1              0.000007   if !ends_in_comment && prev_text_end =~ '\s[{[]\s*$' && !found_cont
                                let ind = ind + shiftwidth()
    1              0.000000   endif
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :endfor, :catch, :finally,
                              " :endtry, :endfun, :enddef, :else and :augroup END.
                              " Although ":en" would be enough only match short command names as in
                              " 'indentkeys'.
    1              0.000015   if cur_text =~ '^\s*\(endif\|endwh\|endfor\|endtry\|endfu\|enddef\|cat\|finall\|else\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
                                if ind < 0
                                  let ind = 0
                                endif
    1              0.000000   endif
                            
    1              0.000002   return ind

FUNCTION  <lambda>228()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 8 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# 'textDocument/publishDiagnostics'

FUNCTION  <lambda>229()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 2 times
Total time:   0.000669
 Self time:   0.000016

count  total (s)   self (s)
                            return Callback(x['server'], x['response'])

FUNCTION  easycomplete#job#send()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/job.vim:371
Called 5 times
Total time:   0.000331
 Self time:   0.000069

count  total (s)   self (s)
    5              0.000013   let l:opts = get(a:000, 0, {})
    5   0.000315   0.000053   call s:job_send(a:jobid, a:data, l:opts)

FUNCTION  <SNR>49_zizzing()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2583
Called 129 times
Total time:   0.000335
 Self time:   0.000335

count  total (s)   self (s)
  129              0.000273   return g:easycomplete_backing_or_cr == 1 ? v:true : v:false

FUNCTION  easycomplete#util#GetTypingWord()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:702
Called 246 times
Total time:   0.015684
 Self time:   0.015684

count  total (s)   self (s)
  246              0.000863   if exists("g:easycomplete_cmdline_typing") && g:easycomplete_cmdline_typing == 1
   10              0.000037     let start = getcmdpos() - 1
   10              0.000017     let line = getcmdline()
  236              0.000112   else
  236              0.000428     let start = col('.') - 1
  236              0.000404     let line = getline('.')
  246              0.000107   endif
  246              0.000200   let width = 0
                              " 正常情况这里取普通单词逻辑不应当变化
                              " 如果不同语言对单词组成字符界定不一，在主流程中处理
                              " 比如 vim 把 'g:abc' 对待为一个完整单词
  246              0.000633   if exists("g:easycomplete_cmdline_typing") && g:easycomplete_cmdline_typing == 1
   10              0.000014     let regx = '[a-zA-Z0-9_#:@]'
  236              0.000799   elseif index(["php", "javascript", "typescript"], &filetype) >= 0
                                let regx = '[$a-zA-Z0-9_#]'
  236              0.000377   elseif index(["lua"], &filetype) >= 0
                                let regx = '[$a-zA-Z0-9_]'
  236              0.000081   else
  236              0.000227     let regx = '[a-zA-Z0-9_#]'
  246              0.000088   endif
 1390              0.004895   while start > 0 && line[start - 1] =~ regx
 1144              0.001078     let start = start - 1
 1144              0.000936     let width = width + 1
 1390              0.001057   endwhile
  246              0.000576   let word = strpart(line, start, width)
  246              0.000213   return word

FUNCTION  easycomplete#sources#tn#SetGlobalSourceItems()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/tn.vim:113
Called 11 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
   11              0.000035   if !has_key(g:easycomplete_source, s:tn_name)
                                let g:easycomplete_source[s:tn_name] = { "complete_result" : [] }
   11              0.000004   endif
   11              0.000032   let g:easycomplete_source[s:tn_name].complete_result = a:items

FUNCTION  easycomplete#lsp#utils#step#start()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/utils/step.vim:17
Called 9 times
Total time:   0.018928
 Self time:   0.000024

count  total (s)   self (s)
    9   0.010285   0.007096   call s:next(a:steps, 0, [])

FUNCTION  easycomplete#pum#close()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:1138
Called 6 times
Total time:   0.002233
 Self time:   0.000106

count  total (s)   self (s)
    6   0.002228   0.000101   call s:flush()

FUNCTION  <SNR>52_PumPosition()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:845
Called 130 times
Total time:   0.005002
 Self time:   0.003934

count  total (s)   self (s)
  130   0.000961   0.000719   if s:pumvisible()
                                " pos 这里是窗口初始化时给的值，如果溢出屏幕，需要重新矫正
  130              0.000457     let pos = nvim_win_get_position(s:pum_window)
  130              0.000265     let h = nvim_win_get_height(s:pum_window)
  130              0.000229     let w = nvim_win_get_width(s:pum_window)
  130   0.001566   0.000740     if s:cmdline()
                                  let editor_height = &window
                                  let rel_row = editor_height - h - (g:easycomplete_winborder ? 2 : 0)
                                  let pos[0] = rel_row
                                  if pos[1] < 0
                                    let pos[1] = 0
                                  endif
  130              0.000055     endif
  130              0.000411     return {"pos":pos, "height": h, "width": w}
                              else
                                return {}
                              endif

FUNCTION  <SNR>62_on_stdout()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/client.vim:33
Called 5 times
Total time:   0.091041
 Self time:   0.002549

count  total (s)   self (s)
    5              0.000033   let l:ctx = get(s:clients, a:id, {})
                            
    5              0.000008   if empty(l:ctx)
                                return
    5              0.000003   endif
                            
    5              0.000008   if empty(l:ctx['buffer'])
    5              0.000053     let l:ctx['buffer'] = join(a:data, "\n")
                              else
                                let l:ctx['buffer'] .= join(a:data, "\n")
    5              0.000002   endif
                            
   10              0.000012   while 1
   10              0.000019     if l:ctx['content-length'] < 0
                                  " wait for all headers to arrive
    9              0.000055       let l:header_end_index = stridx(l:ctx['buffer'], "\r\n\r\n")
    9              0.000011       if l:header_end_index < 0
                                    " no headers found
    4              0.000003         return
    5              0.000002       endif
    5              0.000035       let l:headers = l:ctx['buffer'][:l:header_end_index - 1]
    5   0.000192   0.000051       let l:ctx['content-length'] = s:get_content_length(l:headers)
    5              0.000010       if l:ctx['content-length'] < 0
                                    " invalid content-length
                                    call s:errlog("[LOG]", 'on_stdout', a:id, 'invalid content-length')
                                    call s:lsp_stop(a:id)
                                    return
    5              0.000002       endif
    5              0.000051       let l:ctx['buffer'] = l:ctx['buffer'][l:header_end_index + 4:] " 4 = len(\r\n\r\n)
    6              0.000003     endif
                            
    6              0.000035     if len(l:ctx['buffer']) < l:ctx['content-length']
                                  " incomplete message, wait for next buffer to arrive
    1              0.000001       return
    5              0.000002     endif
                            
                                " we have full message
    5              0.000036     let l:response_str = l:ctx['buffer'][:l:ctx['content-length'] - 1]
    5              0.000009     let l:ctx['content-length'] = -1
                            
    5              0.000004     try
    5              0.001350       let l:response = json_decode(l:response_str)
                                catch
                                  call s:errlog("[ERR]", 's:on_stdout json_decode failed', v:exception)
    5              0.000004     endtry
                            
    5              0.000051     let l:ctx['buffer'] = l:ctx['buffer'][len(l:response_str):]
                            
    5              0.000010     if exists('l:response')
                                  " call appropriate callbacks
    5              0.000019       let l:on_notification_data = { 'response': l:response }
    5              0.000015       if has_key(l:response, 'method') && has_key(l:response, 'id')
                                    " it is a request from a server
                                    let l:request = l:response
                                    if has_key(l:ctx['opts'], 'on_request')
                                      call l:ctx['opts']['on_request'](a:id, l:request)
                                    endif
    5              0.000011       elseif has_key(l:response, 'id')
                                    " it is a request->response
    3              0.000014         if !(type(l:response['id']) == type(0) || type(l:response['id']) == type(''))
                                      " response['id'] can be number | string | null based on the spec
                                      call s:errlog("[ERR]", 'invalid response id. ignoring message', l:response)
                                      continue
    3              0.000001         endif
    3              0.000008         if has_key(l:ctx['requests'], l:response['id'])
    3              0.000012           let l:on_notification_data['request'] = l:ctx['requests'][l:response['id']]
    3              0.000001         endif
    3              0.000006         if has_key(l:ctx['opts'], 'on_notification')
                                      " call client's on_notification first
    3              0.000002           try
    3   0.009629   0.000038             call l:ctx['opts']['on_notification'](a:id, l:on_notification_data, 'on_notification')
                                      catch
                                        call s:errlog("[ERR]", 's:on_stdout client option on_notification() error', v:exception, v:throwpoint)
    3              0.000002           endtry
    3              0.000001         endif
    3              0.000010         if has_key(l:ctx['on_notifications'], l:response['id'])
                                      " call easycomplete#lsp#client#send({ 'on_notification }) second
    3              0.000002           try
    3   0.064031   0.000079             call l:ctx['on_notifications'][l:response['id']](a:id, l:on_notification_data, 'on_notification')
                                      catch
                                        call s:errlog("[ERR]", 's:on_stdout client request on_notification() error', v:exception, v:throwpoint)
    3              0.000003           endtry
    3              0.000012           unlet l:ctx['on_notifications'][l:response['id']]
    3              0.000002         endif
    3              0.000009         if has_key(l:ctx['requests'], l:response['id'])
    3              0.000006           unlet l:ctx['requests'][l:response['id']]
                                    else
                                      call s:errlog("[ERR]", 'cannot find the request corresponding to response: ', l:response)
    3              0.000002         endif
    2              0.000001       else
                                    " it is a notification
    2              0.000005         if has_key(l:ctx['opts'], 'on_notification')
    2              0.000001           try
    2   0.014827   0.000020             call l:ctx['opts']['on_notification'](a:id, l:on_notification_data, 'on_notification')
                                      catch
                                        call s:errlog("[ERR]", 's:on_stdout on_notification() error', v:exception, v:throwpoint)
    2              0.000001           endtry
    2              0.000001         endif
    5              0.000002       endif
    5              0.000002     endif
                            
    5              0.000023     if empty(l:response_str)
                                  " buffer is empty, wait for next message to arrive
                                  return
    5              0.000002     endif
    5              0.000019   endwhile

FUNCTION  <SNR>74_flush()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/tabnine.vim:93
Called 27 times
Total time:   0.000152
 Self time:   0.000152

count  total (s)   self (s)
   27              0.000110   if exists("s:tabnine_hint_snippet") && empty(s:tabnine_hint_snippet)
   27              0.000016     return
                              endif
                              if !easycomplete#tabnine#ready()
                                return
                              endif
                              call s:tabnine_toolkit.delete_hint()
                              call easycomplete#tabnine#SuggestFlagClear()
                              call easycomplete#tabnine#LoadingStop()
                              let s:tabnine_hint_snippet = []

FUNCTION  <SNR>80_GetKeywords()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/buf.vim:38
Called 1 time
Total time:   0.006959
 Self time:   0.001748

count  total (s)   self (s)
                              " 性能测试，3万个单词量级
                              " lua: 0.0644
                              " vim: 0.2573
    1   0.003569   0.000518   let bufkeyword_list = s:GetBufKeywordsList(a:typing)
    1   0.002178   0.000018   let dickeyword_list = s:GetDicKeywordsList(a:typing)
    1              0.000002   if g:env_is_nvim
    1              0.001206     return s:lua_toolkit.combine_list(bufkeyword_list, dickeyword_list)
                              else
                                return s:CombineList(bufkeyword_list, dickeyword_list)
                              endif

FUNCTION  <lambda>230()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 8 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# '$/vimlsp/lsp_server_exit' 

FUNCTION  <SNR>67_IsOverlay()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/popup.vim:382
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000002   let float_winid = g:easycomplete_popup_win['float']
    1              0.000002   if empty(float_winid) | return v:false | endif
                              if g:env_is_vim && empty(pum_getpos())
                                return v:false
                              elseif g:env_is_nvim && !easycomplete#pum#visible()
                                return v:false
                              endif
                              " if empty(pum_getpos()) | return v:false | endif
                              if empty(getwininfo(float_winid)) | return v:false | endif
                              let float_config = getwininfo(float_winid)[0]
                              let pum_config = g:env_is_vim ? pum_getpos() : easycomplete#pum#PumGetPos()
                              let overlay = v:false
                              if float_config.height != 1
                                if pum_config.row <= float_config.winrow && pum_config.row + pum_config.height - 1 >= float_config.winrow
                                  let overlay = v:true
                                endif
                                if pum_config.row <= float_config.winrow + float_config.height - 1 && pum_config.row + pum_config.height - 1 >= float_config.winrow + float_config.height - 1
                                  let overlay = v:true
                                endif
                              endif
                              let screen_line = winline() + (win_screenpos(win_getid())[0] - 1)
                              if (pum_config.row > screen_line && float_config.winrow > screen_line) || (pum_config.row < screen_line && float_config.winrow < screen_line) || (pum_config.row == screen_line && float_config.winrow > screen_line)
                                let overlay = v:true
                              endif
                              return overlay

FUNCTION  <SNR>52_PumDirection()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:866
Called 26 times
Total time:   0.002301
 Self time:   0.001281

count  total (s)   self (s)
   26              0.000039   let buffer_height = a:buffer_height
   26   0.000445   0.000127   let below_space = s:CursorBottom() - 1
   26   0.000201   0.000124   let above_space = s:CursorTop() - 1
                              
                              " #369: 尽量和 signature 不要重叠
   26   0.000811   0.000187   let signature_direction = easycomplete#popup#SignatureDirection()
   26              0.000044   if signature_direction == "below"
                                if above_space - (g:easycomplete_winborder ? 2 : 0) <= 6 " 顶部空间少于6个item
                                  if buffer_height - (above_space - (g:easycomplete_winborder ? 2 : 0)) < 0 " 顶部空间可以展开所有item
                                    return "above"
                                  else " 顶部空间太小，且item个数比顶部空间更多，一律在底部展示
                                    return "below"
                                  endif
                                else " 顶部空间大于 6 个item，一律在顶部展示
                                  return "above"
                                endif
   26              0.000034   elseif signature_direction == "above"
                                if below_space - (g:easycomplete_winborder ? 2 : 0) <= 6 " 底部空间少于 6 个item
                                  if buffer_height - (below_space - (g:easycomplete_winborder ? 2 : 0)) < 0 " 底部空间可以展开所有item
                                    return "below"
                                  else " 底部空间太小，且item个数比底部空间更多，一律在顶部展示
                                    return "above"
                                  endif
                                else " 底部空间大于6个item，一律在底部展示
                                  return "below"
                                endif
   26              0.000010   endif
                            
                              " 如果底部空间不够
   26              0.000031   if buffer_height > below_space
   21              0.000054     if below_space < 6 + (g:easycomplete_winborder ? 2 : 0) " 底部空间太小，小于 6，一律在上部展示
                                  return "above"
   21              0.000032     elseif below_space >= 10 && !g:easycomplete_winborder " 无边框时底部空间大于等于10，一律在底部展示
                                  return "below"
   21              0.000024     elseif below_space >= 12 && g:easycomplete_winborder " 有边框时底部空间大于等于12，一律在底部显示
   21              0.000014       return "below"
                                elseif buffer_height - (below_space - (g:easycomplete_winborder ? 2 : 0)) <= 3
                                  " 底部空间只藏了5个及以内的item，可以在底部展示
                                  return "below"
                                else " 底部空间不够且溢出5个以上的 item，就展示在上部
                                  return "above"
                                endif
    5              0.000011   elseif g:easycomplete_winborder && below_space <= 4 && buffer_height > below_space - 2
                                return "above"
    5              0.000009   elseif buffer_height == below_space && g:easycomplete_winborder && below_space <= 7
                                return "above"
    5              0.000008   elseif buffer_height == below_space && !g:easycomplete_winborder && below_space <= 6
                                return "above"
    5              0.000002   else " 如果底部空间足够
    5              0.000004     return "below"
                              endif

FUNCTION  easycomplete#ui#HighlightWordUnderCursor()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/ui.vim:126
Called 2 times
Total time:   0.000691
 Self time:   0.000201

count  total (s)   self (s)
    2              0.000025   if empty(g:easycomplete_cursor_word_hl) | return | endif
    2              0.000014   let disabled_ft = ["help", "qf", "fugitive", "nerdtree", "gundo", "diff", "fzf", "floaterm"]
    2              0.000018   if &diff || &buftype == "terminal" || index(disabled_ft, &filetype) >= 0
                                return
    2              0.000001   endif
    2   0.000181   0.000042   if s:IsSearchWord()
    1              0.000003     3match none
    1              0.000001     return
    1              0.000000   endif
    1              0.000007   if getline(".")[col(".")-1] !~# '[[:punct:][:blank:]]'
    1   0.000100   0.000005     let bgcolor = easycomplete#ui#GetBgColor("Search")
    1   0.000159   0.000022     let fgcolor = easycomplete#ui#GetFgColor("Search")
    1   0.000007   0.000004     let prefix_bg_key = easycomplete#util#IsGui() ? "guibg" : "ctermbg"
    1   0.000083   0.000012     let append_bg_str = s:IsSearchWord() ? join([prefix_bg_key, bgcolor], "=") : join([prefix_bg_key, "NONE"], "=")
    1   0.000011   0.000007     let prefix_fg_key = easycomplete#util#IsGui() ? "guifg" : "ctermfg"
    1   0.000050   0.000009     let append_fg_str = s:IsSearchWord() ? join([prefix_fg_key, fgcolor], "=") : join([prefix_fg_key, "NONE"], "=")
    1              0.000004     exec "hi clear EasyMatchWord"
    1              0.000006     exec "hi EasyMatchWord cterm=underline gui=underline " . append_bg_str . " " . append_fg_str
    1              0.000000     try
    1              0.000002       let cur_search_word = histget("search")
    1              0.000005       exec '3match' 'EasyMatchWord' '/\V\<'.expand('<cword>').'\>/'
                                catch
                                  " do nothing
    1              0.000001     endtry
                              else
                                3match none
    1              0.000000   endif

FUNCTION  <SNR>52_HLCursordFuzzyChar()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:519
Called 21 times
Total time:   0.009626
 Self time:   0.001628

count  total (s)   self (s)
   21              0.000041   if !empty(g:easycomplete_match_id)
   20              0.000014     try
   20              0.000024       if g:easycomplete_match_id != -1
   20              0.000063         call matchdelete(g:easycomplete_match_id, s:pum_window)
   20              0.000008       endif
                                catch /E802/
                                  echom ">>" . g:easycomplete_match_id . " " . v:exception
   20              0.000016     endtry
   21              0.000008   endif
   21   0.000153   0.000109   if !easycomplete#pum#CompleteCursored()
                                let g:easycomplete_match_id = 0
                                return
   21              0.000008   endif
   21   0.000395   0.000107   let selected_item = easycomplete#pum#CursoredItem()
   21              0.000058   let abbr_marked = get(selected_item, "abbr_marked", "")
   21              0.000054   let marked_position = get(selected_item, "marked_position", [])
   21              0.000031   if empty(abbr_marked)
                                let g:easycomplete_match_id = 0
                                return
   21              0.000007   endif
   21   0.007821   0.000154   let hl_p = s:ComputeHLPositions(abbr_marked, marked_position, a:prefix_length)
                              " let param_arr = map(copy(hl_p), { _, val -> [s:selected_i, val, 1]})
                              " 字符串 lamda 表达式比内联函数更快
   21              0.000187   let param_arr = map(copy(hl_p), "[s:selected_i, v:val, 1]")
   21              0.000219   let exec_str = "let g:easycomplete_match_id = matchaddpos('" . a:hl_group . "', " . string(param_arr) . ")"
   21              0.000012   try
   21              0.000266     call win_execute(s:pum_window, exec_str)
                              catch
                                " do nothing
   21              0.000014   endtry

FUNCTION  <SNR>56_get_lines()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:659
Called 2 times
Total time:   0.000210
 Self time:   0.000179

count  total (s)   self (s)
    2              0.000155   let l:lines = getbufline(a:buf, 1, '$')
    2   0.000045   0.000014   if s:get_fixendofline(a:buf)
    2              0.000006     let l:lines += ['']
    2              0.000001   endif
    2              0.000002   return l:lines

FUNCTION  <SNR>67_CloseByWindowType()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/popup.vim:753
Called 34 times
Total time:   0.000829
 Self time:   0.000829

count  total (s)   self (s)
   34              0.000055   let windowtype = a:win_type
   34              0.000026   if s:is_vim
                                if g:easycomplete_popup_win[windowtype]
                                  call popup_close(g:easycomplete_popup_win[windowtype])
                                  let g:easycomplete_popup_win[windowtype] = 0
                                endif
   34              0.000015   else
   34              0.000061     if g:easycomplete_popup_win[windowtype]
                                  let id = win_id2win(g:easycomplete_popup_win[windowtype])
                                  if id > 0
                                    let winid = g:easycomplete_popup_win[windowtype]
                                    " 这里的hack有一定的隐患，这里的timer有可能给completedone事件带来干扰
                                    " ref: #281
                                    if !(g:easycomplete_pum_noselect)
                                      let delay = 20
                                    else
                                      let delay = 30
                                    endif
                                    call timer_start(delay, { -> s:NvimCloseFloatWithPum(winid) })
                                  endif
                                  let g:easycomplete_popup_win[windowtype] = 0
                                  let s:last_winargs = []
   34              0.000014     endif
   34              0.000015   endif

FUNCTION  easycomplete#sign#DiagnosticsIsEmpty()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sign.vim:275
Called 6 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    6              0.000014   if empty(a:diagnostics)
    6              0.000010     return v:true
                              endif
                              let bufline = len(getbufline(bufnr(''),1,'$'))
                              if bufline == 0
                                return v:true
                              endif
                              let flag = v:true
                              let l:count = 0
                              while l:count < len(a:diagnostics)
                                let item = a:diagnostics[l:count]
                                if item['range']['start']['line'] + 1 <= bufline
                                  let flag = v:false
                                  break
                                endif
                                let l:count += 1
                              endwhile
                              return flag

FUNCTION  <SNR>49_AddCompleteCache()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2531
Called 12 times
Total time:   0.000271
 Self time:   0.000271

count  total (s)   self (s)
   12              0.000037   if !exists('g:easycomplete_menucache')
                                call s:SetupCompleteCache()
   12              0.000005   endif
                            
   12              0.000042   let start_pos = col('.') - strwidth(a:word)
   12              0.000046   if g:easycomplete_menucache["_#_1"] == line('.') && g:easycomplete_menucache["_#_2"] == start_pos
   12              0.000030     let g:easycomplete_menucache[a:word] = a:menulist
                              else
                                let g:easycomplete_menucache = {}
   12              0.000004   endif
   12              0.000025   let g:easycomplete_menucache["_#_1"] = line('.')  " line num
   12              0.000018   let g:easycomplete_menucache["_#_2"] = start_pos  " col num

FUNCTION  easycomplete#GetStuntMenuItems()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2461
Called 17 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
   17              0.000061   return g:easycomplete_stunt_menuitems

FUNCTION  <SNR>63_job_send()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/job.vim:215
Called 5 times
Total time:   0.000262
 Self time:   0.000262

count  total (s)   self (s)
                              " INFO 在一个window里切换 buffer 时，job 会停止
                              " Added by jayli
    5              0.000013   let l:jobinfo = get(s:jobs,a:jobid)
    5              0.000012   if empty(l:jobinfo) | return | endif
    5              0.000012   let l:close_stdin = get(a:opts, 'close_stdin', 0)
    5              0.000011   if l:jobinfo.type == s:job_type_nvimjob
    5              0.000003     try
    5              0.000061       call chansend(a:jobid, a:data)
                                catch
                                  " Bugfix: Can't send data to closed stream
    5              0.000004     endtry
    5              0.000005     if l:close_stdin
                                  call chanclose(a:jobid, 'stdin')
    5              0.000002     endif
                              elseif l:jobinfo.type == s:job_type_vimjob
                                " There is no easy way to know when ch_sendraw() finishes writing data
                                " on a non-blocking channels -- has('patch-8.1.889') -- and because of
                                " this, we cannot safely call ch_close_in().  So when we find ourselves
                                " in this situation (i.e. noblock=1 and close stdin after send) we fall
                                " back to using s:flush_vim_sendraw() and wait for transmit buffer to be
                                " empty
                                "
                                " Ref: https://groups.google.com/d/topic/vim_dev/UNNulkqb60k/discussion
                                try
                                  if has('patch-8.1.818') && (!has('patch-8.1.889') || !l:close_stdin)
                                    call ch_sendraw(l:jobinfo.channel, a:data)
                                  else
                                    let l:jobinfo.buffer .= a:data
                                    call s:flush_vim_sendraw(a:jobid, v:null)
                                  endif
                                  if l:close_stdin
                                    while len(l:jobinfo.buffer) != 0
                                      sleep 1m
                                    endwhile
                                    call ch_close_in(l:jobinfo.channel)
                                  endif
                                catch /^Vim\%((\a\+)\)\=:E631/
                                  " Channel msg sending error, terminated and do nothing
                                endtry
    5              0.000002   endif

FUNCTION  easycomplete#lsp#stream()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:1097
Called 8 times
Total time:   0.034398
 Self time:   0.000196

count  total (s)   self (s)
    8              0.000010   if a:0 == 0
                                return easycomplete#lsp#callbag#share(s:Stream)
    8              0.000004   else
    8   0.034356   0.000153     call s:Stream(a:1, a:2)
    8              0.000003   endif

FUNCTION  easycomplete#lsp#utils#uri_to_path()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/utils.vim:124
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000005     if has_key(s:uri_to_path_cache, a:uri)
    2              0.000004       return s:uri_to_path_cache[a:uri]
                                endif
                            
                                let s:uri_to_path_cache[a:uri] = s:decode_uri(a:uri[len('file://'):])
                                return s:uri_to_path_cache[a:uri]

FUNCTION  <SNR>56_FirstDifference()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:1347
Called 2 times
Total time:   0.002847
 Self time:   0.002847

count  total (s)   self (s)
    2              0.000009   let l:line_count = min([len(a:old), len(a:new)])
    2              0.000005   if l:line_count == 0 | return [0, 0] | endif
  722              0.000481   for l:i in range(l:line_count)
 1442              0.001476     if a:old[l:i] !=# a:new[l:i] | break | endif
  722              0.000380   endfor
    2              0.000003   if l:i >= l:line_count
                                return [l:line_count - 1, strchars(a:old[l:line_count - 1])]
    2              0.000001   endif
    2              0.000004   let l:old_line = a:old[l:i]
    2              0.000003   let l:new_line = a:new[l:i]
    2              0.000011   let l:length = min([strchars(l:old_line), strchars(l:new_line)])
    2              0.000002   let l:j = 0
    2              0.000004   while l:j < l:length
                                if strgetchar(l:old_line, l:j) != strgetchar(l:new_line, l:j) | break | endif
                                let l:j += 1
    2              0.000002   endwhile
    2              0.000003   return [l:i, l:j]

FUNCTION  easycomplete#util#GetCurrentPluginName()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:1005
Called 10 times
Total time:   0.004256
 Self time:   0.000077

count  total (s)   self (s)
   10   0.004251   0.000071   return call('easycomplete#util#GetLspPluginName', a:000)

FUNCTION  easycomplete#lsp#utils#get_buffer_path()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/utils.vim:138
Called 6 times
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
    6              0.000137   return expand((a:0 > 0 ? '#' . a:1 : '%') . ':p')

FUNCTION  easycomplete#installer#GetCommand()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/installer.vim:25
Called 4 times
Total time:   0.000605
 Self time:   0.000469

count  total (s)   self (s)
    4   0.000135   0.000021   if !easycomplete#ok('g:easycomplete_enable')
                                return ''
    4              0.000002   endif
    4   0.000071   0.000058   let opt = easycomplete#GetOptions(a:name)
    4              0.000008   if a:name == ""
                                return ''
    4              0.000002   endif
    4              0.000006   if empty(opt)
                                call easycomplete#util#info('[error]', 'GetCommand("' . a:name . '"): plugin options is null')
                                return ''
    4              0.000001   endif
    4              0.000008   let cmd = opt['command']
    4   0.000103   0.000093   let local_cmd = easycomplete#installer#LspServerDir() . '/' . a:name . '/' . cmd
    4              0.000232   if executable(local_cmd)
    4              0.000007     return local_cmd
                              endif
                              if executable(cmd)
                                return cmd
                              endif
                              return ''

FUNCTION  <SNR>52_ComputePumPos()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:943
Called 26 times
Total time:   0.008856
 Self time:   0.003311

count  total (s)   self (s)
   26   0.002479   0.000178   let pum_direction = s:PumDirection(a:buffer_size.height)
   26              0.000043   let s:pum_direction = pum_direction
   26              0.000026   let l:height = 0
   26              0.000037   let l:width = a:buffer_size.width
   26              0.000022   let l:row = 0
   26   0.000327   0.000124   let below_space = s:CursorBottom() - 1
   26   0.000427   0.000143   let below_space = s:TrimBelowHeight(below_space)
   26   0.000178   0.000105   let above_space = s:CursorTop() - 1
   26   0.000366   0.000130   let above_space = s:TrimAboveHeight(above_space)
   26   0.000257   0.000094   if s:cmdline()
    5              0.000007     let pum_direction = "above"
    5              0.000007     let above_space = &window - 1
    5   0.000072   0.000026     let above_space = s:TrimAboveHeight(above_space)
   26              0.000011   endif
   26              0.000034   if pum_direction == "below"
   21              0.000030     if a:buffer_size.height >= below_space " 需要滚动
   21              0.000024       let l:height = below_space
                                else
                                  let l:height = a:buffer_size.height
   21              0.000008     endif
   21   0.000137   0.000079     let l:row = s:CursorTop()
   26              0.000011   endif
   26              0.000028   if pum_direction == "above"
    5              0.000008     if a:buffer_size.height >= above_space " 需要滚动
                                  let l:height = above_space
    5              0.000002     else
    5              0.000007       let l:height = a:buffer_size.height
    5              0.000002     endif
    5   0.000039   0.000018     if s:cmdline()
    5              0.000008       let l:row = &window - l:height - 1
                                else
                                  let l:row = s:CursorTop() - l:height - 1
    5              0.000002     endif
   26              0.000009   endif
   26              0.000022   if g:easycomplete_winborder
   26              0.000026     if pum_direction == "below"
   21              0.000027       if a:buffer_size.height <= below_space - 2 " 无需滚动
                                    let s:has_scrollbar = 0
   21              0.000009       else
                                    " 需要滚动
   21              0.000022         let s:has_scrollbar = 1
   21              0.000009       endif
    5              0.000006     elseif pum_direction == "above"
    5              0.000007       if a:buffer_size.height <= above_space - 2 " 无需滚动
    5              0.000006         let s:has_scrollbar = 0
                                  else
                                    " 需要滚动
                                    let s:has_scrollbar = 1
    5              0.000002       endif
   26              0.000009     endif
                              else
                                if l:height < a:buffer_size.height
                                  " 判断是否应该出现 scrollbar
                                  let s:has_scrollbar = 1
                                  let l:width = a:buffer_size.width + 1
                                else
                                  let s:has_scrollbar = 0
                                endif
   26              0.000009   endif
                              " 计算相对于 editor 的 startcol
   26              0.000066   let offset = col('.') - a:startcol
   26   0.000286   0.000193   let realcol = s:CursorLeft() - offset
                              " 如果触碰到右壁，默认缩短，和 vim 保持一致，永远和字符对齐
   26              0.000050   let right_space = &columns - (realcol - 2)
   26              0.000051   if right_space < l:width + (g:easycomplete_winborder ? 2 : 0)
                                let l:width = right_space - (g:easycomplete_winborder ? 2 : 0)
                                if g:easycomplete_winborder && s:has_scrollbar == 1
                                  let s:has_scrollbar = 0
                                endif
   26              0.000009   endif
   26              0.000118   let pum_origin_opt = {"row": l:row, "col": realcol - 2, "width":  l:width, "height": l:height }
   26              0.000022   if g:easycomplete_winborder
   26   0.002597   0.000531     let l:pum_pos = s:SetWinBorder(pum_origin_opt, pum_direction)
                              else
                                let l:pum_pos = pum_origin_opt
   26              0.000009   endif
   26              0.000023   return l:pum_pos

FUNCTION  <SNR>52_CacheOpt()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:320
Called 2 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    8              0.000011   for item in ["hlsearch", "wrap", "spell"]
    6              0.000035     let s:original_opt[item] = eval("&" . item)
    8              0.000004   endfor
                              " let s:original_opt = {
                              "       \ "hlsearch": &hlsearch,
                              "       \ "wrap": &wrap,
                              "       \ "spell": &spell
                              "       \ }

FUNCTION  <SNR>52_OpenPum()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:214
Called 26 times
Total time:   0.123953
 Self time:   0.003500

count  total (s)   self (s)
   26   0.003300   0.000175   call s:InitBuffer(a:lines)
   26   0.073635   0.000194   let buffer_size = s:GetBufSize(a:lines)
   26   0.009102   0.000247   let pum_pos = s:ComputePumPos(a:startcol, buffer_size)
   26   0.000280   0.000133   if s:cmdline()
    5              0.000010     let pum_pos.row = &window
   26              0.000009   endif
   26              0.000103   let pum_opts = deepcopy(s:default_pum_pot)
   26              0.000090   call extend(pum_opts, pum_pos)
   26              0.000039   if empty(s:pum_window)
    2   0.000068   0.000009     call s:CacheOpt()
    2              0.000004     let hl = 'Normal:Pmenu,NormalNC:Pmenu,CursorLine:CustomPmenuSel,Search:EasyNone'
    2   0.001588   0.000014     let winid = s:OpenFloatWindow(s:pum_buffer, pum_opts, hl)
    2              0.000003     let s:pum_window = winid
    2   0.000304   0.000012     call s:hl()
    2              0.000016     let s:original_ctx = deepcopy(g:easycomplete_typing_ctx)
   24              0.000010   else
                                " 已经存在的 windowid 用 nvim_win_set_config
   24              0.000209     call nvim_win_set_config(s:pum_window, pum_opts)
   24              0.000209     let s:original_ctx = deepcopy(g:easycomplete_typing_ctx)
   24   0.010985   0.000111     doautocmd <nomodeline> User easycomplete_pum_completechanged
   26              0.000016   endif
   26   0.016172   0.000229   call s:reset()
   26              0.000158   call nvim_win_set_cursor(s:pum_window, [1, 0])
   26   0.002521   0.000235   call s:RenderScrollBar()
   26   0.003745   0.000170   call s:RenderScrollThumb()
                              " 缓解在 cmdline 中匹配查找时造成Search高亮的抖动
   26   0.000263   0.000116   if !(s:cmdline())
   21              0.000154     noa setl textwidth=0
   21              0.000103     noa setl completeopt=menu
   26              0.000012   endif
   26   0.000351   0.000218   if g:easycomplete_ghost_text && !(s:cmdline())
   21              0.000086     noa setlocal lazyredraw
   26              0.000010   endif

FUNCTION  easycomplete#lsp#utils#path_to_uri()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/utils.vim:98
Called 17 times
Total time:   0.000109
 Self time:   0.000109

count  total (s)   self (s)
   17              0.000059     if has_key(s:path_to_uri_cache, a:path)
   17              0.000036       return s:path_to_uri_cache[a:path]
                                endif
                            
                                if empty(a:path) || easycomplete#lsp#utils#is_remote_uri(a:path)
                                  let s:path_to_uri_cache[a:path] = a:path
                                  return s:path_to_uri_cache[a:path]
                                else
                                  let s:path_to_uri_cache[a:path] = s:encode_uri(a:path, 0, 'file://')
                                  return s:path_to_uri_cache[a:path]
                                endif

FUNCTION  easycomplete#util#InsertMode()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:673
Called 4 times
Total time:   0.000082
 Self time:   0.000047

count  total (s)   self (s)
    4   0.000080   0.000045   return !easycomplete#util#NotInsertMode()

FUNCTION  <SNR>57_mergeSourceCallback()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:62
Called 18 times
Total time:   0.002982
 Self time:   0.000583

count  total (s)   self (s)
   18              0.000015   if a:t == 0
                                call insert(a:data['sourceTalkbacks'], a:d, a:i)
                                let a:data['startCount'] += 1
                                if a:data['startCount'] == 1 | call a:data['sink'](0, a:data['talkback']) | endif
   18              0.000033   elseif a:t == 2 && !easycomplete#lsp#callbag#isUndefined(a:d)
                                let a:data['ended'] = 1
                                let l:j = 0
                                while l:j < a:data['n']
                                  if l:j != a:i && l:j < len(a:data['sourceTalkbacks']) && a:data['sourceTalkbacks'][l:j] != 0
                                    call a:data['sourceTalkbacks'][l:j](2, easycomplete#lsp#callbag#undefined())
                                  endif
                                  let l:j += 1
                                endwhile
                                call a:data['sink'](2, a:d)
   18              0.000013   elseif a:t == 2
                                let a:data['sourceTalkbacks'][a:i] = 0
                                let a:data['endCount'] += 1
                                if a:data['endCount'] == a:data['n'] | call a:data['sink'](2, easycomplete#lsp#callbag#undefined()) | endif
   18              0.000007   else
   18   0.002540   0.000142     call a:data['sink'](a:t, a:d)
   18              0.000007   endif

FUNCTION  <SNR>57_createNext()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:254
Called 3 times
Total time:   0.063513
 Self time:   0.000026

count  total (s)   self (s)
    3   0.063512   0.000024   if !a:data['end'] | call a:data['sink'](1, a:d) | endif

FUNCTION  easycomplete#sign#cache()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sign.vim:362
Called 18 times
Total time:   0.001643
 Self time:   0.000808

count  total (s)   self (s)
   18   0.000330   0.000190   let l:key = easycomplete#util#TrimFileName(a:response['params']['uri'])
   18              0.000049   let g:easycomplete_diagnostics_cache[l:key] = a:response
   18   0.000608   0.000176   let diagnostics = easycomplete#sign#GetCurrentDiagnostics()
   18   0.000419   0.000155   let diagnostics_result = easycomplete#sign#SetDiagnosticsIndexes(diagnostics)
                              " call easycomplete#sign#DiagHoverFlush()
   18              0.000025   if !empty(diagnostics_result)
                                call sort(diagnostics_result, 'easycomplete#sign#sort')
                                let g:easycomplete_diagnostics_cache[l:key]['params']['diagnostics'] = diagnostics_result
                                let tmp_diagnostics = g:easycomplete_diagnostics_cache[l:key]['params']['diagnostics']
                                let l:tmp_diagnostics_l = g:env_is_nvim ? s:lua_toolkit.sign_distinct(tmp_diagnostics) : easycomplete#sign#distinct(tmp_diagnostics)
                                let g:easycomplete_diagnostics_cache[l:key]['params']['diagnostics'] = l:tmp_diagnostics_l
   18              0.000007   endif

FUNCTION  <SNR>52_CursorLeft()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:663
Called 26 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
   26              0.000084   return win_screenpos(win_getid())[1] + wincol() - 1

FUNCTION  easycomplete#CursorMovedI()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2718
Called 25 times
Total time:   0.000253
 Self time:   0.000253

count  total (s)   self (s)
                              " 只是移动光标，没有修改buf
   25              0.000087   if exists("b:old_changedtick") && b:old_changedtick == b:changedtick
                                if g:env_is_nvim && easycomplete#pum#visible()
                                  call easycomplete#pum#close()
                                endif
                                call easycomplete#popup#CloseLintPopup()
   25              0.000009   endif

FUNCTION  easycomplete#sign#unhold()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sign.vim:314
Called 3 times
Total time:   0.000651
 Self time:   0.000636

count  total (s)   self (s)
    3   0.000038   0.000023   let current_fn = easycomplete#util#GetCurrentFullName()
    3              0.000013   if get(g:, "easycomplete_place_holder", 0) == 1
    3              0.000002     try
    3              0.000447       call execute("sign unplace 999 file=" . current_fn)
                                catch
    3              0.000003     endtry
    3              0.000002   endif
    3              0.000002   try
    3              0.000087     let sign_placed_list = sign_getplaced(current_fn)
                              catch /^Vim\%((\a\+)\)\=:E158/
                                let sign_placed_list = []
    3              0.000002   endtry
    3              0.000007   if empty(sign_placed_list)
                                return
    3              0.000002   endif
    3              0.000014   let sign_list = get(sign_placed_list[0],"signs", [])
    3              0.000005   if empty(sign_list)
    3              0.000002     return
                              endif
                              for item in sign_list
                                if item['id'] == 999 && item['name'] == 'place_holder'
                                  call sign_unplace('', {'buffer': bufnr(), "id": 999})
                                endif
                              endfor
                              let g:easycomplete_place_holder = 0

FUNCTION  <SNR>49_CompleteAdd()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2308
Called 5 times
Total time:   0.069974
 Self time:   0.002012

count  total (s)   self (s)
    5   0.069971   0.002009   return call("easycomplete#CompleteAdd", a:000)

FUNCTION  <SNR>63_on_stdout()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/job.vim:74
Called 5 times
Total time:   0.091574
 Self time:   0.000533

count  total (s)   self (s)
                              " call s:console("easycomplete, stdout", a:event, a:data)
    5              0.000039   if has_key(s:jobs, a:jobid)
    5              0.000018     let l:jobinfo = s:jobs[a:jobid]
    5              0.000015     if has_key(l:jobinfo.opts, 'on_stdout')
    5   0.091464   0.000423       call l:jobinfo.opts.on_stdout(a:jobid, a:data, a:event)
    5              0.000002     endif
    5              0.000002   endif

FUNCTION  easycomplete#BackSpace()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:927
Called 12 times
Total time:   0.000415
 Self time:   0.000415

count  total (s)   self (s)
   12              0.000113   if !exists("b:fast_bs_timer")
                                let b:fast_bs_timer = 0
   12              0.000010   endif
   12              0.000019   if b:fast_bs_timer > 0
   10              0.000040     call timer_stop(b:fast_bs_timer)
   12              0.000005   endif
   12              0.000114   let b:fast_bs_timer = timer_start(70, { -> s:FastBSTimerReset()})
                              " 回退过程中先处理 ghost_text 防止闪烁
                              " 在tabnine.lua 中的回退事件监听里处理了
   12              0.000031   return "\<C-H>"

FUNCTION  <SNR>49_ResetCompleteCache()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2518
Called 3 times
Total time:   0.000228
 Self time:   0.000089

count  total (s)   self (s)
    3              0.000017   if !exists('g:easycomplete_menucache') || empty(get(g:easycomplete_menucache, "_#_1"))
                                call s:SetupCompleteCache()
    3              0.000002   endif
                            
    3   0.000162   0.000023   let start_pos = col('.') - strwidth(s:GetTypingWord())
    3              0.000013   if g:easycomplete_menucache["_#_1"] != line('.') || g:easycomplete_menucache["_#_2"] != start_pos
    1              0.000003     let g:easycomplete_menucache = {}
    3              0.000001   endif
    3              0.000009   let g:easycomplete_menucache["_#_1"] = line('.')  " line num
    3              0.000006   let g:easycomplete_menucache["_#_2"] = start_pos  " col num

FUNCTION  easycomplete#TextChangedI()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2764
Called 25 times
Total time:   0.160631
 Self time:   0.003382

count  total (s)   self (s)
                              " 如果输入的字符是非法字符，则终止
   25              0.001236   let cc = getcharstr(1)
   25   0.000420   0.000261   if stridx(easycomplete#GetBindingKeys(), cc) == -1
                                return
   25              0.000011   endif
                            
   25   0.001187   0.000457   if !easycomplete#ok('g:easycomplete_enable')
                                return
   25              0.000009   endif
   25   0.000222   0.000148   if s:zizzing() | return | endif " 点击回车选中item后不直接complete()
   25              0.000025   if g:env_is_nvim
   25   0.001557   0.000174     call easycomplete#tabnine#LoadingStop()
   25              0.000010   endif
   25   0.000400   0.000120   call easycomplete#tabnine#flush()
                              " TextCHangedP 和 TextChangedI 是互斥的
   25   0.000342   0.000116   if g:env_is_nvim && easycomplete#pum#visible()
                                " TextChangedP
                                " nvim pum 在 tab select 过程中会触发 TextchangedI，原生 pum 不应当触发
                                " 这里加一个逻辑，阻止掉 tab selecting 过程中的 textchangedp和textchangedi
                                " 事件, vim 中的逻辑不受影响
   23   0.000163   0.000117     if easycomplete#pum#IsInsertingWord()
                                  " call easycomplete#pum#InsertAwake()
   23              0.000028     else
                                  " Fire easycomplete#TextChangedP()
                                  " 用事件队列比直接调用函数流畅度要更好
   23   0.154233   0.000090       doautocmd <nomodeline> User easycomplete_pum_textchanged_p
   23              0.000010     endif
    2              0.000001   else
                                " TextChangedI
    2              0.000005     if !exists("b:fast_bs_timer")
                                  let b:fast_bs_timer = 0
    2              0.000001     endif
    2              0.000002     if !b:fast_bs_timer
    2   0.000136   0.000012       call s:LazyFireTyping()
    2              0.000001     endif
    2   0.000062   0.000011     if easycomplete#ok('g:easycomplete_signature_enable')
    2   0.000047   0.000015       call easycomplete#action#signature#LazyRunHandle()
    2              0.000001     endif
    2              0.000003     let b:old_changedtick = b:changedtick
                                " s:BackChecking() 比对文本差异判断是否回退，比较慢
                                " b:fast_bs_timer 只用作判断是否刚按下<bs>
                                "if s:BackChecking()
    2              0.000002     if b:fast_bs_timer
                                  let g:easycomplete_backing = 1
    2              0.000001     endif
    2              0.000002     return ""
   23              0.000008   endif

FUNCTION  easycomplete#sources#snips#CompleteHandler()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/snips.vim:85
Called 1 time
Total time:   0.040191
 Self time:   0.001428

count  total (s)   self (s)
    1   0.000047   0.000006   if easycomplete#LuaSnipSupports()
    1              0.001365     let result = v:lua.require("easycomplete.luasnip").get_snip_items(a:typing, a:name, a:ctx)
    1   0.038734   0.000011     call easycomplete#complete(a:name, a:ctx, a:startcol, result)
                              elseif easycomplete#SnipSupports()
                                let suggestions = []
                                " 0.010s for these two function call
                                let snippets = UltiSnips#SnippetsInCurrentScope()
                                call UltiSnips#SnippetsInCurrentScope(1)
                            
                                for trigger in keys(snippets)
                                  try
                                    let description = get(snippets, trigger, "")
                                    let description = empty(description) ? "Snippet: " . trigger : description
                                    let snip_object = s:GetSnipObject(trigger, g:current_ulti_dict_info)
                                  catch /^Vim\%((\a\+)\)\=:E684/
                                    " trigger 有可能是 i|n 这类包含特殊字符情况
                                    continue
                                  endtry
                                  try
                                    " Vim 性能比 Python 快五倍
                                    let code_info = easycomplete#util#GetSnippetsCodeInfo(snip_object)
                                  catch
                                    if has("python3")
                                      let code_info = easycomplete#python#GetSnippetsCodeInfo(snip_object)
                                    else
                                      continue
                                    endif
                                  endtry
                                  let sha256_str = strpart(easycomplete#util#Sha256(trigger . string(code_info)), 0, 15)
                                  let user_data_json = {     'plugin_name': a:name,     'sha256': sha256_str,   }
                                  call add(suggestions, { 'word' : trigger, 'abbr' : trigger . '~', 'kind' : g:easycomplete_kindflag_snip, 'menu' : g:easycomplete_menuflag_snip, 'user_data': json_encode(user_data_json), 'info' : [description, "-----"] + s:CodeInfoFilter(code_info), 'user_data_json': user_data_json })
                                endfor
                                call easycomplete#complete(a:name, a:ctx, a:startcol, suggestions)
    1              0.000001   endif

FUNCTION  easycomplete#TextChangedP()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2852
Called 23 times
Total time:   0.152214
 Self time:   0.003371

count  total (s)   self (s)
   23              0.000048   if b:fast_bs_timer > 0
   12              0.000020     let g:easycomplete_backing = 1
   23              0.000011   endif
                            
   23              0.000079   if g:easycomplete_enable == 0 || !exists('b:old_changedtick')
                                return
   23              0.000008   endif
                            
   23              0.000037   if g:env_is_nvim && b:old_changedtick == b:changedtick
                                return
   23              0.000007   endif
                            
   23   0.000397   0.000204   if g:env_is_nvim && easycomplete#pum#visible() && easycomplete#pum#IsInsertingWord()
                                if g:easycomplete_ghost_text && !empty(g:easycomplete_ghost_text_str)
                                  call easycomplete#util#DeleteHint()
                                endif
                                return
   23              0.000008   endif
                            
                              " for #313，当判断是通过 tab 来插入word时，是不应该发生 textchangedp
                              " 事件的，但当文件很大或者很卡时，neovim 有可能会误触
                              " textchangedI，这是不应该的，这里做一层拦截
   23   0.000135   0.000107   if g:env_is_nvim && easycomplete#pum#IsInsertingWord()
                                return
   23              0.000007   endif
                            
   23   0.002837   0.000102   let l:ctx = easycomplete#context()
                            
                              "当前输入的字符长度为1，并且没有回退过，说明是tab匹配到一个函数`abc()`后敲击字符
                              "应该终止当前SecondComplete，而应当进入FirstComplete
   23              0.000067   if strlen(l:ctx["typing"]) == 1 && l:ctx["typed"][-1:] == ")" && g:easycomplete_backing == 0
                                call s:flush()
                                call s:StopZizz()
                                call timer_start(10, { -> s:LazyFireTyping() })
                                return
   23              0.000009   endif
                            
   23              0.000046   let line_length = strlen(l:ctx['typed'])
   23   0.000168   0.000127   let selected_item = easycomplete#GetCompletedItem()
   23              0.000031   if empty(selected_item)
    1              0.000001     let word_str_len = 0
   22              0.000009   else
   22              0.000050     let word_str_len = strlen(selected_item["word"])
   23              0.000008   endif
   23              0.000030   if b:old_changedtick == b:changedtick
                                " neovim 中 textchangedI and textchangedP 会在 Firstcomplete 时同时触发
   23              0.000107   elseif g:env_is_vim && easycomplete#CompleteCursored() && s:zizzing() && get(selected_item, "word", "") == l:ctx['typed'][line_length - word_str_len:line_length - 1]
                                " 直接按下 C-P 或者 C-N 不做任何处理
   23   0.000366   0.000166   elseif g:env_is_nvim && easycomplete#pum#visible() && !s:zizzing()
                                " custom pum 和 默认 pum 的行为不一致
                                " 默认 pum 在回退时都要先触发 completedone 然后关闭 pum，所以这里 hack
                                " 的比较麻烦，custom pum 就不用这么麻烦，直接这里判断是否是回退即可
   23              0.000062     let g:easycomplete_start = reltime()
                                " 判断是否为回退
   23   0.004245   0.000186     if s:BackChecking()
   12              0.000017       let g:easycomplete_backing = 1
   12   0.016015   0.000141       call s:BackingCompleteHandler()
   12   0.001760   0.000093       call s:SnapShoot()
   11              0.000005     else
   11              0.000014       let g:easycomplete_backing = 0
                                  " 首次激发不走这里的逻辑，走 Textchangedi 里的逻辑
   11   0.001622   0.000064       if s:OrigionalPosition() || g:easycomplete_first_complete_hit != 1
                                    return
   11              0.000005       else
   11   0.122558   0.000072         call s:CompleteMatchAction()
   11              0.000005       endif
   23              0.000008     endif
   23              0.000032     let b:old_changedtick = b:changedtick
                              elseif g:env_is_vim && pumvisible() && !s:zizzing()
                                " tabnine, 空格 trigger 出的 tabnine menu 敲入字母后的逻辑
                                if len(easycomplete#GetStuntMenuItems()) == 0 && s:TabnineSupports()
                                  " nvim 中的 paste text 行为异常，空格弹出 pum 后直接 paste 时，c-y 会把
                                  " 菜单关掉的同时也把 pasted text 清空，应该是nvim的bug，这里用c-x,c-z 代替
                                  if has('nvim') && empty(g:easycomplete_insert_char)
                                    call timer_start(50, { -> s:SendKeys("\<C-X>\<C-Z>")})
                                  else
                                    call s:CloseCompletionMenu()
                                  endif
                                  call s:flush()
                                  call s:StopZizz()
                                  call easycomplete#TextChangedI()
                                  return
                                endif
                                if s:OrigionalPosition() || g:easycomplete_first_complete_hit != 1
                                  call s:SnapShoot()
                                  return
                                endif
                                let g:easycomplete_start = reltime()
                                let delay = len(g:easycomplete_stunt_menuitems) > 180 ? (g:env_is_iterm && g:env_is_vim ? 35 : (g:env_is_nvim ? 10 : 20)) : (has("nvim") ? 2 : 4)
                                call s:StopAsyncRun()
                                " 异步执行的目的是避免快速频繁输入字符时的complete渲染扎堆带来的视觉破损，
                                " 不能杜绝，但能大大缓解
                                call s:AsyncRun('easycomplete#CompleteMatchAction', [], delay)
                                let b:old_changedtick = b:changedtick
   23              0.000009   endif

FUNCTION  <SNR>57_subscribeDispose()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:323
Called 3 times
Total time:   0.000078
 Self time:   0.000044

count  total (s)   self (s)
    3   0.000076   0.000043   if has_key(a:data, 'talkback') | call a:data['talkback'](2, easycomplete#lsp#callbag#undefined()) | endif

FUNCTION  easycomplete#SetCompletedItem()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:606
Called 24 times
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
   24              0.000137   let g:easycomplete_completed_item = a:item

FUNCTION  <SNR>56_ExtractText()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:1395
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    2              0.000005   if a:start_line == len(a:lines) + a:end_line
    1              0.000002     if a:end_line == 0 | return '' | endif
    1              0.000002     let l:line = a:lines[a:start_line]
    1              0.000003     let l:length = strchars(l:line) + a:end_char - a:start_char + 1
    1              0.000002     return strcharpart(l:line, a:start_char, l:length)
    1              0.000000   endif
    1              0.000004   let l:result = strcharpart(a:lines[a:start_line], a:start_char) . "\n"
    1              0.000003   for l:line in a:lines[a:start_line + 1:a:end_line - 1]
                                let l:result .= l:line . "\n"
    1              0.000001   endfor
    1              0.000001   if a:end_line != 0
    1              0.000002     let l:line = a:lines[a:end_line]
    1              0.000002     let l:length = strchars(l:line) + a:end_char + 1
    1              0.000003     let l:result .= strcharpart(l:line, 0, l:length)
    1              0.000000   endif
    1              0.000001   return l:result

FUNCTION  easycomplete#lsp#get_text_document_identifier()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:336
Called 3 times
Total time:   0.000196
 Self time:   0.000071

count  total (s)   self (s)
    3              0.000008   let l:buf = a:0 > 0 ? a:1 : bufnr('%')
    3   0.000185   0.000060   return { 'uri': easycomplete#lsp#utils#get_buffer_uri(l:buf) }

FUNCTION  easycomplete#lsp#notify_diagnostics_update()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:310
Called 3 times
Total time:   0.010380
 Self time:   0.000029

count  total (s)   self (s)
    3   0.010379   0.000028   call s:notify_diagnostics_update()

FUNCTION  <SNR>57_makeSubjectSinkCallback()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:203
Called 162 times
Total time:   0.001679
 Self time:   0.001679

count  total (s)   self (s)
  162              0.000125   if a:t == 2
                                let l:i = -1
                                let l:found = 0
                                for l:Item in a:data['sinks']
                                  let l:i += 1
                                  if l:Item == a:Sink
                                    let l:found = 1
                                    break
                                  endif
                                endfor
                                if l:found
                                  call remove(a:data['sinks'], l:i)
                                endif
  162              0.000061   endif

FUNCTION  easycomplete#sources#tn#completor()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/tn.vim:122
Called 1 time
Total time:   0.000394
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000001   if !s:tn_init_ready
    1   0.000391   0.000008     call easycomplete#complete(a:opt['name'], a:ctx, a:ctx['startcol'], [])
    1              0.000001     return v:true
                              endif
                              if !exists('b:module_building') | let b:module_building = v:false | endif
                              if b:module_building == v:false && len(easycomplete#GetStuntMenuItems()) == 0
                                " 防止 tabnine 初始模型构建时的 UI 阻塞
                                call easycomplete#complete(a:opt['name'], a:ctx, a:ctx['startcol'], [])
                              endif
                              if easycomplete#sources#tn#JobStatus() == "run"
                                call easycomplete#sources#tn#SimpleTabNineRequest(a:ctx)
                              else
                                call easycomplete#complete(a:opt['name'], a:ctx, a:ctx['startcol'], [])
                                call timer_start(1000, {  -> s:StartTabNine() })
                                let s:tn_init_ready = v:false
                              endif
                              return v:true

FUNCTION  easycomplete#ui#GetBgColor()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/ui.vim:49
Called 1 time
Total time:   0.000095
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000094   0.000005   return easycomplete#ui#GetHiColor(a:name, "bg")

FUNCTION  <SNR>80_GetDicKeywordsList()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/buf.vim:157
Called 1 time
Total time:   0.002160
 Self time:   0.002153

count  total (s)   self (s)
    1   0.000016   0.000009   let global_dict_keyword = s:GetGlobalDictKeyword()
    1              0.000141   let localdicts = deepcopy(global_dict_keyword)
    1              0.001996   call filter(localdicts, 'v:val =~ "^' . a:typing . '"')
    1              0.000004   return localdicts

FUNCTION  <lambda>4039()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 2 times
Total time:   0.000699
 Self time:   0.000014

count  total (s)   self (s)
                            return Callback(x['server'], x['response'])

FUNCTION  easycomplete#sources#buf#CompleteHandler()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/buf.vim:84
Called 1 time
Total time:   0.023597
 Self time:   0.000503

count  total (s)   self (s)
    1              0.000001   try
                                " let ttt = reltime()
    1   0.007077   0.000118     let keywords_result = s:GetKeywords(a:typing)
                                " call s:console(reltimestr(reltime(ttt)), len(keywords_result))
                              catch
                                echom v:exception
    1              0.000001   endtry
    1   0.016511   0.000376   call easycomplete#complete(a:name, a:ctx, a:startcol, keywords_result)

FUNCTION  easycomplete#sign#SetDiagnosticsIndexes()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sign.vim:379
Called 18 times
Total time:   0.000264
 Self time:   0.000264

count  total (s)   self (s)
   18              0.000017   let ret = []
   18              0.000025   for item in a:diagnostics
                                let decimal_num = str2nr(item['range']['start']['character']) + 1
                                let decimal_str = easycomplete#util#fullfill(string(decimal_num))
                                let sort_number = join( [ string(item['range']['start']['line'] + 1), decimal_str ], ".")
                                let item.sortNumber = float2nr(str2float(sort_number) * 1000)
                                call add(ret, item)
   18              0.000016   endfor
   18              0.000014   return ret

FUNCTION  <SNR>49_NotInsertMode()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:3065
Called 12 times
Total time:   0.000223
 Self time:   0.000119

count  total (s)   self (s)
   12   0.000217   0.000113   return call('easycomplete#util#NotInsertMode', a:000)

FUNCTION  <SNR>49_get()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:3073
Called 1 time
Total time:   0.000054
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000053   0.000008   return call('easycomplete#util#get', a:000)

FUNCTION  easycomplete#lsp#utils#get_buffer_uri()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/utils.vim:142
Called 17 times
Total time:   0.000547
 Self time:   0.000438

count  total (s)   self (s)
   17   0.000538   0.000429   return easycomplete#lsp#utils#path_to_uri(expand((a:0 > 0 ? '#' . a:1 : '%') . ':p'))

FUNCTION  <SNR>52_ComputeHLPositions()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:496
Called 21 times
Total time:   0.007667
 Self time:   0.007667

count  total (s)   self (s)
   21              0.000024   let position = []
   21              0.000023   let mark_char = "§"
   21              0.000020   let count_i = 0  " marked abbr cursor
   21              0.000018   let cursor = 0  " abbr cursor
  714              0.000955   while count_i < strlen(a:abbr_marked)
                                " 这里要区分 byte index 和 char index
                                " 下标索引取的值是 byte index，matchaddpos 用的也是 byte index
                                " 比如 '§a'[0] == '§' 是 false，因为第零个位置的 byte index 是 <c2> 
                                " 所以这里的游标需要增加一个完整字符长度的 byte index 长度
  693              0.001047     if a:abbr_marked[count_i] == mark_char[0]
   42              0.000081       let count_i += strlen(mark_char)
   42              0.000048       continue
  651              0.000205     endif
  651              0.000847     if index(a:fuzzy_p, cursor) >= 0
  126              0.000227       call add(position, count_i + a:prefix_length)
  651              0.000208     endif
  651              0.000535     let cursor += 1
  651              0.000505     let count_i += 1
  672              0.000283   endwhile
   21              0.000021   return position

FUNCTION  <SNR>49_CheckCompleteTaskQueueAllDone()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2367
Called 11 times
Total time:   0.000729
 Self time:   0.000729

count  total (s)   self (s)
   11              0.000015   let flag = v:true
  189              0.000123   for item in g:easycomplete_complete_taskqueue
  186              0.000192     if item.condition == 1 && item.done == 0
    8              0.000008       let flag = v:false
    8              0.000004       break
  178              0.000057     endif
  189              0.000090   endfor
   11              0.000009   return flag

FUNCTION  easycomplete#installer#LspServerDir()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/installer.vim:21
Called 4 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    4              0.000007   return s:lsp_servers_dir

FUNCTION  easycomplete#CompleteDone()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:464
Called 2 times
Total time:   0.000967
 Self time:   0.000172

count  total (s)   self (s)
                              " hack for nvim
                              " 正常情况下回退会触发 completedone，进而导致popup_close，nvim
                              " 中也遵循这个逻辑，需要手动再打开一下
    2   0.000031   0.000013   if g:env_is_nvim && !easycomplete#pum#visible()
    2   0.000032   0.000011     call easycomplete#util#DeleteHint()
    2              0.000004     let g:easycomplete_ghost_text_str = ""
    2              0.000001   endif
    2   0.000028   0.000014   if g:env_is_nvim && easycomplete#pum#visible() && easycomplete#IsBacking() && easycomplete#FirstSelectedWithOptDefaultSelected()
                                call s:ShowCompleteInfoWithoutTimer()
    2   0.000024   0.000012   elseif g:env_is_nvim && easycomplete#pum#visible() && easycomplete#IsBacking()
                                call easycomplete#popup#CompleteDone()
    2   0.000033   0.000017   elseif g:env_is_nvim && !easycomplete#pum#visible() && easycomplete#IsBacking()
    2   0.000416   0.000011     call s:CloseCompleteInfo()
                              else
                                call easycomplete#popup#CompleteDone()
    2              0.000001   endif
                              " 偶尔会有一些pum关闭后completeinfo没有关闭，这里做一个扫尾
                              " if g:env_is_nvim && easycomplete#IsBacking()
                              "   call s:StopAsyncRun()
                              "   call s:AsyncRun(function("s:CompleteDoneTeardown"), [], 5)
                              " endif
    2   0.000254   0.000033   if !s:SameCtx(easycomplete#context(), g:easycomplete_firstcomplete_ctx) && !s:zizzing()
    1              0.000001     return
    1              0.000000   endif
                              " bugfix for #88
    1              0.000001   if g:env_is_nvim
                                " 触发 tabnine suggest
    1   0.000073   0.000011     if !easycomplete#pum#visible() && !easycomplete#IsBacking() && easycomplete#tabnine#ready()
                                  call s:LazyTabNineSuggestFire(500)
    1              0.000001     endif
                                "TODO v:complete_item 是否是必须的，还需再测试一下
    1   0.000013   0.000006     if easycomplete#pum#visible() || (g:easycomplete_first_complete_hit != 1)
    1   0.000026   0.000005       call s:zizz()
    1              0.000001       return
                                endif
                              else
                                if pumvisible() || (empty(v:completed_item) && g:easycomplete_first_complete_hit != 1)
                                  call s:zizz()
                                  return
                                endif
                              endif
                              call s:flush()

FUNCTION  easycomplete#action#signature#LazyRunHandle()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/action/signature.vim:23
Called 2 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    2              0.000004   if !exists("b:signature_timer")
                                let b:signature_timer = 0
    2              0.000001   endif
    2              0.000002   if b:signature_timer > 0
                                call timer_stop(b:signature_timer)
                                let b:signature_timer = 0
    2              0.000001   endif
    2              0.000014   let b:signature_timer = timer_start(100, { -> easycomplete#action#signature#handle() })

FUNCTION  GetVimIndent()
    Defined: /usr/local/lib/nvim-macos-x86_64/share/nvim/runtime/indent/vim.vim:27
Called 1 time
Total time:   0.000387
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000012   let ignorecase_save = &ignorecase
    1              0.000001   try
    1   0.000015   0.000010     let &ignorecase = 0
    1   0.000345   0.000011     return GetVimIndentIntern()
    1              0.000001   finally
    1   0.000007   0.000005     let &ignorecase = ignorecase_save
    1              0.000001   endtry

FUNCTION  easycomplete#lsp#callbag#create()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:223
Called 3 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    3              0.000004   let l:data = {}
    3              0.000003   if a:0 > 0
    3              0.000006     let l:data['prod'] = a:1
    3              0.000002   endif
    3              0.000011   return function('s:createProd', [l:data])

FUNCTION  easycomplete#ResetInsertChar()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:882
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000027   let g:easycomplete_insert_char = ""

FUNCTION  easycomplete#CompleteAdd()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1855
Called 5 times
Total time:   0.067962
 Self time:   0.004370

count  total (s)   self (s)
    5   0.000346   0.000033   if !s:CheckCompleteTaskQueueAllDone()
    4   0.000031   0.000021     if s:zizzing() | return | endif
    5              0.000002   endif
    5   0.000094   0.000024   if s:NotInsertMode() | return |endif
    5              0.000011   if !exists('g:easycomplete_menucache')
                                call s:SetupCompleteCache()
    5              0.000002   endif
                            
    5              0.000009   if !exists('g:easycomplete_menuitems')
                                let g:easycomplete_menuitems = []
    5              0.000002   endif
                            
    5              0.000016   if type(a:menu_list) != type([]) || empty(a:menu_list)
    3   0.000236   0.000018     if s:CheckCompleteTaskQueueAllDone()
                                  " continue
    2              0.000001     else
    2              0.000001       return
    1              0.000000     endif
    3              0.000001   endif
                            
    3   0.000181   0.000092   if easycomplete#CompleteCursored()
                                if g:env_is_nvim
                                  call s:CloseCompletionMenu()
                                else
                                  call feedkeys("\<C-E>")
                                endif
    3              0.000001   endif
                            
                              " FristComplete 的过滤方法重写了
                              " 为了避免重复过滤，去掉了这里的 CompleteMenuFilter 动作
                              " 这里只做 CombineAllMenuitems 动作，在 Render 时一次性做过滤
    3   0.000163   0.000014   let typing_word = s:GetTypingWord()
    3              0.000004   let new_menulist = a:menu_list
    3   0.027469   0.001356   call easycomplete#StoreCompleteSourceItems(a:plugin_name, a:menu_list)
    3   0.000774   0.000073   let g:easycomplete_menuitems = s:CombineAllMenuitems()
    3              0.002536   let g_easycomplete_menuitems = deepcopy(g:easycomplete_menuitems)
    3              0.000008   let filtered_menu = g_easycomplete_menuitems
    3              0.000012   let start_pos = col('.') - strwidth(typing_word)
                            
    3              0.000005   if a:plugin_name == "path"
                                " let typed = strpart(getline('.'), 0, col('.') - 1)
                                " let start_pos = strwidth(typed) - strwidth(fnamemodify(typed, ":t"))
                                let b:is_path_complete = 1
    3              0.000002   else
    3              0.000004     let b:is_path_complete = 0
    3              0.000001   endif
                            
    3              0.000002   try
    3   0.035954   0.000026     call s:FirstComplete(start_pos, filtered_menu)
                              catch /^Vim\%((\a\+)\)\=:E730/
                                return v:null
    3              0.000002   endtry
    3              0.000003   if g:env_is_vim
                                call easycomplete#popup#close("popup")
    3              0.000001   endif

FUNCTION  easycomplete#util#NotInsertMode()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:686
Called 17 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
   17              0.000021   if g:env_is_vim
                                return mode()[0] != 'i' ? v:true : v:false
   17              0.000008   endif
   17              0.000014   if g:env_is_nvim
   17              0.000047     return mode() == 'i' ? v:false : v:true
                              endif

FUNCTION  easycomplete#zizzing()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1956
Called 31 times
Total time:   0.000241
 Self time:   0.000164

count  total (s)   self (s)
   31   0.000227   0.000150   return s:zizzing()

FUNCTION  <SNR>57_shareSourceCallback()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:373
Called 144 times
Total time:   0.022585
 Self time:   0.003619

count  total (s)   self (s)
  144              0.000136   if a:t == 0
                                let a:data['sourceTalkback'] = a:d
                                call a:sink(0, a:data['talkback'])
  144              0.000068   else
  288              0.000432     for l:S in a:data['sinks']
  144   0.020208   0.001241       call l:S(a:t, a:d)
  288              0.000602     endfor
  144              0.000056   endif
  144              0.000104   if a:t == 2
                                let a:data['sinks'] = []
  144              0.000056   endif

FUNCTION  <SNR>59_IsSearchWord()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/ui.vim:216
Called 4 times
Total time:   0.000251
 Self time:   0.000183

count  total (s)   self (s)
    4              0.000028   if !exists("b:cs_searched")
                                let b:cs_searched = v:false
    4              0.000002   endif
    4              0.000007   if b:cs_searched == v:false
                                return v:false
    4              0.000001   endif
    4              0.000013   let current_word = expand('<cword>')
    4              0.000010   let search_word = histget("search")
    4              0.000029   let search_word = substitute(search_word, "^\\\\\<", "", "g")
    4              0.000014   let search_word = substitute(search_word, "\\\\\>$", "", "g")
    4   0.000110   0.000042   let search_word = s:SpecialTrim(search_word)
    4              0.000005   if &ignorecase
    4              0.000015     return current_word =~ search_word
                              else
                                return current_word =~# search_word
                              endif

FUNCTION  <SNR>49_VimDotTyping()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:870
Called 1 time
Total time:   0.000120
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000116   0.000017   if &filetype == "vim" && easycomplete#context()['typed'] =~ '\(\w\+\.\)\{-1,}$'
                                return v:true
    1              0.000000   else
    1              0.000001     return v:false
                              endif

FUNCTION  <SNR>57_mergeTalkbackCallback()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:51
Called 18 times
Total time:   0.001901
 Self time:   0.000780

count  total (s)   self (s)
   18              0.000030   if a:t == 2 | let a:data['ended'] = 1 | endif
   18              0.000018   let l:i = 0
   54              0.000076   while l:i < a:data['n']
   36              0.000117     if l:i < len(a:data['sourceTalkbacks']) && a:data['sourceTalkbacks'][l:i] != 0
   36   0.001409   0.000288       call a:data['sourceTalkbacks'][l:i](a:t, a:d)
   36              0.000015     endif
   36              0.000040     let l:i += 1
   54              0.000095   endwhile

FUNCTION  easycomplete#util#IsGui()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:2362
Called 4 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    4              0.000017   return (has("termguicolors") && &termguicolors == 1) ? v:true : v:false

FUNCTION  <SNR>56_get_last_file_content()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:818
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000009   if has_key(s:file_content, a:buf) && has_key(s:file_content[a:buf], a:server_name)
    2              0.000005     return s:file_content[a:buf][a:server_name]
                              endif
                              return []

FUNCTION  <SNR>49_NormalizeMenulist()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2264
Called 3 times
Total time:   0.021258
 Self time:   0.017174

count  total (s)   self (s)
    3              0.000005   if empty(a:arr)
    1              0.000001     return []
    2              0.000001   endif
    2              0.000002   let l:menu_list = []
  367              0.000285   for item in a:arr
  365   0.006283   0.002200     let o_user_data = easycomplete#util#GetUserData(item)
  365              0.000704     let o_sha256 = get(o_user_data, "sha256", "")
  365              0.000411     if empty(o_sha256)
  195              0.001769       let sha256_str = strpart(sha256(string(item)), 0, 15)
  170              0.000056     else
  170              0.000155       let sha256_str = o_sha256
  365              0.000127     endif
  365              0.001397     let r_user_data = extend(o_user_data, { 'plugin_name': a:plugin_name, 'sha256':      sha256_str, })
  365              0.000559     if type(item) == type("")
                                  let l:menu_item = { 'word':      item,    'menu':       '', 'user_data': json_encode(r_user_data), 'info': '', 'kind':      '',      'equal':      0, 'dup':       1,       'abbr':      '', 'kind_number' : get(item, 'kind_number', 0), 'plugin_name' : a:plugin_name, 'user_data_json': r_user_data }
                                  call add(l:menu_list, l:menu_item)
  365              0.000122     endif
  365              0.000562     if type(item) == type({})
  365              0.004976       call add(l:menu_list, extend({   'word': '',      'menu': '',   'user_data': json_encode(r_user_data), 'equal': 0,   'dup': 1,        'info': '',   'kind': '',      'abbr': '',   'kind_number' : get(item, 'kind_number', 0),   'plugin_name' : a:plugin_name,   'user_data_json': r_user_data },  item ))
  365              0.000132     endif
  367              0.000904   endfor
    2              0.000003   return l:menu_list

FUNCTION  <SNR>67_popup()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/popup.vim:421
Called 26 times
Total time:   0.007952
 Self time:   0.001548

count  total (s)   self (s)
   26              0.000083   if g:env_is_vim && (!pumvisible() || !easycomplete#CompleteCursored())
                                call easycomplete#popup#close("popup")
                                return
   26              0.000013   endif
   26   0.001008   0.000332   if g:env_is_nvim && (!easycomplete#pum#visible() || !easycomplete#CompleteCursored())
    1   0.000076   0.000007     call easycomplete#popup#close("popup")
    1              0.000001     return
   25              0.000010   endif
   25              0.000067   if empty(s:item) || empty(a:info)
   11              0.000010     if s:is_vim
                                  call popup_hide(g:easycomplete_popup_win["popup"])
   11              0.000006     else
   11   0.000617   0.000060       call easycomplete#popup#close("popup")
   11              0.000004     endif
   11              0.000006     return
   14              0.000005   endif
   14   0.001205   0.000086   if easycomplete#FirstSelectedWithOptDefaultSelected()
   14   0.001757   0.000089     let l:event = g:env_is_vim ? v:event : easycomplete#pum#CompleteChangedEvnet()
   14              0.000018     let s:event = l:event
   14              0.000058     let s:last_event = l:event
                              else
                                if s:is_nvim && g:easycomplete_popup_win["popup"] && s:event == s:last_event
                                  return
                                endif
                                let s:last_event = s:event
   14              0.000004   endif
                            
   14              0.000045   let info = type(a:info) == type("") ? [a:info] : a:info
   14   0.001654   0.000125   let info = easycomplete#util#ModifyInfoByMaxwidth(info, g:easycomplete_popup_width)
                            
   14              0.000032   if len(info) == 1 && len(info[0]) == 0
   14              0.000012     if s:is_vim
                                  call popup_hide(g:easycomplete_popup_win["popup"])
   14              0.000006     else
   14   0.000868   0.000082       call easycomplete#popup#close("popup")
   14              0.000005     endif
   14              0.000008     return
                              endif
                              call s:InitBuf(info, 'popup',  getbufvar(bufnr(), "&filetype"))
                              let prevw_width = easycomplete#popup#DisplayWidth(info, g:easycomplete_popup_width)
                              let prevw_height = easycomplete#popup#DisplayHeight(info, prevw_width, 'popup') - 1
                              let opt = { 'focusable': v:true, 'width': prevw_width, 'height': prevw_height, 'relative':'editor', 'style':'minimal', 'filetype': &filetype }
                              if g:env_is_vim
                                let pum_pos = pum_getpos()
                              else
                                let pum_pos = easycomplete#pum#PumGetPos()
                              endif
                              if get(pum_pos, 'scrollbar')
                                let right_avail_col  = pum_pos.col + pum_pos.width + 1
                              else
                                let right_avail_col  = pum_pos.col + pum_pos.width
                              endif
                              let left_avail_col = pum_pos.col - 2
                            
                              let right_avail = &co - right_avail_col - (g:easycomplete_winborder ? 2 : 0)
                              let left_avail = left_avail_col + 1 - (g:easycomplete_winborder ? 2 : 0)
                            
                              if right_avail >= prevw_width + (g:easycomplete_winborder ? 2 : 0)
                                let opt.col = right_avail_col + (g:easycomplete_winborder ? 2 : 0)
                              elseif left_avail >= prevw_width + (g:easycomplete_winborder ? 2 : 0)
                                let opt.col = left_avail_col - prevw_width + 1 - (g:easycomplete_winborder ? 2 : 0)
                              else
                                " 如果左右都没有正常空间可以展开
                            
                                " 如果左右空间都小于 20，直接关闭
                                if right_avail <= 20 && left_avail <= 20
                                  call easycomplete#popup#close("popup")
                                  return
                                endif
                            
                                if right_avail >= left_avail
                                  " 右侧空间较大
                                  " let opt.col = float2nr(right_avail_col) + (g:easycomplete_winborder ? 2 : 0)
                                  let opt.col = pum_pos.col + pum_pos.width + 1 + (g:easycomplete_winborder ? 2 : 0)
                                  let opt.width = float2nr(right_avail) - (g:easycomplete_winborder ? 2 : 0)
                                else
                                  " 左侧空间较大
                                  let opt.col = 0
                                  let opt.width = float2nr(left_avail)
                                endif
                              endif
                            
                              let l:screen_line = winline() + (win_screenpos(win_getid())[0] - 1)
                              let screen_enc = (win_screenpos(win_getid())[0] - 1)
                              if l:screen_line <= pum_pos.row
                                " 菜单向下展开
                                let opt.row = pum_pos.row
                                let opt.row = winline() + screen_enc
                              else
                                " 菜单向上展开
                                let opt.row = l:screen_line - opt.height - 1
                                let opt.row -= (g:easycomplete_winborder ? 2 : 0)
                              endif
                            
                              if s:is_nvim
                                call easycomplete#popup#close("popup")
                                call s:NVimShow(opt, "popup", '')
                              elseif s:is_vim
                                call s:VimShow(opt, "popup", '')
                              endif

FUNCTION  easycomplete#sign#LintPopup()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sign.vim:493
Called 1 time
Total time:   0.000388
 Self time:   0.000059

count  total (s)   self (s)
    1   0.000033   0.000005   if !easycomplete#ok('g:easycomplete_diagnostics_hover')
                                call easycomplete#sign#DiagHoverFlush()
                                return
    1              0.000000   endif
    1   0.000043   0.000006   if easycomplete#util#InsertMode() && easycomplete#popup#LintPopupVisible()
                                call easycomplete#popup#CloseLintPopup()
                                return
    1              0.000000   endif
    1   0.000093   0.000005   let ctx = easycomplete#context()
                              " 换行则先清空
    1              0.000002   if g:easycomplete_diagnostics_last_ln != ctx["lnum"]
    1   0.000047   0.000006     call easycomplete#sign#DiagHoverFlush()
    1              0.000000   endif
                              " 如果当前行没有 lintinfo, 则清空后直接返回
    1   0.000057   0.000009   let diagnostics_info = easycomplete#sign#GetDiagnosticsInfo(ctx["lnum"], ctx["col"])
    1              0.000001   if empty(diagnostics_info)
    1   0.000056   0.000008     let diagnostics_info = s:GetDiagnosticsInfoByLine(ctx["lnum"])
    1              0.000001     if empty(diagnostics_info)
    1   0.000045   0.000006       call easycomplete#sign#DiagHoverFlush()
    1              0.000001       return
                                endif
                              endif
                              " 不是原有的 lintinfo 则先清空
                              let g_easycomplete_diagnostics_last_popup = s:GetDiagnosticsLastPopup()
                              if g:easycomplete_diagnostics_last_msg != g_easycomplete_diagnostics_last_popup
                                call easycomplete#sign#DiagHoverFlush()
                              endif
                              " call s:StopAsyncRun()
                              " call s:AsyncRun(function("s:PopupMsg"), [diagnostics_info], 50)
                              if s:lint_popup_timer > 0
                                call timer_stop(s:lint_popup_timer)
                              endif
                              let s:lint_popup_timer = timer_start(10, { -> easycomplete#util#call(function("s:PopupMsg"), [diagnostics_info, ctx["lnum"]]) })

FUNCTION  <SNR>56_ensure_flush()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:529
Called 6 times
Total time:   0.012654
 Self time:   0.000165

count  total (s)   self (s)
    6   0.010381   0.007168   call easycomplete#lsp#utils#step#start([ {s->s:ensure_start(a:buf, a:server_name, s.callback)}, {s->s:is_step_error(s) ? s:throw_step_error(s) : s:ensure_init(a:buf, a:server_name, s.callback)}, {s->s:is_step_error(s) ? s:throw_step_error(s) : s:ensure_conf(a:buf, a:server_name, s.callback)}, {s->s:is_step_error(s) ? s:throw_step_error(s) : s:ensure_open(a:buf, a:server_name, s.callback)}, {s->s:is_step_error(s) ? s:throw_step_error(s) : s:ensure_changed(a:buf, a:server_name, s.callback)}, {s->a:cb(s.result[0])} ])

FUNCTION  easycomplete#pum#CompleteChangedEvnet()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:381
Called 71 times
Total time:   0.008953
 Self time:   0.002412

count  total (s)   self (s)
   71   0.001030   0.000718   if !s:pumvisible() || !easycomplete#pum#CompleteCursored()
    6              0.000008     return {}
   65              0.000029   endif
   65   0.005448   0.000420   let pum_pos = easycomplete#pum#PumGetPos()
   65   0.002026   0.000825   let completed_item = easycomplete#pum#CursoredItem()
   65              0.000273   return extend(pum_pos, {"completed_item": completed_item })

FUNCTION  <SNR>52_pumvisible()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:1142
Called 944 times
Total time:   0.001999
 Self time:   0.001999

count  total (s)   self (s)
  944              0.001634   return s:pum_window > 0 ? v:true : v:false

FUNCTION  easycomplete#popup#overlay()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/popup.vim:376
Called 1 time
Total time:   0.000013
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000010   0.000005   if s:IsOverlay()
                                call easycomplete#popup#close("float")
    1              0.000000   endif

FUNCTION  easycomplete#pum#IsInsertingWord()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:644
Called 69 times
Total time:   0.000109
 Self time:   0.000109

count  total (s)   self (s)
   69              0.000083   return s:pum_insert_word_timer > 0

FUNCTION  easycomplete#ui#GetFgColor()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/ui.vim:54
Called 1 time
Total time:   0.000137
 Self time:   0.000022

count  total (s)   self (s)
    1   0.000137   0.000021   return easycomplete#ui#GetHiColor(a:name, "fg")

FUNCTION  easycomplete#lsp#client#is_server_instantiated_notification()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/client.vim:350
Called 5 times
Total time:   0.000059
 Self time:   0.000046

count  total (s)   self (s)
    5   0.000057   0.000044   return s:is_server_instantiated_notification(a:notification)

FUNCTION  easycomplete#lsp#get_allowed_servers()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:200
Called 25 times
Total time:   0.003871
 Self time:   0.003871

count  total (s)   self (s)
   25              0.000031   if a:0 == 0
   22              0.000066     let l:buffer_filetype = &filetype
    3              0.000001   else
    3              0.000008     if type(a:1) == type('')
                                  let l:buffer_filetype = a:1
    3              0.000001     else
    3              0.000009       let l:buffer_filetype = getbufvar(a:1, '&filetype')
    3              0.000001     endif
   25              0.000010   endif
                            
                              " TODO: cache active servers per buffer
   25              0.000031   let l:active_servers = []
                            
  100              0.000158   for l:server_name in keys(s:servers)
   75              0.000192     let l:server_info = s:servers[l:server_name]['server_info']
   75              0.000074     let l:blocked = 0
                            
   75              0.000130     if has_key(l:server_info, 'blocklist')
                                  let l:blocklistkey = 'blocklist'
   75              0.000033     else
   75              0.000091       let l:blocklistkey = 'blacklist'
   75              0.000031     endif
   75              0.000125     if has_key(l:server_info, l:blocklistkey)
                                  for l:filetype in l:server_info[l:blocklistkey]
                                    if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
                                      let l:blocked = 1
                                      break
                                    endif
                                  endfor
   75              0.000029     endif
                            
   75              0.000056     if l:blocked
                                  continue
   75              0.000045     endif
                            
   75              0.000113     if has_key(l:server_info, 'allowlist')
   75              0.000089       let l:allowlistkey = 'allowlist'
                                else
                                  let l:allowlistkey = 'whitelist'
   75              0.000028     endif
   75              0.000119     if has_key(l:server_info, l:allowlistkey)
  125              0.000177       for l:filetype in l:server_info[l:allowlistkey]
   75              0.000153         if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
   25              0.000065           let l:active_servers += [l:server_name]
   25              0.000013           break
   50              0.000019         endif
  125              0.000081       endfor
   75              0.000030     endif
  100              0.000084   endfor
                            
   25              0.000030   return l:active_servers

FUNCTION  easycomplete#lsp#request()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:374
Called 3 times
Total time:   0.000077
 Self time:   0.000048

count  total (s)   self (s)
    3              0.000016   let l:ctx = { 'server_name': a:server_name, 'request': copy(a:request), 'request_id': 0, 'done': 0, 'cancelled': 0, }
    3   0.000059   0.000030   return easycomplete#lsp#callbag#create(function('s:request_create', [l:ctx]))

FUNCTION  easycomplete#util#get()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:2379
Called 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000003   let params = deepcopy(a:000)
    1              0.000001   let tmp = a:obj
    3              0.000005   for item in params
    2              0.000005     let tmp = get(tmp, item, 0)
    3              0.000005     if empty(tmp) | break | endif
    3              0.000020   endfor
    1              0.000001   return tmp

FUNCTION  <SNR>56_errlog()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:1438
Called 6 times
Total time:   0.000105
 Self time:   0.000052

count  total (s)   self (s)
    6   0.000102   0.000049   return call('easycomplete#util#errlog', a:000)

FUNCTION  <SNR>52_GetFullfillItems()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:1239
Called 26 times
Total time:   0.069294
 Self time:   0.050741

count  total (s)   self (s)
   26              0.000041   let wlength = 0
   26              0.000038   let word_arr_length = []
   26              0.000027   let kind_arr_length = []
   26              0.000024   let menu_arr_length = []
   26              0.000024   let abbr_arr_length = []
   26              0.000024   let new_data = []
                              " ------------ find max length --------------
 1103              0.000710   for item in a:data
                                " let abbr = easycomplete#util#GetItemAbbr(item)
 1077              0.001853     let word = get(item, "word", "")
 1077              0.001737     let abbr = get(item, "abbr", "")
                                " if empty(get(item, "abbr", ""))
                                "   let item["abbr"] = abbr
                                " endif
 1077              0.002361     let word_arr_length += [strdisplaywidth(word)]
 1077              0.002352     let abbr_arr_length += [strdisplaywidth(abbr)]
 1077              0.003534     let kind_arr_length += [strdisplaywidth(trim(get(item, "kind", "")))]
 1077              0.003421     let menu_arr_length += [strdisplaywidth(trim(get(item, "menu", "")))]
 1103              0.000644   endfor
   26              0.000228   let maxlength = { "word_max_length": max(word_arr_length), "abbr_max_length": max(abbr_arr_length), "kind_max_length": max(kind_arr_length), "menu_max_length": max(menu_arr_length) }
 1103              0.000911   for item in a:data
 1077   0.011362   0.006832     let f_kind = s:fullfill(trim(get(item, "kind", "")), maxlength.kind_max_length)
 1077   0.013472   0.006917     let f_menu = s:fullfill(trim(get(item, "menu", "")), maxlength.menu_max_length)
 1077   0.021864   0.014396     call add(new_data, { "abbr": s:FullfillMarkedAbbr(get(item, "abbr", ""),                              get(item, "abbr_marked", ""),                              maxlength.abbr_max_length), "word": get(item, "word", ""), "kind": f_kind, "menu": f_menu })
 1103              0.002181   endfor
   26              0.000108   return extend({ "items": new_data, }, maxlength)

FUNCTION  <SNR>75_close()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/action/signature.vim:19
Called 1 time
Total time:   0.000107
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000106   0.000011   call easycomplete#popup#close("float")

FUNCTION  <SNR>56_notify_diagnostics_update()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:302
Called 3 times
Total time:   0.010351
 Self time:   0.000040

count  total (s)   self (s)
    3              0.000014   let l:data = { 'server': '$vimlsp', 'response': { 'method': '$/vimlsp/lsp_diagnostics_updated', 'params': {} } }
                              " if a:0 > 0 | let l:data['response']['params']['server'] = a:1 | endif
                              " if a:0 > 1 | let l:data['response']['params']['uri'] = a:2 | endif
    3   0.010330   0.000019   call easycomplete#lsp#stream(1, l:data)
                              " doautocmd <nomodeline> User lsp_diagnostics_updated

FUNCTION  <SNR>52_SetWinBorder()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:1030
Called 26 times
Total time:   0.002066
 Self time:   0.001607

count  total (s)   self (s)
   26              0.000065   if a:pum_direction == "below"
   21              0.000035     let l:row = a:opt.row
   21              0.000020     let l:col = a:opt.col
   21              0.000024     let l:width = a:opt.width
   21   0.000269   0.000103     let l:below_space = s:CursorBottom() - 1
   21   0.000310   0.000111     let l:below_space = s:TrimBelowHeight(l:below_space)
   21              0.000028     if a:opt.height + 2 <= l:below_space
                                  " 向下远没有触底
                                  let l:height = a:opt.height
   21              0.000027     elseif a:opt.height + 1 == l:below_space
                                  " 向下+1后触底
                                  let l:height = a:opt.height - 1
   21              0.000020     elseif a:opt.height + 2 == l:below_space
                                  " 向下+2后触底
                                  let l:height = a:opt.height - 2
   21              0.000008     else
                                  " 超过触底，一般不会走到这里
   21              0.000025       let l:height = a:opt.height - 2
   21              0.000009     endif
    5              0.000008   elseif a:pum_direction == "above"
    5              0.000008     let l:col = a:opt.col
    5   0.000053   0.000031     let l:above_space = s:CursorTop() - 1
                                " TODO here jayli 要处理顶部高度----------------------
                                " 不写这句好像就可以了，还需要再测试下
    5   0.000085   0.000030     let l:above_space = s:TrimAboveHeight(l:above_space)
    5   0.000043   0.000027     let l:row_with_maxheight_computed = s:CursorTop() - l:above_space - 1
    5              0.000007     let l:height = a:opt.height
    5              0.000006     let l:width = a:opt.width
                            
    5              0.000007     if a:opt.height + 2 <= l:above_space
                                  " 向上远没有触顶
    5              0.000006       let l:height = a:opt.height
    5              0.000006       let l:row = a:opt.row - 2
                                elseif a:opt.height + 1 == l:above_space
                                  " 向上+1后触顶
                                  let l:height = a:opt.height - 1
                                  let l:row = l:row_with_maxheight_computed > 0 ? l:row_with_maxheight_computed : 0
                                elseif a:opt.height + 2 == l:above_space
                                  " 向上+2后触顶
                                  let l:height = a:opt.height - 2
                                  let l:row = l:row_with_maxheight_computed > 0 ? l:row_with_maxheight_computed : 0
                                else
                                  " 超过触顶，一般不会走到这里
                                  let l:height = a:opt.height - 2
                                  let l:row = l:row_with_maxheight_computed > 0 ? l:row_with_maxheight_computed : 0
    5              0.000002     endif
   26              0.000011   endif
   26              0.000237   return extend(a:opt, { "height": l:height, "width": l:width + (s:has_scrollbar ? 1 : 0), "row": l:row, "col": l:col, "border": g:easycomplete_pum_border_style })

FUNCTION  <SNR>52_HasScrollbar()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:840
Called 145 times
Total time:   0.000329
 Self time:   0.000329

count  total (s)   self (s)
  145              0.000252   return s:has_scrollbar == 1 ? v:true : v:false

FUNCTION  <SNR>49_zizz()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2562
Called 15 times
Total time:   0.000307
 Self time:   0.000307

count  total (s)   self (s)
   15              0.000045   let delay = g:env_is_nvim ? 30 : (&filetype == 'vim' ? 50 : 50)
   15              0.000021   let g:easycomplete_backing_or_cr = 1
   15              0.000042   if exists('s:zizz_timmer') && s:zizz_timmer > 0
   15              0.000036     call timer_stop(s:zizz_timmer)
   15              0.000008   endif
   15              0.000103   let s:zizz_timmer = timer_start(delay, function('s:ResetBacking'))
   15              0.000028   return "\<BS>"

FUNCTION  <SNR>52_RecoverOpt()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:331
Called 2 times
Total time:   0.000110
 Self time:   0.000104

count  total (s)   self (s)
    8              0.000017   for k in keys(s:original_opt)
    6              0.000015     let v = get(s:original_opt, k, "")
    6   0.000039   0.000034     call setwinvar(0, "&" . k, v)
    8              0.000024   endfor
                              " call setwinvar(0, '&hlsearch', get(s:original_opt, "hlsearch"))
                              " call setwinvar(0, '&wrap', get(s:original_opt, "wrap"))
                              " call setwinvar(0, '&spell', get(s:original_opt, "spell"))

FUNCTION  easycomplete#action#diagnostics#do()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/action/diagnostics.vim:5
Called 3 times
Total time:   0.020701
 Self time:   0.000156

count  total (s)   self (s)
                              " 确保从这里 fire 的 diagnostic 才会被更新渲染
    3   0.001607   0.000024   if easycomplete#util#GetLspPluginName() == "ts"
                                call easycomplete#sources#ts#lint()
                                return
    3              0.000001   endif
    3   0.001687   0.000035   if !easycomplete#util#LspServerReady() | return | endif
    3   0.010404   0.000024   call easycomplete#lsp#notify_diagnostics_update()
    3              0.000005   let s:response_ready = 0
    3   0.006870   0.000022   call easycomplete#lsp#ensure_flush_all()
    3   0.000112   0.000028   call easycomplete#util#timer_start('easycomplete#action#diagnostics#render', [], g:easycomplete_diagnostics_render_delay)

FUNCTION  easycomplete#ui#GetHiColor()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/ui.vim:59
Called 2 times
Total time:   0.000204
 Self time:   0.000146

count  total (s)   self (s)
    2              0.000006   let sufix = empty(a:sufix) ? "bg" : a:sufix
    2   0.000060   0.000013   let hlString = easycomplete#ui#HighlightArgs(a:hiName)
    2              0.000002   let my_color = "NONE"
    2              0.000005   if empty(hlString) | return my_color | endif
    2   0.000021   0.000010   if easycomplete#util#IsGui()
                                " Gui color name
    2              0.000061     let my_color = matchstr(hlString,"\\(\\sgui" . sufix . "=\\)\\@<=#\\{-}\\w\\+")
    2              0.000003     if empty(my_color)
                                  let linksGroup = matchstr(hlString, "\\(links\\sto\\s\\+\\)\\@<=\\w\\+")
                                  if !empty(linksGroup)
                                    let my_color = easycomplete#ui#GetHiColor(linksGroup, a:sufix)
                                  endif
    2              0.000001     endif
                              else
                                let my_color= matchstr(hlString,"\\(\\scterm" .sufix. "=\\)\\@<=\\w\\+")
    2              0.000001   endif
                            
    2              0.000003   if my_color == "" || my_color == "NONE"
                                return "NONE"
    2              0.000001   endif
                            
                              " if my_color =~ '^\d\+$'
                              "   return str2nr(my_color)
                              " endif
                            
    2              0.000001   return my_color

FUNCTION  easycomplete#popup#SignatureDirection()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/popup.vim:356
Called 26 times
Total time:   0.000624
 Self time:   0.000453

count  total (s)   self (s)
   26   0.000342   0.000170   if easycomplete#popup#SignatureVisible() && !(empty(s:float_opt))
                                let screen_row_enc = win_screenpos(win_getid())[0] - 1
                                let c_row = screen_row_enc + winline() - 1
                                if c_row < s:float_opt["row"]
                                  return "below"
                                elseif c_row > s:float_opt["row"]
                                  return "above"
                                else
                                  return ""
                                endif
   26              0.000011   else
   26              0.000017     return ""
                              endif

FUNCTION  easycomplete#util#AsyncRun()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:49
Called 33 times
Total time:   0.002830
 Self time:   0.002830

count  total (s)   self (s)
   33              0.000047   let Method = a:1
   33              0.000074   let args = exists('a:2') ? a:2 : []
   33              0.000058   let delay = exists('a:3') ? a:3 : 0
   33              0.000025   if g:env_is_nvim
                                " Method 如果是字符串的话不能是 s:xxx 这类临时函数
   33              0.002375     let g:easycomplete_popup_timer = s:util_toolkit.async_run(Method, args, delay)
                              else
                                let g:easycomplete_popup_timer = timer_start(delay, { -> easycomplete#util#call(Method, args)})
   33              0.000013   endif
   33              0.000035   return g:easycomplete_popup_timer

FUNCTION  <SNR>57_filterSourceCallback()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:104
Called 144 times
Total time:   0.018967
 Self time:   0.004021

count  total (s)   self (s)
  144              0.000129   if a:t == 0
                                let a:data['talkback'] = a:d
                                call a:data['sink'](a:t, a:d)
  144              0.000116   elseif a:t == 1
  144   0.001458   0.000769     if a:data['condition'](a:d)
   18   0.009733   0.000104       call a:data['sink'](a:t, a:d)
  126              0.000056     else
  126   0.006464   0.001836       call a:data['talkback'](1, easycomplete#lsp#callbag#undefined())
  144              0.000056     endif
                              else
                                call a:data['sink'](a:t, a:d)
  144              0.000053   endif

FUNCTION  <SNR>80_GetGlobalDictKeyword()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/buf.vim:164
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000004   if exists("b:easycomplete_global_dict")
    1              0.000002     return b:easycomplete_global_dict
                              endif
                              let b:easycomplete_global_dict = []
                              if empty(&dictionary)
                                return []
                              endif
                              " 如果当前 Buff 所读取的字典目录存在
                              let dictsFiles   = split(&dictionary,",")
                              let dictkeywords = []
                              let dictFile = ""
                              for onedict in dictsFiles
                                try
                                  let lines = readfile(onedict)
                                catch /.*/
                                  "echoe "关键词字典不存在!请删除该字典配置 ".
                                  "           \ "dictionary-=".onedict
                                  continue
                                endtry
                            
                                if dictFile == ""
                                  let dictFile = substitute(onedict,"^.\\+[\\/]","","g")
                                  let dictFile = substitute(dictFile,".txt","","g")
                                endif
                                let filename         = dictFile
                                let localdicts       = []
                                let localWrappedList = []
                            
                                if empty(lines)
                                  continue
                                endif
                            
                                for line in lines
                                  call extend(localdicts, split(line, s:KeywordsRegx()))
                                endfor
                            
                                let localdicts_uniq = s:ArrayDistinct(localdicts)
                                let dictkeywords += localdicts_uniq
                              endfor
                              let b:easycomplete_global_dict = dictkeywords
                              return dictkeywords

FUNCTION  easycomplete#CursorHold()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2745
Called 2 times
Total time:   0.010841
 Self time:   0.000050

count  total (s)   self (s)
    2   0.000074   0.000012   if !easycomplete#ok('g:easycomplete_enable')
                                return
    2              0.000001   endif
    2   0.010629   0.000010   call easycomplete#lint()
    2   0.000132   0.000021   if easycomplete#ok('g:easycomplete_diagnostics_enable') && easycomplete#ok('g:easycomplete_diagnostics_hover')
                                " call easycomplete#sign#LintPopup()
    2              0.000001   endif

FUNCTION  easycomplete#lsp#client#is_error()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/client.vim:334
Called 30 times
Total time:   0.000503
 Self time:   0.000204

count  total (s)   self (s)
   30   0.000490   0.000191   return s:lsp_is_error(a:obj_or_response)

FUNCTION  <lambda>26850()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 8 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# 'textDocument/publishDiagnostics'

FUNCTION  <lambda>26851()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 2 times
Total time:   0.000659
 Self time:   0.000014

count  total (s)   self (s)
                            return Callback(x['server'], x['response'])

FUNCTION  <SNR>49_GetCurrentChar()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:878
Called 4 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    4              0.000025   return strpart(getline('.'), getcurpos()[2]-2, 1)

FUNCTION  easycomplete#GetBindingKeys()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:163
Called 47 times
Total time:   0.000278
 Self time:   0.000278

count  total (s)   self (s)
                              " 通用触发跟指匹配的字符绑定，所有文档类型生效
                              " 另外每个插件可自定义触发按键，在插件的 semantic_triggers 中定义
   47              0.000129   let l:key_liststr = 'abcdefghijklmnopqrstuvwxyz'. 'ABCDEFGHIJKLMNOPQRSTUVWXYZ#$/._'
   47              0.000059   return l:key_liststr

FUNCTION  easycomplete#_complete()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2133
Called 9 times
Total time:   0.115035
 Self time:   0.000870

count  total (s)   self (s)
    9              0.000121   let g:easycomplete_complete_ctx = { 'start': a:start, 'candidates': a:items, }
    9              0.000088   if mode() =~# 'i' && &paste != 1
    9              0.000020     let should_fire_pum_show = v:false
    9              0.000009     if g:env_is_nvim
    9   0.000178   0.000060       if !easycomplete#pum#visible() && !empty(a:items)
                                    let should_fire_pum_show = v:true
    9              0.000007       endif
    9   0.109820   0.000089       call easycomplete#pum#complete(a:start, a:items)
    9              0.000009       if g:easycomplete_ghost_text
    9   0.000400   0.000073         let ghost_text = s:GetGhostText(a:start, a:items[0]["word"])
    9              0.000016         let g:easycomplete_ghost_text_str = ghost_text
    9              0.000024         if !exists("g:easycomplete_second_complete_ghost_timer")
                                      let g:easycomplete_second_complete_ghost_timer = 0
    9              0.000004         endif
    9              0.000011         if g:easycomplete_second_complete_ghost_timer > 0
                                      call timer_stop(g:easycomplete_second_complete_ghost_timer)
                                      let g:easycomplete_second_complete_ghost_timer = 0
    9              0.000003         endif
    9              0.000061         let g:easycomplete_second_complete_ghost_timer = timer_start(40, { -> easycomplete#util#ShowHint(ghost_text) })
    9              0.000004       endif
                                else
                                  let should_fire_pum_show = v:false
                                  if !pumvisible() && !empty(a:items)
                                    let should_fire_pum_show = v:true
                                  endif
                                  silent! noa call feedkeys("\<Plug>EasycompleteRefresh", 'i')
    9              0.000003     endif
    9              0.000008     if should_fire_pum_show
                                  silent doautocmd <nomodeline> User easycomplete_pum_show
    9              0.000004     else
    9   0.004048   0.000059       call s:ShowCompleteInfoInSecondRendering()
    9              0.000003     endif
    9              0.000003   endif

FUNCTION  <SNR>49_CompleteInit()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1824
Called 1 time
Total time:   0.000084
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000002   if !exists('a:1')
    1   0.000060   0.000005     let l:word = s:GetTypingWord()
                              else
                                let l:word = a:1
    1              0.000000   endif
                              " 这会导致 pum 闪烁
    1              0.000002   let g:easycomplete_menuitems = []
                              " 用一个延时来避免闪烁
    1              0.000003   if exists('g:easycomplete_visual_delay') && g:easycomplete_visual_delay > 0
    1              0.000003     call timer_stop(g:easycomplete_visual_delay)
    1              0.000000   endif
    1              0.000009   let g:easycomplete_visual_delay = timer_start(100, function("s:CompleteMenuResetHandler"))

FUNCTION  <SNR>56_Length()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:1414
Called 2 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000005   let l:adj_end_line = len(a:lines) + a:end_line
    2              0.000004   if l:adj_end_line >= len(a:lines)
                                let l:adj_end_char = a:end_char - 1
    2              0.000001   else
    2              0.000006     let l:adj_end_char = strchars(a:lines[l:adj_end_line]) + a:end_char
    2              0.000001   endif
    2              0.000002   if a:start_line == l:adj_end_line
    2              0.000003     return l:adj_end_char - a:start_char + 1
                              endif
                              let l:result = strchars(a:lines[a:start_line]) - a:start_char + 1
                              let l:line = a:start_line + 1
                              while l:line < l:adj_end_line
                                let l:result += strchars(a:lines[l:line]) + 1
                                let l:line += 1
                              endwhile
                              let l:result += l:adj_end_char + 1
                              return l:result

FUNCTION  <SNR>49_SecondComplete()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:435
Called 11 times
Total time:   0.011780
 Self time:   0.008180

count  total (s)   self (s)
   11              0.000422   let tmp_menuitems = copy(a:easycomplete_menuitems)
   11              0.000224   let g:easycomplete_stunt_menuitems = copy(a:menuitems)
   11              0.000062   let result = a:menuitems[0 : g:easycomplete_maxlength]
   11              0.000015   if len(result) <= 5
                                let result = easycomplete#util#uniq(result)
   11              0.000004   endif
                              " 这里功能上是不必要的，因为已经输入新的字符，应该匹配出新的TN结果，而GetGlobalSourceItems
                              " 返回的是旧的，这里还要加上旧结果只是为了先占位，防止删除+呈现TN新结果时的pum的抖动
                              "
                              " 但TN并不是每次都能有返回，如果没有返回结果时，这里的旧的占位的结果也应该更新掉，否则会
                              " 出现 #368 的问题，所以要有一个定时器判断TN有没有正确的返回，如果没有正确返回，那么占位
                              " 的TN的旧结果要更新掉
   11   0.000706   0.000205   if easycomplete#sources#tn#available()
                                let l:tn_ret = easycomplete#sources#tn#GetGlobalSourceItems()
                                let b:easycomplete_tn_match_done = 0
                                let result_all = l:tn_ret + result
                                call easycomplete#util#timer_start("easycomplete#UpdateTNPlaceHolder", [a:word], 20)
   11              0.000004   else
   11              0.000038     let result_all = [] + result
   11              0.000004   endif
   11   0.000117   0.000068   call s:StopFirstCompleteRenderingTimer()
   11   0.002949   0.000147   call s:SecondCompleteRendering(a:start_pos, result_all)
   11   0.007088   0.006839   call s:AddCompleteCache(a:word, deepcopy(g:easycomplete_stunt_menuitems))
                              " complete() 会触发 completedone 事件，会执行 s:flush()
                              " 所以这里要确保 g:easycomplete_menuitems 不会被修改
   11              0.000016   let g:easycomplete_menuitems = tmp_menuitems

FUNCTION  easycomplete#typing()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:946
Called 2 times
Total time:   0.042685
 Self time:   0.000313

count  total (s)   self (s)
    2   0.000081   0.000016   if !easycomplete#ok('g:easycomplete_enable')
                                return
    2              0.000001   endif
                            
    2   0.000028   0.000014   let l:curr_char = s:GetCurrentChar()
                            
    2              0.000004   if l:curr_char == " "
                                call s:flush()
                                return
    2              0.000001   endif
                            
    2   0.000084   0.000058   if (g:env_is_vim && pumvisible()) || (g:env_is_nvim && easycomplete#pum#visible())
                                return ""
    2              0.000001   endif
                            
    2              0.000008   let g:easycomplete_start = reltime()
    2   0.000334   0.000022   let back_checking = s:BackChecking()
    2              0.000003   if g:env_is_vim && back_checking
                                let g:easycomplete_backing = 1
                                call s:BackingCompleteHandler()
                                call s:SnapShoot()
                                return ""
    2              0.000001   endif
    2              0.000003   if g:env_is_nvim && back_checking
                                let g:easycomplete_backing = 1
                                call s:BackingCompleteHandler()
                                " 回退不能激发 complete
                                call s:SnapShoot()
                                return ""
    2              0.000001   endif
                            
    2              0.000003   let g:easycomplete_backing = 0
                            
                              " 判断是否是 C-V 粘贴
    2   0.000087   0.000015   call s:AsyncRun('easycomplete#ResetInsertChar', [], 30)
    2              0.000004   if empty(g:easycomplete_insert_char)
                                return ""
    2              0.000001   endif
                            
                              " TODO 为了防止tab补全 tabnine后自动触发complete动作，这里需要更多测试兼容性
    2   0.000018   0.000012   if s:zizzing() | return "" | endif
                            
    2   0.001667   0.000011   if !easycomplete#FireCondition()
                                " tabnine
    1   0.000009   0.000006     if s:TabnineSupports() && easycomplete#sources#tn#FireCondition()
                                  call s:flush()
                                  if g:env_is_nvim
                                    call s:util_toolkit.defer_fn("easycomplete#sources#tn#refresh", [v:true], 20)
                                  else
                                    call timer_start(20, { -> easycomplete#sources#tn#refresh(v:true) })
                                  endif
    1              0.000001     endif
    1              0.000001     return ""
    1              0.000001   endif
                            
                              " hack for vim ':' typing
    1              0.000004   if &filetype == 'vim' && l:curr_char == ":"
                                if !s:VimColonTyping()
                                  return ""
                                endif
    1              0.000000   endif
                            
                              " vim lsp 返回结果中包含多层的对象，比如 "a.b.c"，这样在输入"." 时就需要匹配
                              " 返回结果中的"."，":" 也是同理，这里只对 viml 做特殊处理
    1   0.000155   0.000007   if s:VimColonTyping()
                                " continue
    1   0.000127   0.000007   elseif s:VimDotTyping()
                                " continue
    1   0.000008   0.000005   elseif s:zizzing()
                                return ""
    1              0.000001   endif
                            
    1   0.000161   0.000008   call s:SnapShoot()
    1   0.000032   0.000006   call s:StopAsyncRun()
    1   0.039779   0.000010   call s:DoComplete(v:false)
    1              0.000001   return ""

FUNCTION  easycomplete#popup#CloseLintPopup()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/popup.vim:747
Called 1 time
Total time:   0.000122
 Self time:   0.000043

count  total (s)   self (s)
    1   0.000058   0.000008   if easycomplete#popup#LintPopupVisible()
    1   0.000063   0.000034     call s:CloseByWindowType("float")
    1              0.000000   endif

FUNCTION  <SNR>75_GetTyped()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/action/signature.vim:61
Called 4 times
Total time:   0.000684
 Self time:   0.000176

count  total (s)   self (s)
    4   0.000553   0.000045   let ctx = easycomplete#context()
    4              0.000006   let linenr = 10
    4              0.000008   if line(".") == 1
                                let typed = trim(ctx["typed"])
    4              0.000002   else
    4              0.000017     let start_line_nr = line(".") - linenr <= 0 ? 0 : line(".") - linenr
    4              0.000026     let lines = getline(start_line_nr, line(".") - 1)
    4              0.000030     let prelines = trim(join(lines, " "))
    4              0.000017     let typed = prelines . " " . trim(ctx["typed"])
    4              0.000002   endif
    4              0.000005   return typed

FUNCTION  <SNR>49_NormalTrigger()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:807
Called 27 times
Total time:   0.004077
 Self time:   0.001212

count  total (s)   self (s)
   27   0.002868   0.000361   let l:char = easycomplete#context()["char"]
   27   0.000253   0.000180   if s:zizzing() && index([":",".","_","/",">"], l:char) < 0
    5              0.000006     return v:false
   22              0.000010   endif
                              " if s:PythonColonTyping()
                              "   return v:false
                              " endif
   22   0.000377   0.000258   let binding_keys = easycomplete#GetBindingKeys()
   22   0.000463   0.000298   if index(easycomplete#util#str2list(binding_keys), char2nr(l:char)) >= 0
   16              0.000014     return v:true
    6              0.000002   endif
    6              0.000005   return v:false

FUNCTION  <SNR>52_RenderScrollThumb()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:732
Called 54 times
Total time:   0.008091
 Self time:   0.002880

count  total (s)   self (s)
   54   0.001008   0.000732   if !s:pumvisible() || !s:HasScrollbar()
   10   0.000114   0.000049     call s:CloseScrollThumb()
   10              0.000006     return
   44              0.000018   endif
   44              0.000076   if empty(s:scrollbar_buffer)
                                let s:scrollbar_buffer = s:CreateEmptyBuffer()
                                let buflines = s:GetScrollBufflines()
                                call nvim_buf_set_lines(s:scrollbar_buffer, 0, -1, v:false, buflines)
   44              0.000015   endif
   44   0.005278   0.000525   let pos = s:ComputeScrollThumbPos()
   44              0.000158   let scrollthumb_opts = deepcopy(s:default_scroll_thumb_pot)
   44              0.000133   call extend(scrollthumb_opts, pos)
   44              0.000052   if scrollthumb_opts.height == 0
                                call s:CloseScrollThumb()
                                return
   44              0.000016   endif
   44              0.000061   if empty(s:scrollthumb_window)
                                " create scrollthumb window
    1              0.000002     let hl = "Normal:PmenuThumb,NormalNC:PmenuThumb,CursorLine:PmenuThumb,NonText:PmenuThumb"
    1   0.000127   0.000008     let s:scrollthumb_window = s:OpenFloatWindow(s:scrollbar_buffer, scrollthumb_opts, hl)
   43              0.000019   else
                                " update scrollthumb window
                            
                                " if get(scrollthumb_opts, "row") == -1 && g:easycomplete_winborder
                                "   let scrollthumb_opts["row"] = 100
                                " endif
                                " if get(scrollthumb_opts, "row") == 0 && g:easycomplete_winborder
                                "   let scrollthumb_opts["row"] = 101
                                " endif
   43              0.000240     call nvim_win_set_config(s:scrollthumb_window, scrollthumb_opts)
   44              0.000020   endif

FUNCTION  <SNR>49_StopZizz()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2576
Called 11 times
Total time:   0.000253
 Self time:   0.000220

count  total (s)   self (s)
   11              0.000035   if exists('s:zizz_timmer') && s:zizz_timmer > 0
   11              0.000024     call timer_stop(s:zizz_timmer)
   11              0.000005   endif
   11   0.000178   0.000144   call s:ResetBacking()

FUNCTION  <SNR>77_TypingAPath()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/path.vim:148
Called 1 time
Total time:   0.000155
 Self time:   0.000124

count  total (s)   self (s)
                              " TODO 这里不清楚为什么
                              " 输入 ./a/b/c ，./a/b/  两者得到的prefx都为空
                              " 前者应该得到 c, 这里只能临时将base透传进来表示文件名
    1              0.000008   if exists("g:easycomplete_cmdline_typing") && g:easycomplete_cmdline_typing == 1
                                let line = getcmdline()
                                let coln = getcmdpos() - 1
    1              0.000001   else
    1              0.000002     let l:ctx = a:1
    1              0.000003     let line  = getline('.')
    1              0.000002     let coln  = l:ctx['col'] - 1
    1              0.000001   endif
    1              0.000003   let prefx = ' ' . line[0:coln - 1]
                            
                              " 需要注意，参照上一个注释，fpath和spath只是path，没有filename
                              " 从正在输入的一整行字符(行首到光标)中匹配出一个path出来
                              " TODO 正则不严格，需要优化，下面这几个情况匹配要正确
                              "   \ a <Tab>  => done
                              "   \<Tab> => done
                              "   xxxss \ xxxss<Tab> => done
                              " MoreInfo: #140
    1              0.000001   try
    1              0.000029     let fpath = matchstr(prefx,"\\([\\(\\) \"'\\t\\[\\]\\{\\}]\\)\\@<=" .   "\\([\\/\\.\\~]\\+[\\.\\/a-zA-Z0-9\u2e80-\uef4f\\_\\- ]\\+\\|[\\.\\/]\\)")
                              catch /^Vim\%((\a\+)\)\=:E945/
                                let fpath = matchstr(prefx,"\\([\\(\\) \"'\\t\\[\\]\\{\\}]\\)\\@<=" .   "\\([\\/\\.\\~]\\+[\\.\\/a-zA-Z0-9\\_\\- ]\\+\\|[\\.\\/]\\)")
    1              0.000001   endtry
                            
                              " 兼容单个 '/' 匹配的情况
    1   0.000025   0.000015   let spath = s:GetPathName(substitute(fpath,"^[\\.\\/].*\\/","./","g"))
                              " 清除对 '\' 的路径识别
    1   0.000012   0.000005   let fpath = s:GetPathName(fpath)
                            
    1              0.000002   let pathDict                 = {}
    1              0.000002   let pathDict.line            = line
    1              0.000001   let pathDict.prefx           = prefx
    1   0.000019   0.000005   let pathDict.fname           = s:GetFileName(prefx)
    1              0.000001   let pathDict.fpath           = fpath " fullpath
    1              0.000001   let pathDict.spath           = spath " shortpath
    1              0.000003   let pathDict.full_path_start = coln - len(fpath) + 2
    1              0.000003   if trim(pathDict.fname) == ''
                                let pathDict.short_path_start = coln - len(spath) + 2
    1              0.000001   else
    1              0.000002     let pathDict.short_path_start = coln - len(pathDict.fname)
    1              0.000000   endif
                            
                              " 排除掉输入注释的情况
                              " 因为如果输入'//'紧跟<Tab>不应该出<C-X><C-U><C-N>出补全菜单
    1              0.000003   if len(fpath) == 0 || match(prefx,"\\(\\/\\/\\|\\/\\*\\)") >= 0
    1              0.000001     let pathDict.is_path = 0
                              elseif fpath == "/"
                                let pathDict.is_path = 0
                              else
                                let pathDict.is_path = 1
    1              0.000000   endif
                            
    1              0.000001   return pathDict

FUNCTION  <lambda>25662()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 8 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# '$/vimlsp/lsp_server_exit' 

FUNCTION  easycomplete#sources#tn#available()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/tn.vim:34
Called 34 times
Total time:   0.001426
 Self time:   0.000544

count  total (s)   self (s)
   34   0.001327   0.000446   if easycomplete#ok('g:easycomplete_tabnine_enable') && easycomplete#sources#tn#JobStatus() == "run"
                                return s:tn_init_ready
   34              0.000014   else
   34              0.000027     return v:false
                              endif

FUNCTION  <SNR>52_select()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:456
Called 26 times
Total time:   0.015647
 Self time:   0.001821

count  total (s)   self (s)
   26   0.000199   0.000145   if !s:pumvisible() | return | endif
   26              0.000047   if a:line_index > len(s:curr_items)
                                let l:line_index = (a:line_index + len(s:curr_items)) % len(s:curr_items)
   26              0.000012   else
   26              0.000037     let l:line_index = a:line_index
   26              0.000010   endif
   26              0.000023   if l:line_index == 0
    5              0.000035     call setwinvar(s:pum_window, '&cursorline', 0)
    5              0.000007     let s:selected_i = 0
   21              0.000007   else
   21              0.000138     call setwinvar(s:pum_window, '&cursorline', 1)
   21              0.000442     call nvim_win_set_cursor(s:pum_window, [l:line_index, 1])
   21              0.000031     let s:selected_i = l:line_index
   21              0.000058     if g:easycomplete_pum_format[0] == "kind" && g:easycomplete_nerd_font == 1
                                  let bufline_str = getbufline(s:pum_buffer, s:selected_i)[0]
                                  " 读取行内 nerdfont 字符时要用函数 strcharpart，不能用下标
                                  " line_str[1], 用下标取的结果会把字符截断
                                  let kind_char = strcharpart(bufline_str, 2, 1)
                                  let prefix_length = 5 + strlen(kind_char)
   21              0.000009     else
   21              0.000023       let prefix_length = 2
   21              0.000008     endif
   21   0.009816   0.000190     call s:HLCursordFuzzyChar("CustomFuzzyMatch", prefix_length)
   26              0.000011   endif
   26   0.004345   0.000199   call s:RenderScrollThumb()

FUNCTION  easycomplete#sources#snips#completor()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/snips.vim:2
Called 1 time
Total time:   0.000129
 Self time:   0.000043

count  total (s)   self (s)
    1   0.000068   0.000010   if !easycomplete#SnipSupports() && !easycomplete#LuaSnipSupports()
                                call easycomplete#complete(a:opt['name'], a:ctx, a:ctx['startcol'], [])
                                return v:true
    1              0.000000   endif
    1              0.000002   let l:typing = a:ctx['typing']
    1              0.000003   if index(['.','/',':'], a:ctx['char']) >= 0
                                call easycomplete#complete(a:opt['name'], a:ctx, a:ctx['startcol'], [])
                                return v:true
    1              0.000000   endif
    1              0.000002   if strlen(l:typing) == 0
                                call easycomplete#complete(a:opt['name'], a:ctx, a:ctx['startcol'], [])
                                return v:true
    1              0.000000   endif
                              " call timer_start(10, {
                              "       \ -> easycomplete#sources#snips#CompleteHandler(l:typing, a:opt['name'], a:ctx, a:ctx['startcol'])
                              "       \ })
    1   0.000038   0.000011   call easycomplete#util#timer_start( "easycomplete#sources#snips#CompleteHandler", [l:typing, a:opt['name'], a:ctx, a:ctx['startcol']], 10)
                              " #133
                              " call easycomplete#complete(a:opt['name'], a:ctx, a:ctx['startcol'], [])
    1              0.000001   return v:true

FUNCTION  <SNR>49_VimColonTyping()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:853
Called 1 time
Total time:   0.000149
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000002   if !(&filetype == "vim")
                                return v:false
    1              0.000000   endif
    1   0.000126   0.000010   let l:typed = easycomplete#context()['typed']
    1              0.000014   if    (   l:typed =~ "\\W\\(w\\|t\\|a\\|b\\|v\\|s\\|g\\):$"   ||   l:typed =~ "^\\(w\\|t\\|a\\|b\\|v\\|s\\|g\\):$" )
                                return v:true
    1              0.000001   else
    1              0.000001     return v:false
                              endif

FUNCTION  <SNR>49_RemovePrefixIgnoreCase()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2075
Called 21 times
Total time:   0.000387
 Self time:   0.000387

count  total (s)   self (s)
   21              0.000036   if a:prefix ==# ''
                                return a:str
   21              0.000008   endif
                              " 构造正则表达式：忽略大小写匹配前缀，并只匹配开头部分
   21              0.000061   let pattern = '\c^' . escape(a:prefix, '\/.*$^~[]')
                              " 判断是否匹配
   21              0.000104   if a:str =~ pattern
                                " 匹配则返回去掉前缀的部分
   21              0.000110     return substitute(a:str, pattern, '', '')
                              else
                                " 不匹配则返回空字符串
                                return ''
                              endif

FUNCTION  easycomplete#util#GetLspPlugin()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:1523
Called 13 times
Total time:   0.005607
 Self time:   0.000440

count  total (s)   self (s)
   13   0.005448   0.000281   let attached_plugins = call("easycomplete#util#GetAttachedPlugins", a:000)
   13              0.000021   let ret_plugin = {}
   13              0.000020   for plugin in attached_plugins
   13              0.000040     if has_key(plugin, 'gotodefinition') && has_key(plugin, 'command')
   13              0.000019       let ret_plugin = plugin
   13              0.000010       break
                                endif
   13              0.000011   endfor
   13              0.000012   return ret_plugin

FUNCTION  <SNR>57_createProd()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:231
Called 3 times
Total time:   0.006882
 Self time:   0.000085

count  total (s)   self (s)
    3              0.000006   if a:start != 0 | return | endif
    3              0.000005   let a:data['sink'] = a:sink
    3              0.000020   if !has_key(a:data, 'prod') || type(a:data['prod']) != type(function('s:noop'))
                                call a:sink(0, function('s:noop'))
                                call a:sink(2, easycomplete#lsp#callbag#undefined())
                                return
    3              0.000001   endif
    3              0.000004   let a:data['end'] = 0
    3   0.000147   0.000026   call a:sink(0, function('s:createSinkCallback', [a:data]))
    3              0.000005   if a:data['end'] | return | endif
    3   0.005290   0.003393   let a:data['clean'] = a:data['prod'](function('s:createNext', [a:data]), function('s:createError', [a:data]), function('s:createComplete', [a:data]))

FUNCTION  easycomplete#util#ShowHint()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:7
Called 15 times
Total time:   0.000491
 Self time:   0.000491

count  total (s)   self (s)
   15              0.000037   if g:env_is_vim | return | endif
   15              0.000442   call s:tabnine_toolkit.show_hint([a:text])

FUNCTION  easycomplete#pum#CompleteInfo()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:429
Called 45 times
Total time:   0.000642
 Self time:   0.000564

count  total (s)   self (s)
   45   0.000570   0.000493   let l:ret = { "mode": "function", "pum_visible": s:pumvisible() ? v:true : v:false, "items": s:curr_items, "selected": s:selected_i - 1, }
   45              0.000036   return l:ret

FUNCTION  <SNR>49_GetTypingWordByGtx()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1323
Called 22 times
Total time:   0.002615
 Self time:   0.000327

count  total (s)   self (s)
   22              0.000033   if empty(g:easycomplete_firstcomplete_ctx)
                                return ""
   22              0.000008   endif
   22   0.002391   0.000104   let l:ctx = easycomplete#context()
   22              0.000027   let l:gtx = g:easycomplete_firstcomplete_ctx
   22              0.000040   let offset = l:gtx['startcol'] - l:ctx['startcol']
   22              0.000074   return l:ctx['typed'][strlen(l:gtx['typed']) - strlen(l:gtx['typing']) - offset:]

FUNCTION  easycomplete#pum#PumSelectedIndex()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:424
Called 9 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    9              0.000008   return s:selected_i

FUNCTION  <SNR>56_on_text_document_did_close()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:137
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000004   let l:buf = bufnr('%')
    2              0.000008   if getbufvar(l:buf, '&buftype') ==# 'terminal' | return | endif

FUNCTION  <SNR>52_CloseScrollBar()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:725
Called 6 times
Total time:   0.000088
 Self time:   0.000054

count  total (s)   self (s)
    6              0.000016   if !empty(s:scrollbar_window) && nvim_win_is_valid(s:scrollbar_window)
    1   0.000046   0.000011     call nvim_win_close(s:scrollbar_window, 1)
    6              0.000003   endif
    6              0.000008   let s:scrollbar_window = 0

FUNCTION  <SNR>56_text_changes()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:599
Called 2 times
Total time:   0.004238
 Self time:   0.000108

count  total (s)   self (s)
    2   0.000113   0.000018   let l:sync_kind = s:get_text_document_change_sync_kind(a:server_name)
                            
                              " When syncKind is None, return null for contentChanges.
    2              0.000002   if l:sync_kind == 0
                                return v:null
    2              0.000001   endif
                            
                              " When syncKind is Incremental and previous content is saved.
    2              0.000006   if l:sync_kind == 2 && has_key(s:file_content, a:buf)
                                " compute diff
    2   0.000031   0.000016     let l:old_content = s:get_last_file_content(a:buf, a:server_name)
    2   0.000222   0.000012     let l:new_content = s:get_lines(a:buf)
    2   0.003759   0.000016     let l:changes = s:diff_compute(l:old_content, l:new_content)
    2              0.000006     if empty(l:changes.text) && l:changes.rangeLength ==# 0
                                  return []
    2              0.000001     endif
    2   0.000083   0.000016     call s:update_file_content(a:buf, a:server_name, l:new_content)
    2              0.000002     return [l:changes]
                              endif
                            
                              let l:new_content = s:get_lines(a:buf)
                              let l:changes = {'text': join(l:new_content, "\n")}
                              call s:update_file_content(a:buf, a:server_name, l:new_content)
                              return [l:changes]

FUNCTION  easycomplete#tabnine#ready()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/tabnine.vim:10
Called 29 times
Total time:   0.001511
 Self time:   0.000569

count  total (s)   self (s)
   29              0.000036   if g:env_is_vim
                                return v:false
   29              0.000013   endif
   29   0.000439   0.000201   if !easycomplete#util#HasLua()
                                return v:false
   29              0.000011   endif
   29   0.000879   0.000176   if !easycomplete#ok('g:easycomplete_tabnine_enable')
   29              0.000025     return v:false
                              endif
                              if !easycomplete#ok('g:easycomplete_tabnine_suggestion')
                                return v:false
                              endif
                              if !easycomplete#installer#LspServerInstalled("tn")
                                return v:false
                              endif
                              return v:true

FUNCTION  easycomplete#ok()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2661
Called 136 times
Total time:   0.003888
 Self time:   0.003888

count  total (s)   self (s)
  136              0.000368   if empty(bufname())
                                return v:false
  136              0.000063   endif
                              " let varstr = substitute(a:str, "[abvgsl]:","","i")
  136              0.000336   let varstr = a:str[2:]
  136              0.000130   let flag = 0
  136              0.000432   let value = get(g:easycomplete_config, a:str, 0)
  136              0.000547   if exists(a:str) && get(g:, varstr, 0) == 0
   89              0.000080     let flag = 0
   47              0.000152   elseif exists(a:str) && get(g:, varstr, 0) != 0
   47              0.000107     let flag = get(g:, varstr, 0)
                              elseif !exists(a:str)
                                let flag = value
  136              0.000053   endif
  136              0.000342   let g:easycomplete_config[a:str] = flag
  136              0.000126   return flag

FUNCTION  <SNR>49_ShowCompleteInfo()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1486
Called 20 times
Total time:   0.008863
 Self time:   0.000399

count  total (s)   self (s)
   20   0.001251   0.000180   call easycomplete#HandleTagbarUpdateAction()
   20   0.007600   0.000207   call easycomplete#popup#MenuPopupChanged(a:info)

FUNCTION  easycomplete#util#GetAttachedPlugins()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:26
Called 13 times
Total time:   0.005167
 Self time:   0.005019

count  total (s)   self (s)
   13   0.000329   0.000181   let all_plugins = easycomplete#GetAllPlugins()
   13              0.000055   let buf_nr = empty(a:000) ? bufnr('%') : str2nr(a:1)
   13              0.000046   let ft = getbufvar(buf_nr, "&filetype")
   13              0.000017   let attached_plugins = []
  403              0.000347   for name in keys(all_plugins)
  390              0.000623     let plugin = get(all_plugins, name)
  767              0.000503     if empty(plugin) | continue | endif
  390              0.000715     let whitelist = get(plugin, 'whitelist', [])
  390              0.000379     if empty(whitelist)
                                  continue
  390              0.000116     endif
  390              0.000586     if index(whitelist, ft) >= 0
   13              0.000028       call add(attached_plugins, plugin)
  390              0.000120     endif
  403              0.000187   endfor
   13              0.000015   return attached_plugins

FUNCTION  <SNR>49_CallCompeltorByName()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:764
Called 5 times
Total time:   0.030721
 Self time:   0.000135

count  total (s)   self (s)
    5              0.000013   let l:opt = get(g:easycomplete_source, a:name)
    5              0.000017   if empty(l:opt) || empty(get(l:opt, "completor"))
                                return v:true
    5              0.000002   endif
    5              0.000011   let b:completor = get(l:opt, "completor")
    5              0.000009   if type(b:completor) == 2 " type is function
    2   0.001033   0.000031     return b:completor(l:opt, a:ctx)
    3              0.000001   endif
    3              0.000006   if type(b:completor) == type("string") " type is string
    3   0.029613   0.000029     return call(b:completor, [l:opt, a:ctx])
                              endif

FUNCTION  <SNR>80_GetBufKeywordsList()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/buf.vim:96
Called 1 time
Total time:   0.003051
 Self time:   0.003051

count  total (s)   self (s)
    1              0.000003   if !exists("g:easycomplete_bufkw_storage")
                                let g:easycomplete_bufkw_storage = {}
    1              0.000000   endif
    1              0.000001   let tmpkeywords = []
                              " preform: 0.022s
   11              0.000133   for buf in getbufinfo()
   10              0.000024     if !empty(getbufvar(buf['bufnr'], '&buftype'))
    5              0.000003       continue
    5              0.000002     endif
    5              0.000008     if !(bufloaded(buf['bufnr']))
    2              0.000001       continue
    3              0.000001     endif
    3              0.000011     let nr_key = 'k' . string(buf['bufnr']) " bufnr key
    3              0.000007     let tk_key = 'c' . string(buf['bufnr']) " changedtick key
    3              0.000010     let stored_kws = get(g:easycomplete_bufkw_storage, nr_key, [])
    3              0.000009     let stored_cgtk = get(g:easycomplete_bufkw_storage, tk_key, 0)
    3              0.000008     if buf["changedtick"] == stored_cgtk && !empty(stored_kws)
    2              0.000462       let tmpkeywords += copy(stored_kws)
    1              0.000000     else
    1              0.000058       let lines = getbufline(buf.bufnr, 1 ,"$")
    1              0.000001       let local_kwlist = []
                                  " 性能测试：分检出 84238 个单词
                                  " lua: 0.021
                                  " vim: 0.147
    1              0.000001       if g:env_is_nvim
    1              0.001212         let local_kwlist = s:lua_toolkit.get_buf_keywords_from_lines(lines)
                                  else
                                    for line in lines
                                      let local_kwlist += split(line,'[^A-Za-z0-9_#]')
                                    endfor
    1              0.000000       endif
    1              0.000003       let g:easycomplete_bufkw_storage[nr_key] = local_kwlist
    1              0.000003       let g:easycomplete_bufkw_storage[tk_key] = buf["changedtick"]
    1              0.000174       let tmpkeywords += local_kwlist
    3              0.000001     endif
    4              0.000004   endfor
                              " call easycomplete#util#StartRecord()
    1              0.000001   if g:env_is_nvim
                                " 匹配首字符
                                " 58424 → 3623   0.010739
                                " 匹配前三个起始字符
                                " 53378 → 4781   0.006533
                                " 53378 → 4781   0.006361
                                " lua 的实现选择匹配前三个字符
    1              0.000787     let keyword_list = s:lua_toolkit.filter(tmpkeywords, a:typing)
                              else
                                " 匹配首字符
                                " 58424 → 3623   0.082437
                                " 匹配前三个起始字符
                                " 53378 → 4781   0.102643
                                " 53378 → 4781   0.101672
                                " vim 的实现还是应该性能优先，只匹配首字符
                                " call filter(tmpkeywords, 'v:val =~ "^' . a:typing . '" && v:val !=# "' . a:typing . '"')
                                call filter(tmpkeywords, 'v:val =~ "^' . a:typing . '"')
                                let keyword_list = tmpkeywords
    1              0.000001   endif
                              " call easycomplete#util#StopRecord('filter ' . len(tmpkeywords) . "→" . len(keyword_list))
    1              0.000002   return keyword_list

FUNCTION  <SNR>52_TrimAboveHeight()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:931
Called 36 times
Total time:   0.000338
 Self time:   0.000338

count  total (s)   self (s)
   36              0.000053   let l:real_above_space = a:above_space
   36              0.000044   let h = g:easycomplete_pum_maxheight
   36              0.000030   if g:easycomplete_winborder
   36              0.000075     let l:real_above_space = a:above_space > h - 2 ? h - 2 : a:above_space
                              else
                                let l:real_above_space = a:above_space > h ? h : a:above_space
   36              0.000013   endif
   36              0.000030   return l:real_above_space

FUNCTION  <SNR>52_flush()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:1097
Called 6 times
Total time:   0.002127
 Self time:   0.000702

count  total (s)   self (s)
    6              0.000028   let should_fire_pum_done = 0
    6              0.000030   if !empty(s:pum_window) && nvim_win_is_valid(s:pum_window)
    2   0.000108   0.000067     call nvim_win_close(s:pum_window, 1)
    2   0.000123   0.000013     call s:RecoverOpt()
    2              0.000003     let should_fire_pum_done = 1
    6              0.000004   endif
    6              0.000011   if !empty(s:scrollthumb_window)
    1   0.000025   0.000006     call s:CloseScrollThumb()
    6              0.000002   endif
    6              0.000008   if !empty(s:scrollbar_window)
    1   0.000056   0.000005     call s:CloseScrollBar()
    6              0.000002   endif
    6              0.000008   let s:pum_window = 0
    6              0.000006   let s:has_scrollbar = 0
    6              0.000005   let s:selected_i = 0
    6              0.000115   let s:curr_items = []
    6              0.000024   let s:original_ctx = {}
    6              0.000007   let s:scrollthumb_window = 0
    6              0.000006   let s:scrollbar_window= 0
    6              0.000008   let s:pum_direction = ""
    6              0.000007   let g:easycomplete_match_id = 0
    6              0.000006   if should_fire_pum_done
    2   0.001149   0.000009     doautocmd <nomodeline> User easycomplete_pum_done
    6              0.000002   endif
    6              0.000006   if !s:contains_shortmess
    6   0.000069   0.000052     set shortmess-=c
    6              0.000003   endif
    6              0.000060   call execute("noa setl textwidth=" . s:textwidth)
    6              0.000047   call execute("noa setl completeopt=" . s:completeopt)
    6   0.000106   0.000060   if g:easycomplete_ghost_text && !(s:cmdline())
    3              0.000003     if !s:lazyredraw
    3              0.000012       noa setlocal nolazyredraw
    3              0.000002     endif
    6              0.000002   endif

FUNCTION  <lambda>4038()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 8 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# 'textDocument/publishDiagnostics'

FUNCTION  easycomplete#lsp#callbag#isUndefined()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:11
Called 6 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    6              0.000019   return type(a:d) == s:str_type && a:d ==# s:undefined_token

FUNCTION  easycomplete#util#call()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:82
Called 32 times
Total time:   0.024089
 Self time:   0.002494

count  total (s)   self (s)
   32              0.000083   try
   32              0.000092     if type(a:method) == 2 " 是函数
   26              0.000112       let TmpCallback = function(a:method, a:args)
   26   0.008133   0.000182       return TmpCallback()
    6              0.000004     endif
    6              0.000009     let res = 0
    6              0.000013     if type(a:method) == type("string") " 是字符串
    6   0.015260   0.001617       let res = call(a:method, a:args)
    6              0.000013     endif
    6              0.000019     let g:easycomplete_popup_timer = -1
    6              0.000011     return res
                              catch /.*/
                                return 0
   32              0.000028   endtry

FUNCTION  easycomplete#context()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:706
Called 202 times
Total time:   0.021509
 Self time:   0.008264

count  total (s)   self (s)
  202              0.001210   let l:ret = { 'bufnr':bufnr('%'), 'curpos':getcurpos(), 'changedtick': b:changedtick }
  202              0.000533   let l:ret['lnum'] = l:ret['curpos'][1] " 行号
  202              0.000352   let l:ret['col'] = l:ret['curpos'][2] " 列号
  202              0.000386   let l:ret['filetype'] = &filetype " filetype
  202              0.000537   if !exists("b:easycomplete_buffer_filepath")
                                let b:easycomplete_buffer_filepath = expand('%:p') " filepath
  202              0.000118   end
  202              0.000361   let l:ret['filepath'] = b:easycomplete_buffer_filepath
  202              0.000433   let l:line = getline(l:ret['lnum']) " 当前行内容
  202              0.000305   let l:ret['line'] = l:line
  202              0.000583   let l:ret['typed'] = strpart(l:line, 0, l:ret['col']-1) " 光标前敲入的内容
  202              0.000491   let l:ret['char'] = strpart(l:line, l:ret['col']-2, 1) " 当前单个字符
  202   0.014596   0.001351   let l:ret['typing'] = s:GetTypingWord() " 当前敲入的单词
  202              0.000660   let l:ret['startcol'] = l:ret['col'] - strlen(l:ret['typing']) " 单词起始位置
  202              0.000154   return l:ret

FUNCTION  easycomplete#complete()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:737
Called 5 times
Total time:   0.071130
 Self time:   0.000233

count  total (s)   self (s)
    5   0.000164   0.000050   if s:NotInsertMode()
                                call s:flush()
                                return
    5              0.000002   endif
    5   0.000572   0.000027   let l:ctx = easycomplete#context()
    5   0.000125   0.000036   if !s:SameCtx(a:ctx, l:ctx)
                                return
    5              0.000002   endif
    5   0.000215   0.000040   call s:SetCompleteTaskQueue(a:plugin_name, l:ctx, 1, 1)
    5   0.070026   0.000052   call s:CompleteAdd(a:items, a:plugin_name)

FUNCTION  <SNR>56_ensure_changed()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:540
Called 6 times
Total time:   0.009020
 Self time:   0.004672

count  total (s)   self (s)
    6              0.000012   let l:server = s:servers[a:server_name]
    6   0.000232   0.000082   let l:path = easycomplete#lsp#utils#get_buffer_uri(a:buf)
                            
    6              0.000011   let l:buffers = l:server['buffers']
    6              0.000013   if !has_key(l:buffers, l:path)
                                let l:msg = s:new_rpc_success('file is not managed', { 'server_name': a:server_name, 'path': l:path })
                                call s:errlog("[ERR]ensure_changed", l:msg)
                                call a:cb(l:msg)
                                return
    6              0.000003   endif
    6              0.000013   let l:buffer_info = l:buffers[l:path]
                            
    6              0.000019   let l:changed_tick = getbufvar(a:buf, 'changedtick')
                            
    6              0.000014   if l:buffer_info['changed_tick'] == l:changed_tick
    4   0.000058   0.000034     let l:msg = s:new_rpc_success('not dirty', { 'server_name': a:server_name, 'path': l:path })
    4   0.000113   0.000043     call s:errlog("[ERR]ensure_changed", l:msg)
    4   0.000605   0.000013     call a:cb(l:msg)
    4              0.000003     return
    2              0.000001   endif
                            
    2              0.000005   let l:buffer_info['changed_tick'] = l:changed_tick
    2              0.000005   let l:buffer_info['version'] = l:buffer_info['version'] + 1
                            
    2   0.004846   0.000151   call s:send_notification(a:server_name, { 'method': 'textDocument/didChange', 'params': {   'textDocument': s:get_versioned_text_document_identifier(a:buf, l:buffer_info),   'contentChanges': s:text_changes(a:buf, a:server_name), } })
                              " call lsp#ui#vim#folding#send_request(a:server_name, a:buf, 0)
    2              0.001771   call easycomplete#lsp#folding#send_request(a:server_name, a:buf, 0)
                            
    2   0.000034   0.000021   let l:msg = s:new_rpc_success('textDocument/didChange sent', { 'server_name': a:server_name, 'path': l:path })
                              " call s:errlog("[LOG]", l:msg)
    2   0.000305   0.000007   call a:cb(l:msg)

FUNCTION  <SNR>12_Remove_Matches()
    Defined: /usr/local/lib/nvim-macos-x86_64/share/nvim/runtime/plugin/matchparen.vim:203
Called 53 times
Total time:   0.000582
 Self time:   0.000582

count  total (s)   self (s)
   53              0.000133   if exists('w:paren_hl_on') && w:paren_hl_on
                                while !empty(w:matchparen_ids)
                                  silent! call remove(w:matchparen_ids, 0)->matchdelete()
                                endwhile
                                let w:paren_hl_on = 0
   53              0.000021   endif

FUNCTION  easycomplete#util#ItemIsFromLS()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:1679
Called 30 times
Total time:   0.000592
 Self time:   0.000592

count  total (s)   self (s)
   30              0.000070   let menu_str = get(a:item, "menu", "")
   30              0.000083   if !exists("b:easycomplete_lsp_plugin")
                                return v:false
   30              0.000010   endif
   30              0.000068   let plugin_name = get(b:easycomplete_lsp_plugin, "name", "")
   30              0.000073   if plugin_name == "tn" | return v:false | endif
   30              0.000081   let item_lsp_name = get(a:item, "plugin_name", "")
   30              0.000080   if toupper(item_lsp_name) == toupper(plugin_name)
                                return v:true
   30              0.000013   else
   30              0.000022     return v:false
                              endif

FUNCTION  <lambda>4040()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 8 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# '$/vimlsp/lsp_server_exit' 

FUNCTION  easycomplete#util#GetFileName()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:1512
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000002   let path  = simplify(a:path)
    1              0.000003   let fname = fnamemodify(path, ":t")
    1              0.000001   return fname

FUNCTION  easycomplete#lsp#folding#send_request()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/folding.vim:49
Called 2 times
Total time:   0.002631
 Self time:   0.000080

count  total (s)   self (s)
                              " if !easycomplete#lsp#capabilities#has_folding_range_provider(a:server_name)
                              "     return
                              " endif
    2   0.000094   0.000013   if !s:has_provider(a:server_name, 'foldingRangeProvider')
                                return
    2              0.000001   endif
                            
    2              0.000009   if has('textprop')
                                call s:set_textprops(a:buf)
    2              0.000001   endif
                            
    2   0.002515   0.000045   call easycomplete#lsp#send_request(a:server_name, { 'method': 'textDocument/foldingRange', 'params': {   'textDocument': easycomplete#lsp#get_text_document_identifier(a:buf) }, 'on_notification': function('s:handle_fold_request', [a:server_name]), 'sync': a:sync, 'bufnr': a:buf })

FUNCTION  easycomplete#util#PrepareInfoPlaceHolder()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:1418
Called 350 times
Total time:   0.002036
 Self time:   0.002036

count  total (s)   self (s)
  350              0.001022   if !(has_key(a:val, "info") && type(a:val.info) == type("") && !empty(a:val.info))
  350              0.000281     let a:val.info = ""
  350              0.000097   endif
  350              0.000266   let a:val.equal = 1
  350              0.000185   return a:val

FUNCTION  <SNR>61_callback()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/utils/step.vim:13
Called 33 times
Total time:   0.043601
 Self time:   0.000034

count  total (s)   self (s)
   33   0.009707   0.008926   call s:next(a:steps, a:current_index + 1, a:000)

FUNCTION  <SNR>113_VimHack_GetVimTypingWord()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/vim.vim:80
Called 30 times
Total time:   0.000548
 Self time:   0.000548

count  total (s)   self (s)
   30              0.000038   let start = col('.') - 1
   30              0.000034   let line = getline('.')
   30              0.000033   let width = 0
   30              0.000023   let regx = '[a-zA-Z0-9_.:]'
   60              0.000135   while start > 0 && line[start - 1] =~ regx
   30              0.000025     let start = start - 1
   30              0.000022     let width = width + 1
   60              0.000104   endwhile
   30              0.000048   let word = strpart(line, start, width)
   30              0.000018   return word

FUNCTION  <SNR>49_CloseCompletionMenu()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1783
Called 4 times
Total time:   0.000391
 Self time:   0.000177

count  total (s)   self (s)
    4              0.000005   if g:env_is_nvim
    4   0.000063   0.000025     if easycomplete#pum#visible()
    2              0.000017       call timer_start(5, { -> easycomplete#pum#close() })
    2   0.000070   0.000014       call s:zizz()
    4              0.000003     endif
                              else
                                if pumvisible()
                                  if !(g:easycomplete_pum_noselect)
                                    call timer_start(10, { -> s:SendKeys("\<Esc>a")})
                                  else
                                    silent! noa call s:SendKeys("\<C-Y>")
                                  endif
                                  call s:zizz()
                                endif
    4              0.000002   endif
    4   0.000147   0.000028   call s:ResetCompletedItem()

FUNCTION  <SNR>49_SecondCompleteRendering()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:418
Called 11 times
Total time:   0.002801
 Self time:   0.000318

count  total (s)   self (s)
   11              0.000014   if g:env_is_iterm
   11   0.000275   0.000047     call s:StopAsyncRun()
   11              0.000018     if len(g:easycomplete_stunt_menuitems) < 40
                                  call s:AsyncRun('easycomplete#_complete', [a:start_pos, a:result], 5)
   11              0.000007     else
   11   0.002350   0.000094       call s:AsyncRun('easycomplete#_complete', [a:start_pos, a:result], 30)
   11              0.000005     endif
                              else
                                call s:complete(a:start_pos, a:result)
   11              0.000004   endif

FUNCTION  <SNR>49_SetCompleteTaskQueue()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2357
Called 125 times
Total time:   0.002423
 Self time:   0.002423

count  total (s)   self (s)
  125              0.001709   call filter(g:easycomplete_complete_taskqueue, 'v:val.name != "'.a:name.'"')
  125              0.000636   call add(g:easycomplete_complete_taskqueue, { "name" : a:name, "condition": a:condition, "ctx" : a:ctx, "done" : a:done })

FUNCTION  <SNR>65_has_provider()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/folding.vim:38
Called 2 times
Total time:   0.000081
 Self time:   0.000066

count  total (s)   self (s)
    2   0.000030   0.000015   let l:value = easycomplete#lsp#get_server_capabilities(a:server_name)
    4              0.000006   for l:provider in a:000
    2              0.000011     if empty(l:value) || type(l:value) != type({}) || !has_key(l:value, l:provider)
                                  return 0
    2              0.000001     endif
    2              0.000004     let l:value = l:value[l:provider]
    4              0.000003   endfor
    2              0.000010   return (type(l:value) == type(v:true) && l:value == v:true) || type(l:value) == type({})

FUNCTION  easycomplete#DoLspComplete()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2644
Called 1 time
Total time:   0.005653
 Self time:   0.000012

count  total (s)   self (s)
    1   0.005653   0.000011   return easycomplete#action#completion#do(a:opt, a:ctx)

FUNCTION  <SNR>56_send_request()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:515
Called 3 times
Total time:   0.000484
 Self time:   0.000052

count  total (s)   self (s)
    3              0.000007   let l:lsp_id = s:servers[a:server_name]['lsp_id']
    3              0.000009   let l:data = copy(a:data)
    3              0.000005   if has_key(l:data, 'on_notification')
    3              0.000006     let l:data['on_notification'] = '---funcref---'
    3              0.000001   endif
    3   0.000452   0.000021   return easycomplete#lsp#client#send_request(l:lsp_id, a:data)
                              " call s:errlog('[LOG]', 'lsp request --->', l:lsp_id, a:server_name, l:data)

FUNCTION  easycomplete#popup#LintPopupVisible()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/popup.vim:327
Called 1 time
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    1              0.000043   if g:env_is_nvim && nvim_win_is_valid(g:easycomplete_popup_win["float"])
    1              0.000005     return v:true
                              elseif g:easycomplete_popup_win["float"] && s:float_type == "lint"
                                return v:true
                              else
                                return v:false
                              endif

FUNCTION  <SNR>52_ComputeScrollBarPos()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:770
Called 21 times
Total time:   0.001016
 Self time:   0.000361

count  total (s)   self (s)
   21   0.000752   0.000096   let pum_pos = s:PumPosition()
   21              0.000040   let c = pum_pos.pos[1] + pum_pos.width - 1
   21              0.000022   let r = pum_pos.pos[0]
   21              0.000014   let w = 1
   21              0.000018   let h = pum_pos.height
   21              0.000020   if g:easycomplete_winborder
   21              0.000018     let c = c + 1
   21              0.000018     let r = r + 1 " + (s:pum_direction == "above" ? 2 : 0)
   21              0.000009   endif
   21              0.000075   return { "col": c, "row": r, "width": w, "height": h }

FUNCTION  easycomplete#util#FindLspServers()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:2089
Called 22 times
Total time:   0.004458
 Self time:   0.000913

count  total (s)   self (s)
   22              0.000037   let l:server_names = []
   44   0.003646   0.000251   for l:server_name in easycomplete#lsp#get_allowed_servers()
   22   0.000329   0.000180     let l:init_capabilities = easycomplete#lsp#get_server_capabilities(l:server_name)
   22              0.000046     if has_key(l:init_capabilities, 'completionProvider')
                                  " TODO: support triggerCharacters
   22              0.000060       call add(l:server_names, l:server_name)
   22              0.000009     endif
   44              0.000098   endfor
                            
   22              0.000052   return { 'server_names': l:server_names }

FUNCTION  <SNR>57_tapSourceCallback()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:146
Called 18 times
Total time:   0.009629
 Self time:   0.000424

count  total (s)   self (s)
   18   0.006368   0.000145   if a:t == 1 && has_key(a:data, 'next') | call a:data['next'](a:d) | endif
   18              0.000074   if a:t == 2 && easycomplete#lsp#callbag#isUndefined(a:d) && has_key(a:data, 'complete') | call a:data['complete']() | endif
   18              0.000059   if a:t == 2 && !easycomplete#lsp#callbag#isUndefined(a:d) && has_key(a:data, 'error') | call a:data['error'](a:d) | endif
   18   0.003097   0.000115   call a:data['sink'](a:t, a:d)

FUNCTION  easycomplete#pum#PumGetPos()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:357
Called 65 times
Total time:   0.005028
 Self time:   0.002172

count  total (s)   self (s)
   65   0.000360   0.000251   if !s:pumvisible()
                                return {}
   65              0.000025   endif
   65   0.002985   0.000386   let pum_pos = s:PumPosition()
   65              0.000088   let h = pum_pos.height
   65              0.000061   let w = pum_pos.width
   65              0.000092   let r = pum_pos.pos[0]
   65              0.000067   let c = pum_pos.pos[1]
   65   0.000569   0.000421   let scrollbar = s:HasScrollbar()
   65              0.000053   if scrollbar
   65              0.000070     let w = w - 1
   65              0.000029   endif
   65              0.000125   let item_size = len(s:curr_items)
   65              0.000326   return { "col": c + 1, "row": r, "height": h, "width": w - 1, "scrollbar": scrollbar, "size": item_size }

FUNCTION  <lambda>136998()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 2 times
Total time:   0.000664
 Self time:   0.000014

count  total (s)   self (s)
                            return Callback(x['server'], x['response'])

FUNCTION  <lambda>136999()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 8 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# '$/vimlsp/lsp_server_exit' 

FUNCTION  easycomplete#lsp#get_position()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:977
Called 1 time
Total time:   0.000033
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000002   let l:line = line('.')
    1   0.000027   0.000009   let l:char = easycomplete#lsp#utils#to_char('%', l:line, col('.'))
    1              0.000003   return { 'line': l:line - 1, 'character': l:char }

FUNCTION  <SNR>49_SemanticTriggerForPluginName()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:794
Called 15 times
Total time:   0.001633
 Self time:   0.000369

count  total (s)   self (s)
   15   0.001386   0.000123   let ctx = easycomplete#context()
   15              0.000057   let trigger_keys = get(g:easycomplete_source[a:name], 'semantic_triggers', [])
   15              0.000042   if empty(trigger_keys) | return v:false | endif
   12              0.000018   for item_rgx in trigger_keys
    9              0.000060     if ctx['typed'] =~ item_rgx
                                  return v:true
    9              0.000004     endif
   12              0.000028   endfor
    3              0.000003   return v:false

FUNCTION  <SNR>56_diff_compute()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:1325
Called 2 times
Total time:   0.003743
 Self time:   0.000206

count  total (s)   self (s)
    2   0.002866   0.000019   let [l:start_line, l:start_char] = s:FirstDifference(a:old, a:new)
    2   0.000718   0.000097   let [l:end_line, l:end_char] = s:LastDifference(a:old[l:start_line :], a:new[l:start_line :], l:start_char)
                            
    2   0.000061   0.000018   let l:text = s:ExtractText(a:new, l:start_line, l:start_char, l:end_line, l:end_char)
    2   0.000060   0.000034   let l:length = s:Length(a:old, l:start_line, l:start_char, l:end_line, l:end_char)
                            
    2              0.000004   let l:adj_end_line = len(a:old) + l:end_line
    2              0.000007   let l:adj_end_char = l:end_line == 0 ? 0 : strchars(a:old[l:end_line]) + l:end_char + 1
                            
    2              0.000018   let l:result = { 'range': {'start': {'line': l:start_line, 'character': l:start_char}, 'end': {'line': l:adj_end_line, 'character': l:adj_end_char}}, 'text': l:text, 'rangeLength': l:length,}
                            
    2              0.000002   return l:result

FUNCTION  <SNR>52_CloseScrollThumb()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:833
Called 11 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
   11              0.000030   if !empty(s:scrollthumb_window) && nvim_win_is_valid(s:scrollthumb_window)
    1              0.000012     call nvim_win_close(s:scrollthumb_window, 1)
   11              0.000004   endif
   11              0.000014   let s:scrollthumb_window = 0

FUNCTION  <SNR>56_ensure_init()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:447
Called 6 times
Total time:   0.011016
 Self time:   0.000073

count  total (s)   self (s)
    6              0.000013   let l:server = s:servers[a:server_name]
                            
    6              0.000011   if has_key(l:server, 'init_result')
    6   0.000089   0.000054     let l:msg = s:new_rpc_success('lsp server already initialized', { 'server_name': a:server_name, 'init_result': l:server['init_result'] })
                                " call s:errlog("[LOG]", l:msg)
    6   0.009071   0.006862     call a:cb(l:msg)
    6              0.000003     return
                              endif
                            
                              if has_key(l:server, 'init_callbacks')
                                " waiting for initialize response
                                call add(l:server['init_callbacks'], a:cb)
                                let l:msg = s:new_rpc_success('waiting for lsp server to initialize', { 'server_name': a:server_name })
                                " call s:errlog("[LOG]", l:msg)
                                return
                              endif
                            
                              " server has already started, but not initialized
                              let l:server_info = l:server['server_info']
                              if has_key(l:server_info, 'root_uri')
                                let l:root_uri_type = type(l:server_info['root_uri'])
                                if l:root_uri_type == v:t_list
                                  let l:root_uri_o = l:server_info['root_uri'][0]
                                elseif l:root_uri_type == v:t_string
                                  let l:root_uri_o = l:server_info['root_uri']
                                else
                                  let l:root_uri_o = l:server_info['root_uri'](l:server_info)
                                endif
                              else
                                let l:root_uri_o = ""
                              endif
                            
                              let l:root_uri = l:root_uri_o
                              if empty(l:root_uri)
                                let l:root_uri = easycomplete#lsp#utils#get_default_root_uri()
                              endif
                              let l:server['server_info']['_root_uri_resolved'] = l:root_uri
                            
                              if has_key(l:server_info, 'capabilities')
                                let l:capabilities = l:server_info['capabilities']
                              else
                                let l:capabilities = call(function('easycomplete#lsp#default_get_supported_capabilities'), [l:server_info])
                              endif
                              if easycomplete#util#GetCurrentPluginName() == "go"
                                call remove(l:capabilities["textDocument"], "typeHierarchy")
                              endif
                            
                              let l:request = {   'method': 'initialize',   'params': {     'processId': getpid(),     'clientInfo': { 'name': 'vim-lsp' },     'capabilities': l:capabilities,     'rootUri': l:root_uri,     'rootPath': easycomplete#lsp#utils#uri_to_path(l:root_uri),     'trace': 'off',   }, }
                            
                              if has_key(l:server_info, 'initialization_options')
                                let l:request.params['initializationOptions'] = l:server_info['initialization_options']
                              endif
                            
                              let l:server['init_callbacks'] = [a:cb]
                              call s:send_request(a:server_name, l:request)

FUNCTION  easycomplete#pum#complete()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:66
Called 26 times
Total time:   0.272097
 Self time:   0.009622

count  total (s)   self (s)
   26              0.000113   if len(a:items) == 0
                                call s:close()
                                return
   26              0.000016   endif
   26   0.001073   0.000189   if easycomplete#ok("g:easycomplete_tabnine_enable")
                                let items = s:TabNineHLNormalize(a:items)
   26              0.000051   else
   26              0.000036     let items = a:items
   26              0.000013   endif
   26              0.007662   let s:curr_items = deepcopy(items)
   26   0.262673   0.001156   call s:OpenPum(a:startcol, s:NormalizeItems(s:curr_items))
   26              0.000028   if !s:contains_shortmess
   26   0.000197   0.000123     set shortmess+=c
   26              0.000011   endif

FUNCTION  easycomplete#sources#buf#completor()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/buf.vim:5
Called 1 time
Total time:   0.023795
 Self time:   0.000197

count  total (s)   self (s)
    1              0.000002   let l:typing = a:ctx['typing']
                            
    1              0.000002   if a:ctx['char'] ==# '.'
                                call easycomplete#complete(a:opt['name'], a:ctx, a:ctx['startcol'], [])
                                return v:true
    1              0.000000   endif
                            
    1              0.000002   if strlen(l:typing) == 0
                                call easycomplete#complete(a:opt['name'], a:ctx, a:ctx['startcol'], [])
                                return v:true
    1              0.000000   endif
                            
                              " 这里异步和非异步都可以，性能考虑，如果返回空用同步，如果数据量大用异步
                            
                              " call easycomplete#util#timer_start("easycomplete#sources#buf#CompleteHandler",
                              "       \ [l:typing, a:opt['name'], a:ctx, a:ctx['startcol']], 0)
                            
    1   0.023776   0.000179   call easycomplete#sources#buf#CompleteHandler(l:typing, a:opt['name'], a:ctx, a:ctx['startcol'])
                            
                              " call easycomplete#complete(a:opt['name'], a:ctx, a:ctx['startcol'], [])
    1              0.000001   return v:true

FUNCTION  <SNR>61_next()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/utils/step.vim:1
Called 42 times
Total time:   0.062284
 Self time:   0.000142

count  total (s)   self (s)
   42              0.000083   if len(a:steps) == a:current_index
                                return
   42              0.000018   endif
   42              0.000092   let l:Step = a:steps[a:current_index]
   42              0.000248   let l:ctx = { 'callback': function('s:callback', [a:steps, a:current_index]), 'result': a:result }
   42   0.009893   0.009214   call call(l:Step, [l:ctx])

FUNCTION  <SNR>49_CompleteMenuResetHandler()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1839
Called 1 time
Total time:   0.000076
 Self time:   0.000051

count  total (s)   self (s)
    1   0.000067   0.000042   if s:NotInsertMode() | return |endif
    1              0.000004   if !exists("g:easycomplete_menuitems") || empty(g:easycomplete_menuitems)
                                call s:CloseCompletionMenu()
    1              0.000000   endif

FUNCTION  easycomplete#CompleteCursored()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:552
Called 168 times
Total time:   0.003600
 Self time:   0.002028

count  total (s)   self (s)
  168   0.002294   0.001048   if g:env_is_nvim && easycomplete#pum#visible()
  163   0.001166   0.000839     return easycomplete#pum#CompleteCursored()
    5              0.000007   elseif g:env_is_vim && pumvisible()
                                return complete_info()['selected'] == -1 ? v:false : v:true
    5              0.000002   else
    5              0.000004     return v:false
                              endif

FUNCTION  <SNR>56_get_text_document_change_sync_kind()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:580
Called 2 times
Total time:   0.000095
 Self time:   0.000080

count  total (s)   self (s)
    2   0.000050   0.000035   let l:capabilities = easycomplete#lsp#get_server_capabilities(a:server_name)
    2              0.000008   if !empty(l:capabilities) && has_key(l:capabilities, 'textDocumentSync')
    2              0.000007     if type(l:capabilities['textDocumentSync']) == type({})
                                  if  has_key(l:capabilities['textDocumentSync'], 'change') && type(l:capabilities['textDocumentSync']['change']) == type(1)
                                    let l:val = l:capabilities['textDocumentSync']['change']
                                    return l:val >= 0 && l:val <= 2 ? l:val : 1
                                  else
                                    return 1
                                  endif
    2              0.000005     elseif type(l:capabilities['textDocumentSync']) == type(1)
    2              0.000003       return l:capabilities['textDocumentSync']
                                else
                                  return 1
                                endif
                              endif
                              return 1

FUNCTION  <SNR>52_MapFunction()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:1187
Called 1077 times
Total time:   0.062504
 Self time:   0.062504

count  total (s)   self (s)
 1077              0.001165   let kind_char = "ϟ"
 1077              0.000907   if g:easycomplete_nerd_font
 1077              0.001867     let kind_o = get(a:val, "kind", "")
 1077              0.004281     if      kind_o ==# g:easycomplete_lsp_type_font["function"] || kind_o ==# g:easycomplete_lsp_type_font["constant"] || kind_o ==# g:easycomplete_lsp_type_font["struct"]
                                  " 颜色1
                                  let kind_char = "⊥"
 1077              0.003064     elseif  kind_o ==# g:easycomplete_menu_skin["snip"]["kind"] || kind_o ==# g:easycomplete_lsp_type_font["snippet"]
                                  " 颜色2
                                  let kind_char = "∫"
 1077              0.001780     elseif kind_o ==# g:easycomplete_menu_skin["tabnine"]["kind"]
                                  " 颜色3
                                  let kind_char = "∮"
 1077              0.003488     elseif  kind_o ==# g:easycomplete_menu_skin["buf"]["kind"] || kind_o ==# g:easycomplete_menu_skin["dict"]["kind"] || kind_o ==# g:easycomplete_lsp_type_font["text"]
                                  " 颜色4，标准色
  656              0.000540       let kind_char = "Φ"
  421              0.001053     elseif  kind_o ==# g:easycomplete_lsp_type_font["keyword"] || kind_o ==# g:easycomplete_lsp_type_font["class"]
                                  " 颜色 5
                                  let kind_char = "♧"
  421              0.001024     elseif  kind_o ==# g:easycomplete_lsp_type_font["module"] || kind_o ==# g:easycomplete_lsp_type_font["method"]
                                  " 颜色 6
                                  let kind_char = "♤"
 1077              0.000407     endif
 1077              0.000370   endif
 1077              0.001793   let kind_str = get(a:val, "kind", "")
 1077              0.000939   if kind_str == ""
                                let kind_char = ""
 1077              0.000351   endif
 1077              0.005941   let format_object = { "abbr" : get(a:val, "abbr", ""), "kind" : kind_char . kind_str . kind_char, "menu" : "‰" . get(a:val, "menu", "") . "‰" }
 1077              0.000805   let ret = []
 1077              0.000865   if g:easycomplete_nerd_font
 1077              0.001265     let format_s = g:easycomplete_pum_format
                              else
                                let format_s = ["abbr", "kind", "menu"]
 1077              0.000343   endif
 4308              0.003161   for item in format_s
 3231              0.007636     call add(ret, " " . get(format_object, item, ""))
 4308              0.003419   endfor
 1077              0.002106   return join(ret,"")

FUNCTION  <SNR>57_subscribeSourceCallback()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:315
Called 27 times
Total time:   0.066308
 Self time:   0.000858

count  total (s)   self (s)
   27              0.000060   if a:t == 0 | let a:data['talkback'] = a:d | endif
   27   0.063443   0.000185   if a:t == 1 && has_key(a:data, 'next') | call a:data['next'](a:d) | endif
   27   0.002338   0.000334   if a:t == 1 || a:t == 0 | call a:data['talkback'](1, easycomplete#lsp#callbag#undefined()) | endif
   27   0.000322   0.000145   if a:t == 2 && easycomplete#lsp#callbag#isUndefined(a:d) && has_key(a:data, 'complete') | call a:data['complete']() | endif
   27   0.000115   0.000104   if a:t == 2 && !easycomplete#lsp#callbag#isUndefined(a:d) && has_key(a:data, 'error') | call a:data['error'](a:d) | endif

FUNCTION  <lambda>25591()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 8 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# 'textDocument/publishDiagnostics'

FUNCTION  <lambda>25592()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 2 times
Total time:   0.000695
 Self time:   0.000031

count  total (s)   self (s)
                            return Callback(x['server'], x['response'])

FUNCTION  <lambda>25593()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 8 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# '$/vimlsp/lsp_server_exit' 

FUNCTION  <SNR>52_NormalizeItems()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:1182
Called 26 times
Total time:   0.137564
 Self time:   0.005765

count  total (s)   self (s)
   26   0.069754   0.000460   let new_line_arr = s:GetFullfillItems(a:items)
   26   0.067786   0.005282   return map(copy(new_line_arr["items"]), function('s:MapFunction'))

FUNCTION  <SNR>113_VimHack_A_DotMap()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sources/vim.vim:64
Called 170 times
Total time:   0.004773
 Self time:   0.002669

count  total (s)   self (s)
  170              0.000577   if has_key(a:val, "abbr") && has_key(a:val, "word") && stridx(get(a:val, "word"), ".") > 0
   15   0.001186   0.000057     let ctx = easycomplete#context()
   15   0.000374   0.000082     let vim_typing_word = s:VimHack_GetVimTypingWord()
   15              0.000019     if ctx["char"] == "."
                                  let a:val.word = substitute(get(a:val, "word"), "^" . vim_typing_word, "", "g")
   15              0.000006     else
   15   0.000497   0.000071       let word = easycomplete#util#GetTypingWord()
   15              0.000101       let a:val.word = substitute(get(a:val, "word"), "^" . vim_typing_word[:-1 * ( 1 + strlen(word))], "", "g")
   15              0.000005     endif
   15   0.000339   0.000082     let vim_typing_word = s:VimHack_GetVimTypingWord()
  170              0.000050   endif
  170              0.000093   return a:val

FUNCTION  easycomplete#GetAllPlugins()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:257
Called 13 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
   13              0.000139   return copy(g:easycomplete_source)

FUNCTION  easycomplete#util#FunctionSurffixMap()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:1605
Called 170 times
Total time:   0.011786
 Self time:   0.010891

count  total (s)   self (s)
  170              0.000530   let is_func = (get(a:val,'kind_number') == 3 || get(a:val,'kind_number') == 2)
  170              0.000338   let kind = exists('a:val.kind') ? a:val.kind : ""
  170              0.000298   let word = exists('a:val.word') ? a:val.word : ""
  170              0.000302   let menu = exists('a:val.menu') ? a:val.menu : ""
  170              0.000308   let abbr = exists('a:val.abbr') ? a:val.abbr : ""
  170              0.000306   let info = exists('a:val.info') ? a:val.info : ""
  170              0.000350   let kind_number = exists('a:val.kind_number') ? a:val.kind_number : 0
  170              0.000410   let user_data = exists('a:val.user_data') ? a:val.user_data : ""
  170              0.000355   let user_data_json = exists('a:val.user_data_json') ? a:val.user_data_json : {}
  170   0.002198   0.001303   let next_to_left_paren = easycomplete#util#IsCursorNextToLeftParen()
  170              0.001059   let ret = { "abbr":      abbr, "dup":       1, "icase":     1, "kind":      kind, "menu":      menu, "word":      word, "info":      info, "equal":     1, "user_data": user_data, "kind_number": kind_number, "user_data_json": user_data_json }
  170              0.000095   if is_func
                                if stridx(word,"(") <= 0
                                  " 不包含括号时，自动加上括号，考虑到右侧是否挨着左括号
                                  " 没括号就没有需要展开的结构，还需要简单展开即可
                                  let ret["word"] = word . (next_to_left_paren ? "" : "()")
                                  let ret['abbr'] = word . "~"
                                  let user_data_json_f = extend(easycomplete#util#GetUserData(a:val), { 'expandable': (next_to_left_paren ? 0 : 1), 'custom_expand': (next_to_left_paren ? 0 : 1), 'placeholder_position': (next_to_left_paren ? strlen(word) : strlen(word) + 1), 'cursor_backing_steps': (next_to_left_paren ? 0 : 1) })
                                  let ret['user_data'] = json_encode(user_data_json_f)
                                  let ret['user_data_json'] = user_data_json_f
                                elseif next_to_left_paren && word[-2:] == "()"
                                  " 右侧挨着左括号
                                  let ret["word"] = word[0:-3]
                                  let ret['abbr'] = ret["abbr"]
                                  let user_data_json_f = extend(easycomplete#util#GetUserData(a:val), { 'expandable': 0, 'custom_expand': 0, 'placeholder_position': strlen(word), 'cursor_backing_steps': 0 })
                                  let ret['user_data'] = json_encode(user_data_json_f)
                                  let ret['user_data_json'] = user_data_json_f
                                elseif !next_to_left_paren && stridx(word,"(") > 0
                                  " 右侧没挨着左括号，且包含()
                                  " 保持原样，需要判断snip展开
                                  let ret["word"] = word
                                  let ret['abbr'] = ret['abbr']
                                  let user_data_json_f = extend(easycomplete#util#GetUserData(a:val), { 'expandable': 1, 'placeholder_position': strlen(word) - 1, 'cursor_backing_steps':1 })
                                  if easycomplete#SnipExpandSupport()
                                    let user_data_json_f["custom_expand"] = 0
                                  else
                                    let user_data_json_f["custom_expand"] = 1
                                  endif
                                  let ret['user_data'] = json_encode(user_data_json_f)
                                  let ret['user_data_json'] = user_data_json_f
                                endif
  170              0.000054   endif
  170              0.000100   return ret

FUNCTION  <SNR>49_CompleteMatchAction()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1333
Called 11 times
Total time:   0.122486
 Self time:   0.007602

count  total (s)   self (s)
   11   0.000436   0.000183   call s:StopZizz()
   11   0.000113   0.000077   if s:TabnineSupports()
                                call easycomplete#sources#tn#refresh()
   11              0.000005   endif
                              " let l:vim_word = s:GetTypingWordByGtx() " 刚输入的单词
   11   0.001105   0.000184   let l:vim_word = easycomplete#util#GetTypingWord()
   11              0.000034   let l:vim_char = strpart(getline('.'), col('.') - 2, 1) " 刚输入的字符
   11              0.000021   if g:env_is_nvim && empty(l:vim_word)
                                " 输入了 . 或者 : 后先 closemenu 再尝试做一次匹配
                                " 也有可能输入了(，这时应该尝试执行signature
                                call s:CloseCompletionMenu()
                                call s:flush()
                                call s:StopZizz()
                                " 这里的 timer 要比 tabnine 的触发慢 20ms 以上才能正常激活 
                                let local_delay = easycomplete#ok("g:easycomplete_tabnine_enable") ? 50 : 20
                                if g:env_is_nvim
                                  call s:util_toolkit.defer_fn("easycomplete#typing", [], local_delay)
                                  if easycomplete#ok('g:easycomplete_signature_enable')
                                    call easycomplete#action#signature#LazyRunHandle()
                                  endif
                                else
                                  call timer_start(local_delay, { -> easycomplete#typing() })
                                endif
                                return
   11              0.000004   endif
   11   0.118583   0.006753   call s:CompleteTypingMatch(l:vim_word)
   11   0.001939   0.000094   call s:SnapShoot()

FUNCTION  easycomplete#sign#hold()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/sign.vim:296
Called 3 times
Total time:   0.002065
 Self time:   0.000262

count  total (s)   self (s)
    3   0.000227   0.000077   let diagnostics = easycomplete#sign#GetCurrentDiagnostics()
    3   0.000055   0.000037   if easycomplete#sign#DiagnosticsIsEmpty(diagnostics)
    3   0.000744   0.000028     call easycomplete#sign#flush()
    3   0.000945   0.000026     call easycomplete#sign#ClearSign()
                              else
                                let cache = get(g:easycomplete_diagnostics_cache, easycomplete#util#GetCurrentFullName(), {})
                                let uri = cache['params']['uri']
                                let fn = easycomplete#util#TrimFileName(uri)
                                let file_line_plus_one = len(getbufline(bufnr(''),1,'$')) + 1
                                if get(g:, "easycomplete_place_holder", 0) == 0
                                  let cmd = "sign place 999 line=" . file_line_plus_one . " name=place_holder file=" . fn
                                  call execute(cmd)
                                  let g:easycomplete_place_holder = 1
                                endif
    3              0.000002   endif

FUNCTION  <lambda>331()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 8 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# '$/vimlsp/lsp_server_exit' 

FUNCTION  easycomplete#CheckContextSequence()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:728
Called 12 times
Total time:   0.001585
 Self time:   0.000140

count  total (s)   self (s)
   12   0.001581   0.000136   return s:SameCtx(a:ctx, easycomplete#context())

FUNCTION  easycomplete#InsertLeave()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:537
Called 1 time
Total time:   0.013821
 Self time:   0.000062

count  total (s)   self (s)
    1   0.000108   0.000033   if easycomplete#ok('g:easycomplete_diagnostics_enable')
    1   0.010113   0.000007     call easycomplete#lint()
                                " call easycomplete#sign#LintCurrentLine()
    1   0.000397   0.000009     call easycomplete#sign#LintPopup()
    1              0.000000   endif
    1   0.000016   0.000005   call easycomplete#tabnine#flush()
    1   0.003184   0.000004   call s:flush()

FUNCTION  easycomplete#action#diagnostics#HandleCallback()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/action/diagnostics.vim:19
Called 18 times
Total time:   0.006063
 Self time:   0.000449

count  total (s)   self (s)
   18              0.000161   if getbufinfo(bufnr())[0].changed == 1
   18   0.004111   0.000141     call easycomplete#sign#flush()
   18              0.000008   endif
   18   0.001742   0.000099   call easycomplete#sign#cache(a:response)
   18              0.000023   let s:response_ready = 1

FUNCTION  <SNR>49_ResetBacking()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2556
Called 23 times
Total time:   0.000187
 Self time:   0.000187

count  total (s)   self (s)
   23              0.000159   let g:easycomplete_backing_or_cr = 0

FUNCTION  easycomplete#action#signature#FireCondition()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/action/signature.vim:56
Called 2 times
Total time:   0.000441
 Self time:   0.000129

count  total (s)   self (s)
    2   0.000333   0.000022   let l:typed = s:GetTyped()
    2              0.000106   return l:typed =~ "\\w($" || (l:typed =~ "\\w(.*,$" && getline(".") =~ "(")

FUNCTION  <lambda>136997()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 8 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
                            return has_key(x, 'server') && has_key(x, 'response')           && get(x['response'], 'method', '') ==# 'textDocument/publishDiagnostics'

FUNCTION  easycomplete#util#GetCurrentFullName()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:391
Called 77 times
Total time:   0.000365
 Self time:   0.000365

count  total (s)   self (s)
   77              0.000216   if exists("b:easycomplete_buf_fullname")
   77              0.000101     return b:easycomplete_buf_fullname
                              else
                                let b:easycomplete_buf_fullname = easycomplete#util#GetFullName(bufname("%"))
                                return b:easycomplete_buf_fullname
                              endif

FUNCTION  easycomplete#HandleTagbarUpdateAction()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1491
Called 20 times
Total time:   0.001071
 Self time:   0.000209

count  total (s)   self (s)
   20   0.000978   0.000116   if easycomplete#util#TagBarExists()
                                try
                                  call tagbar#StopAutoUpdate()
                                catch /^Vim\%((\a\+)\)\=:E216/
                                  " Do Nothing
                                endtry
   20              0.000007   endif

FUNCTION  <SNR>49_StopAsyncRun()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:3061
Called 33 times
Total time:   0.000745
 Self time:   0.000251

count  total (s)   self (s)
   33   0.000727   0.000233   return call('easycomplete#util#StopAsyncRun', a:000)

FUNCTION  easycomplete#tabnine#flush()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/tabnine.vim:106
Called 27 times
Total time:   0.000300
 Self time:   0.000148

count  total (s)   self (s)
   27   0.000286   0.000134   call s:flush()

FUNCTION  <SNR>40_NormalizeLspInfo()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:2061
Called 170 times
Total time:   0.003490
 Self time:   0.003490

count  total (s)   self (s)
  170              0.000464   if type(a:info) == type({})
                                let info = get(a:info, "value", "")
  170              0.000074   else
  170              0.000173     let info = a:info
  170              0.000083   endif
  170              0.000522   let l:li = split(info, "\n")
  170              0.000161   let l:str = []
  170              0.000221   if &filetype == "vim"
  170              0.000196     let l:str = l:li
                              else
                                for item in l:li
                                  if item ==# '```' || item =~ "^```\[a-zA-Z0-9]\\{-}$"
                                    continue
                                  endif
                                  call add(l:str, item)
                                endfor
  170              0.000061   endif
  170              0.000123   return l:str

FUNCTION  <SNR>49_DoComplete()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1031
Called 1 time
Total time:   0.039769
 Self time:   0.000079

count  total (s)   self (s)
    1   0.000090   0.000005   let l:ctx = easycomplete#context()
                              " 过滤不连续的 '.'
    1              0.000003   if strlen(l:ctx['typed']) >= 2 && l:ctx['char'] ==# '.' && l:ctx['typed'][l:ctx['col'] - 3] !~ '^[a-zA-Z0-9]$'
                                call s:CloseCompletionMenu()
                                return v:null
    1              0.000000   endif
                            
                              " sh #!<tab> hack, bugfix #12
    1              0.000002   if &filetype == "sh" && l:ctx['typed'] == "#!"
                                call s:MainCompleteHandler()
                                return v:null
    1              0.000000   endif
                            
    1              0.000002   if g:env_is_vim && complete_check()
                                call s:flush()
                                return v:null
    1              0.000000   endif
                            
                              " One ':' or '.', Do nothing
    1              0.000004   if strlen(l:ctx['typed']) == 1 && (l:ctx['char'] ==# '.' || l:ctx['char'] ==# ':')
                                call s:CloseCompletionMenu()
                                return v:null
    1              0.000000   endif
                            
                              " 连续两个 '.' 重新初始化 complete
    1              0.000004   if l:ctx['char'] == '.' && (len(l:ctx['typed']) >= 2 && easycomplete#util#str2list(l:ctx['typed'])[-2] == char2nr('.'))
                                call s:CompleteInit()
                                call s:ResetCompleteCache()
    1              0.000000   endif
                            
                              " 首次按键给一个延迟，体验更好
    1              0.000004   if index([':','.','/'], l:ctx['char']) >= 0 || a:immediately is v:true
                                let word_first_type_delay = 0
    1              0.000000   else
    1              0.000001     let word_first_type_delay = 5
    1              0.000000   endif
                            
                              " typing 中的 SecondComplete 特殊字符处理
                              " 特殊字符'->',':','.','::'等 在个语言中的匹配，一般要配合 lsp 一起使用，即
                              " lsp给出的结果中就包含了 "a.b.c" 的提示，这时直接执行 SecondComplete 动作
    1              0.000002   if !empty(g:easycomplete_menuitems)
                                " hack for vim ':' colon typing
                                if s:VimColonTyping()
                                  let l:vim_word = matchstr(l:ctx['typed'], '\w:$')
                                  call s:CompleteTypingMatch(l:vim_word)
                                  return v:null
                                endif
    1              0.000000   endif
                            
                              " 检查模糊匹配 fuzzy match 条件
    1              0.000004   if !empty(g:easycomplete_menuitems) && !s:SameCtx(l:ctx, g:easycomplete_firstcomplete_ctx) && s:SameBeginning(g:easycomplete_firstcomplete_ctx, l:ctx)
                                call s:CompleteTypingMatch()
                                return v:null
    1              0.000000   endif
                            
                              " 如果不是 insert 模式
    1              0.000002   if g:env_is_nvim && mode() != 'i'
                                return v:null
    1              0.000000   endif
                            
                              " 执行 DoComplete
    1   0.039613   0.000008   call s:MainCompleteHandler()
    1              0.000001   return v:null

FUNCTION  <lambda>330()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:276
Called 2 times
Total time:   0.000759
 Self time:   0.000014

count  total (s)   self (s)
                            return Callback(x['server'], x['response'])

FUNCTION  <SNR>56_request_create()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:385
Called 3 times
Total time:   0.006630
 Self time:   0.000070

count  total (s)   self (s)
    3              0.000005   let a:ctx['next'] = a:next
    3              0.000004   let a:ctx['error'] = a:error
    3              0.000005   let a:ctx['complete'] = a:complete
    3              0.000013   let a:ctx['bufnr'] = get(a:ctx['request'], 'bufnr', bufnr('%'))
    3              0.000014   let a:ctx['request']['on_notification'] = function('s:request_on_notification', [a:ctx])
    3   0.005271   0.003445   call easycomplete#lsp#utils#step#start([ {s->s:ensure_flush(a:ctx['bufnr'], a:ctx['server_name'], s.callback)}, {s->s:is_step_error(s) ? s:request_error(a:ctx, s.result[0]) : s:request_send(a:ctx) }, ])
    3              0.000015   return function('s:request_cancel', [a:ctx])

FUNCTION  easycomplete#util#str2list()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:354
Called 39 times
Total time:   0.000296
 Self time:   0.000296

count  total (s)   self (s)
   39              0.000093   if exists("*str2list")
   39              0.000154     return str2list(a:expr)
                              endif
                              if type(a:expr) ==# v:t_list
                                return a:expr
                              endif
                              let l:index = 0
                              let l:arr = []
                              while l:index < strlen(a:expr)
                                call add(l:arr, char2nr(a:expr[l:index]))
                                let l:index += 1
                              endwhile
                              return l:arr

FUNCTION  easycomplete#popup#close()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/popup.vim:780
Called 34 times
Total time:   0.001854
 Self time:   0.001055

count  total (s)   self (s)
                              "call setwinvar(winid, '&hlsearch', s:hlsearch)
   34              0.000056   if empty(a:000)
    1              0.000002     if g:easycomplete_popup_win["popup"]
                                  call easycomplete#popup#close("popup")
    1              0.000000     endif
    1              0.000001     if g:easycomplete_popup_win["float"]
                                  call easycomplete#popup#close("float")
    1              0.000000     endif
    1              0.000001     return
   33              0.000013   endif
   33              0.000050   let windowtype = a:1
   33              0.000217   if windowtype == "float" && bufnr() != expand("<abuf>") && !empty(expand("<abuf>")) && ((g:env_is_vim && pumvisible()) || g:env_is_nvim && easycomplete#pum#visible()) && easycomplete#util#InsertMode()
                                return
   33              0.000011   endif
   33   0.001068   0.000269   call s:CloseByWindowType(windowtype)
   33              0.000041   if windowtype == "float"
    1              0.000002     let s:float_type = ""
    1              0.000004     let s:float_opt = {}
   33              0.000012   endif

FUNCTION  <SNR>56_get_fixendofline()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:633
Called 2 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000008   let l:eol = getbufvar(a:buf, '&endofline')
    2              0.000005   let l:binary = getbufvar(a:buf, '&binary')
                            
    2              0.000002   if s:fixendofline_exists
    2              0.000005     let l:fixeol = getbufvar(a:buf, '&fixendofline')
                            
    2              0.000002     if !l:binary
                                  " When 'binary' is off and 'fixeol' is on, 'endofline' is not used
                                  "
                                  " When 'binary' is off and 'fixeol' is off, 'endofline' is used to
                                  " remember the presence of a <EOL>
    2              0.000003       return l:fixeol || l:eol
                                else
                                  " When 'binary' is on, the value of 'fixeol' doesn't matter
                                  return l:eol
                                endif
                              else
                                " When 'binary' is off the value of 'endofline' is not used
                                "
                                " When 'binary' is on 'endofline' is used to remember the presence of
                                " a <EOL>
                                return !l:binary || l:eol
                              endif

FUNCTION  easycomplete#pum#visible()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:1146
Called 378 times
Total time:   0.003179
 Self time:   0.002334

count  total (s)   self (s)
  378   0.003033   0.002188   return s:pumvisible()

FUNCTION  easycomplete#ShowCompleteInfoByItem()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1431
Called 20 times
Total time:   0.268594
 Self time:   0.001076

count  total (s)   self (s)
   20   0.258694   0.000430   let info = easycomplete#util#GetInfoByCompleteItem(copy(a:item), g:easycomplete_menuitems)
   20              0.000049   let async = empty(info) ? v:true : v:false
   20   0.000563   0.000172   if easycomplete#util#ItemIsFromLS(a:item) && (async || index(["rb"], easycomplete#util#GetLspPluginName()) >= 0)
                                call s:StopAsyncRun()
                                call s:AsyncRun('easycomplete#action#documentation#LspRequest', [a:item], 80)
   20              0.000008   else
   20              0.000033     if type(info) == type("")
                                  let info = [info]
   20              0.000008     endif
   20              0.000049     if exists('b:easycomplete_documentation_popup') && b:easycomplete_documentation_popup > 0
                                  call timer_stop(b:easycomplete_documentation_popup)
   20              0.000006     endif
   20   0.008987   0.000124     call s:ShowCompleteInfo(info)
   20              0.000007   endif

FUNCTION  <SNR>49_GetGhostText()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2092
Called 21 times
Total time:   0.000708
 Self time:   0.000322

count  total (s)   self (s)
   21              0.000040   let curr_col = col('.')
   21              0.000029   let span = curr_col - a:start_pos
   21              0.000065   let prefix = strpart(getline('.'), a:start_pos - 1, span)
   21   0.000529   0.000142   let ghost_text = s:RemovePrefixIgnoreCase(a:first_complete_word, prefix)
   21              0.000020   return ghost_text

FUNCTION  <SNR>52_cmdline()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:206
Called 245 times
Total time:   0.001483
 Self time:   0.001483

count  total (s)   self (s)
  245              0.000823   if exists("g:easycomplete_cmdline_typing") && g:easycomplete_cmdline_typing == 1
   28              0.000028     return v:true
  217              0.000101   else
  217              0.000171     return v:false
                              endif

FUNCTION  <SNR>56_on_notification()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:1002
Called 5 times
Total time:   0.024398
 Self time:   0.000251

count  total (s)   self (s)
                              " echom '>>>> on_notification ' . string(a:data)
                              " call s:errlog("[LOG]", 'lsp response <---', a:id, a:server_name)
    5              0.000010   let l:response = a:data['response']
    5              0.000013   let l:server = s:servers[a:server_name]
    5              0.000009   let l:server_info = l:server['server_info']
                            
    5              0.000015   let l:stream_data = { 'server': a:server_name, 'response': l:response }
    5              0.000008   if has_key(a:data, 'request')
    3              0.000007     let l:stream_data['request'] = a:data['request']
    5              0.000002   endif
    5   0.024123   0.000035   call easycomplete#lsp#stream(1, l:stream_data) " notify stream before callbacks
                            
    5   0.000101   0.000041   if easycomplete#lsp#client#is_server_instantiated_notification(a:data)
    2              0.000003     if has_key(l:response, 'method')
    2              0.000004       if l:response['method'] ==# 'textDocument/semanticHighlighting'
                                    " call lsp#ui#vim#semantic#handle_semantic(a:server_name, a:data)
    2              0.000001       endif
    2              0.000001     endif
    3              0.000001   else
    3              0.000006     let l:request = a:data['request']
    3              0.000006     let l:method = l:request['method']
    3              0.000004     if l:method ==# 'initialize'
                                  call s:handle_initialize(a:server_name, a:data)
    3              0.000001     endif
    5              0.000002   endif
                            
    5              0.000008   for l:callback_info in s:notification_callbacks
                                call l:callback_info.callback(a:server_name, a:data)
    5              0.000003   endfor

FUNCTION  <SNR>49_FirstComplete()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1942
Called 3 times
Total time:   0.035928
 Self time:   0.000923

count  total (s)   self (s)
    3   0.000027   0.000017   if s:zizzing() | return | endif
    3   0.000216   0.000018   if s:CheckCompleteTaskQueueAllDone()
    1              0.000003     if len(a:menuitems) == 1 && easycomplete#util#GetPluginNameFromUserData(a:menuitems[0]) ==# "buf"
                                  if a:menuitems[0]["word"] == expand("<cword>")
                                    call s:flush()
                                    return
                                  endif
    1              0.000000     endif
    1   0.035652   0.000854     call s:FirstCompleteRendering(a:start_pos, a:menuitems)
    3              0.000001   endif

FUNCTION  easycomplete#util#TagBarExists()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:401
Called 20 times
Total time:   0.000862
 Self time:   0.000205

count  total (s)   self (s)
   20   0.000852   0.000196   return easycomplete#util#FuncExists("tagbar#StopAutoUpdate")

FUNCTION  easycomplete#lsp#callbag#pipe()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:156
Called 3 times
Total time:   0.006983
 Self time:   0.000041

count  total (s)   self (s)
    3              0.000006   let l:Res = a:1
    3              0.000003   let l:i = 1
    6              0.000009   while l:i < a:0
    3   0.005538   0.003453     let l:Res = a:000[l:i](l:Res)
    3              0.000005     let l:i = l:i + 1
    6              0.000005   endwhile
    3              0.000003   return l:Res

FUNCTION  easycomplete#lsp#ensure_flush_all()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:156
Called 3 times
Total time:   0.006847
 Self time:   0.000124

count  total (s)   self (s)
    3              0.000009   let l:buf = bufnr('%')
    3              0.000015   if getbufvar(l:buf, '&buftype') ==# 'terminal' | return | endif
    3              0.000008   if getcmdwintype() !=# '' | return | endif
    6   0.000511   0.000035   for l:server_name in easycomplete#lsp#get_allowed_servers(l:buf)
    3   0.006282   0.000035     call s:ensure_flush(l:buf, l:server_name, function('s:Noop'))
    6              0.000006   endfor

FUNCTION  <SNR>52_ComputeScrollThumbPos()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:783
Called 44 times
Total time:   0.004752
 Self time:   0.003005

count  total (s)   self (s)
   44   0.002183   0.000436   let pum_pos = s:PumPosition()
   44              0.000099   let c = pum_pos.pos[1] + pum_pos.width - 1
   44              0.000049   let r = pum_pos.pos[0]
   44              0.000031   let w = 1
                              " ---- 计算 scrollbar 的高度 ----
   44              0.000080   let buf_h = len(s:curr_items)
   44              0.000045   let pum_h = pum_pos.height
   44              0.000045   if g:easycomplete_winborder
   44              0.000043     let pum_h = pum_h
   44              0.000019   endif
   44              0.000176   let scroll_h = float2nr(floor(pum_h * pum_h * 1.0 / buf_h))
   44              0.000045   if scroll_h >= pum_h
                                let scroll_h = pum_h
   44              0.000016   endif
   44              0.000033   if scroll_h == 0
                                let scroll_h = 1
   44              0.000014   endif
   44              0.000039   let h = scroll_h
                              " ---- 计算scrollbar 的位置 ----
   44              0.000347   let top_line = getwininfo(s:pum_window)[0]["topline"]
   44              0.000084   let max_off_r = pum_h - scroll_h
   44              0.000071   let max_top_line = buf_h - pum_h + 1
   44              0.000039   if top_line == 1
   44              0.000051     let r = pum_pos.pos[0]
                              elseif top_line >= max_top_line
                                let r = pum_pos.pos[0] + max_off_r
                              else
                                let p_position = (top_line) * 1.0 / (max_top_line)
                                let r_position = float2nr((pum_h * p_position * 1.0) - (scroll_h * 1.0 / 2))
                                if r_position < 0
                                  let r_position = 0
                                elseif r_position >= max_off_r
                                  let r_position = max_off_r
                                endif
                            
                                if r_position == 0 && top_line > 1
                                  let r_position = 1
                                elseif r_position == max_off_r && top_line < max_top_line
                                  let r_position = max_off_r - 1
                                endif
                                let r = pum_pos.pos[0] + r_position
   44              0.000018   endif
                            
   44              0.000076   let c = c + (g:easycomplete_winborder ? 1 : 0)
   44              0.000058   let r = r + (g:easycomplete_winborder ? 1 : 0)
                            
   44              0.000133   return { "col": c, "row": r, "width": w, "height": h }

FUNCTION  <SNR>56_ensure_open()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:667
Called 6 times
Total time:   0.009916
 Self time:   0.000148

count  total (s)   self (s)
    6              0.000012   let l:server = s:servers[a:server_name]
    6   0.000304   0.000082   let l:path = easycomplete#lsp#utils#get_buffer_uri(a:buf)
                            
    6              0.000010   if empty(l:path)
                                let l:msg = s:new_rpc_success('ignore open since not a valid uri', { 'server_name': a:server_name, 'path': l:path })
                                " call s:errlog("[LOG]", l:msg)
                                call a:cb(l:msg)
                                return
    6              0.000003   endif
                            
    6              0.000012   let l:buffers = l:server['buffers']
                            
    6              0.000013   if has_key(l:buffers, l:path)
    6   0.000089   0.000054     let l:msg = s:new_rpc_success('already opened', { 'server_name': a:server_name, 'path': l:path })
                                " call s:errlog("[LOG]", l:msg)
    6   0.007931   0.006661     call a:cb(l:msg)
    6              0.000003     return
                              endif
                            
                              call s:update_file_content(a:buf, a:server_name, s:get_lines(a:buf))
                              let l:buffer_info = { 'changed_tick': getbufvar(a:buf, 'changedtick'), 'version': 1, 'uri': l:path }
                              let l:buffers[l:path] = l:buffer_info
                            
                              call s:send_notification(a:server_name, { 'method': 'textDocument/didOpen', 'params': {   'textDocument': s:get_text_document(a:buf, a:server_name, l:buffer_info) }, })
                            
                              call easycomplete#lsp#folding#send_request(a:server_name, a:buf, 0)
                            
                              let l:msg = s:new_rpc_success('textDocument/open sent', { 'server_name': a:server_name, 'path': l:path, 'filetype': getbufvar(a:buf, '&filetype') })
                              " call s:errlog("[LOG]", l:msg)
                              call a:cb(l:msg)

FUNCTION  <SNR>49_LetCompleteTaskQueueAllDone()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2382
Called 1 time
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
   31              0.000019   for item in g:easycomplete_complete_taskqueue
   30              0.000021     let item.done = 1
   31              0.000010   endfor

FUNCTION  <SNR>62_get_content_length()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/client.vim:142
Called 5 times
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
    5              0.000042   for l:header in split(a:headers, "\r\n")
    5              0.000026     let l:kvp = split(l:header, ':')
    5              0.000010     if len(l:kvp) == 2
    5              0.000038       if l:kvp[0] =~? '^Content-Length'
    5              0.000014         return str2nr(l:kvp[1], 10)
                                  endif
                                endif
                              endfor
                              return -1

FUNCTION  <SNR>67_StartPopupAsyncRun()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/popup.vim:569
Called 41 times
Total time:   0.000367
 Self time:   0.000367

count  total (s)   self (s)
   41              0.000343   let s:popup_visual_delay = timer_start(a:times, { -> easycomplete#util#call(function(a:method), a:args)})

FUNCTION  easycomplete#lsp#get_server_capabilities()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp.vim:192
Called 26 times
Total time:   0.000180
 Self time:   0.000180

count  total (s)   self (s)
   26              0.000055   let l:server = s:servers[a:server_name]
   26              0.000108   return has_key(l:server, 'init_result') ? l:server['init_result']['result']['capabilities'] : {}

FUNCTION  easycomplete#GetCompletedItem()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:615
Called 23 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
   23              0.000031   return g:easycomplete_completed_item

FUNCTION  <SNR>49_complete()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2108
Called 1 time
Total time:   0.011144
 Self time:   0.000049

count  total (s)   self (s)
    1              0.000002   let g:complete_start = reltime()
    1              0.000007   if mode() =~# 'i' && &paste != 1
    1              0.000001     let should_fire_pum_show = v:false
    1              0.000001     if g:env_is_nvim
    1   0.000011   0.000005       if !easycomplete#pum#visible() && !empty(a:context)
    1              0.000001         let should_fire_pum_show = v:true
    1              0.000000       endif
    1   0.011083   0.000007       noa call easycomplete#pum#complete(a:start, a:context)
                                else
                                  if !pumvisible() && !empty(a:context)
                                    let should_fire_pum_show = v:true
                                  endif
                                  noa silent! call complete(a:start, a:context)
    1              0.000000     endif
    1              0.000001     if should_fire_pum_show
    1              0.000003       silent doautocmd <nomodeline> User easycomplete_pum_show
                                else
                                  call s:ShowCompleteInfoInSecondRendering()
    1              0.000000     endif
    1              0.000000   endif
    1   0.000020   0.000007   noa call easycomplete#popup#overlay()

FUNCTION  <SNR>49_MainCompleteHandler()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1802
Called 1 time
Total time:   0.039605
 Self time:   0.000055

count  total (s)   self (s)
    1   0.000023   0.000005   call s:StopAsyncRun()
    1   0.000021   0.000006   if s:NotInsertMode() && g:env_is_vim | return | endif
    1   0.000128   0.000005   let l:ctx = easycomplete#context()
                              " 执行 complete action 之前最后一道严格拦截，只对这几个末尾特殊字符放行
    1              0.000002   let l:checking = [':','.','/','>',"@","$"]
    1              0.000001   if &filetype == "json"
                                call extend(l:checking, ['"'])
    1              0.000000   endif
    1              0.000003   if strwidth(l:ctx['typing']) == 0 && index(l:checking, l:ctx['char']) < 0
                                return
    1              0.000000   endif
                              " 以上所有步骤都是特殊情况的拦截，后续逻辑应当完全交给 LSP 插件来做标准处
                              " 理，原则上后续处理不应当做过多干扰，是什么结果就是什么结果了，除非严重错误，
                              " 否则不应该在后续链路做 Hack 了
    1   0.003108   0.000006   call s:flush()
    1   0.000089   0.000006   call s:CompleteInit()
    1   0.036217   0.000009   call s:CompletorCallingAtFirstComplete(l:ctx)
                              " 记录 g:easycomplete_firstcomplete_ctx 的时机，最早就是这里
    1              0.000003   let g:easycomplete_firstcomplete_ctx = l:ctx

FUNCTION  easycomplete#lsp#callbag#undefined()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:7
Called 156 times
Total time:   0.000272
 Self time:   0.000272

count  total (s)   self (s)
  156              0.000210   return s:undefined_token

FUNCTION  easycomplete#WinScrolled()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:521
Called 2 times
Total time:   0.000506
 Self time:   0.000037

count  total (s)   self (s)
    2              0.000005   if empty(v:event) | return | endif
    2              0.000004   let l:winid = win_getid()
    2   0.000018   0.000015   if has_key(v:event, l:winid) || has_key(v:event, easycomplete#pum#PumWinid())
    2   0.000475   0.000010     call easycomplete#pum#WinScrolled()
    2              0.000001   endif

FUNCTION  <SNR>49_SetFirstCompeleHit()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2215
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   let g:easycomplete_first_complete_hit = 1

FUNCTION  <SNR>57_makeSubjectFactory()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/callbag.vim:174
Called 8 times
Total time:   0.034202
 Self time:   0.011617

count  total (s)   self (s)
    8              0.000009   if a:t == 0
                                let l:Sink = a:d
                                call add(a:data['sinks'], l:Sink)
                                call l:Sink(0, function('s:makeSubjectSinkCallback', [a:data, l:Sink]))
    8              0.000004   else
    8              0.000051     let l:zinkz = copy(a:data['sinks'])
    8              0.000008     let l:i = 0
    8              0.000014     let l:n = len(l:zinkz)
  152              0.000150     while l:i < l:n
  144              0.000240       let l:Sink = l:zinkz[l:i]
  144              0.000118       let l:j = -1
  144              0.000135       let l:found = 0
  144              0.000236       for l:Item in a:data['sinks']
  144              0.000128         let l:j += 1
  144              0.008442         if l:Item == l:Sink
  144              0.000152           let l:found = 1
  144              0.000090           break
                                    endif
  144              0.000086       endfor
                            
  144              0.000111       if l:found
  144   0.023539   0.000953         call l:Sink(a:t, a:d)
  144              0.000063       endif
  144              0.000171       let l:i += 1
  152              0.000089     endwhile
    8              0.000003   endif

FUNCTION  <SNR>49_CompletorCallingAtFirstComplete()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1183
Called 1 time
Total time:   0.036208
 Self time:   0.001130

count  total (s)   self (s)
    1              0.000001   let l:ctx = a:ctx
    1   0.003184   0.000006   call s:ResetCompleteTaskQueue()
    1              0.000001   if s:first_render_timer > 0
                                call timer_stop(s:first_render_timer)
    1              0.000000   endif
    1              0.000011   let s:first_render_timer = timer_start(s:easycomplete_first_render_delay, { -> s:FirstCompleteRendering(            s:GetCompleteCache(l:ctx['typing'])['start_pos'],            s:GetCompleteCache(l:ctx['typing'])['menu_items']          ) })
                            
                              " TODO 原本在设计 CompletorCalling 机制时，每个CallCompeltorByName返回true时继
                              " 续执行，返回false中断执行，目的是为了实现那些排他性的CompleteCalling，比如
                              " path. 这样就只能串行执行每个插件的 completor()
                              "
                              " 但在 runtime 中不能很好的执行，因为每个 complete_plugin 的
                              " completor 的调用顺序不确定，如果让所有 completor 全都异步，是可以实现排他性
                              " complete的，但即便每个调用都是异步，对于 lsp request 已经发出的情况，由于不
                              " 能abort掉 lsp 进程，因此还是会有返回值冲刷进 g:easycomplete_menuitems，进而
                              " 污染匹配结果。
                              "
                              " 这里默认只有 path 唯一一个需要排他的情况，把 path 提前。
                              " 设计上需要重新考虑下，是否是只能有一个排他completor，还是存在多个共存的
                              " 情况，还不清楚，先这样hack掉
    1              0.000001   try
    1              0.000002     let source_path = ['path']
    1              0.000001     let source_names = []
                            
   31              0.000030     for name in keys(g:easycomplete_source)
   30              0.000027       if name == "path"
    1              0.000001         continue
   29              0.000010       endif
   29              0.000039       if name == "snips" || name == "buf"
                                    " 非lsp plugin，都放后面
    2              0.000004         call add(source_names, name)
   27              0.000055       elseif has_key(g:easycomplete_source[name], "command")
                                    " lsp 需要耗时的，都放前面
   27              0.000107         let source_names = [name] + source_names
                                  else
                                    call add(source_names, name)
   29              0.000010       endif
   30              0.000013     endfor
                                " 最后把 source_path 放在最前面
    1              0.000006     let source_names = source_path + source_names
                            
    1              0.000001     let l:count = 0
   31              0.000053     while l:count < len(source_names)
   30              0.000048       let item = source_names[l:count]
   30              0.000033       let l:count += 1
   30   0.001421   0.000241       if s:CompleteSourceReady(item) && (s:NormalTrigger() || s:SemanticTriggerForPluginName(item))
    5   0.030758   0.000037         let l:cprst = s:CallCompeltorByName(item, l:ctx)
    5              0.000008         if l:cprst == v:true " true: 继续
    5              0.000005           continue
                                    else
                                      call s:flush()
                                      call s:LetCompleteTaskQueueAllDone()
                                      break " false: break, 只在 directory 文件目录匹配时使用
                                    endif
   25              0.000010       endif
   26              0.000042     endwhile
                              catch
                                call s:errlog("[ERR] Completor Calling At FirstComplete", v:exception)
                                call s:flush()
    1              0.000001   endtry

FUNCTION  easycomplete#GetOptions()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1960
Called 4 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    4              0.000012   return get(g:easycomplete_source, a:name, {})

FUNCTION  easycomplete#pum#winid()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:198
Called 5 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    5              0.000007   return s:pum_window

FUNCTION  <SNR>49_NormalizeSortLua()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:2248
Called 3 times
Total time:   0.003827
 Self time:   0.003827

count  total (s)   self (s)
    3              0.003825   return s:easycomplete_toolkit.normalize_sort(a:items)

FUNCTION  <SNR>65_handle_fold_request()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/lsp/folding.vim:72
Called 2 times
Total time:   0.000257
 Self time:   0.000203

count  total (s)   self (s)
    2   0.000064   0.000021   if easycomplete#lsp#client#is_error(a:data) || !has_key(a:data, 'response') || !has_key(a:data['response'], 'result')
                                return
    2              0.000001   endif
                            
    2              0.000004   let l:result = a:data['response']['result']
                            
    2              0.000005   if type(l:result) != type([])
                                return
    2              0.000001   endif
                            
    2              0.000007   let l:uri = a:data['request']['params']['textDocument']['uri']
    2   0.000026   0.000015   let l:path = easycomplete#lsp#utils#uri_to_path(l:uri)
    2              0.000038   let l:bufnr = bufnr(l:path)
                            
    2              0.000002   if l:bufnr < 0
                                return
    2              0.000001   endif
                            
    2              0.000005   if !has_key(s:folding_ranges, a:server)
                                let s:folding_ranges[a:server] = {}
    2              0.000001   endif
    2              0.000052   let s:folding_ranges[a:server][l:bufnr] = l:result
                            
                              " Set 'foldmethod' back to 'expr', which forces a re-evaluation of
                              " 'foldexpr'. Only do this if the user hasn't changed 'foldmethod',
                              " and this is the correct buffer.
    4              0.000009   for l:winid in win_findbuf(l:bufnr)
    2              0.000011     if getwinvar(l:winid, '&foldmethod') ==# 'expr'
                                  call setwinvar(l:winid, '&foldmethod', 'expr')
    2              0.000001     endif
    4              0.000003   endfor

FUNCTION  easycomplete#pum#PumWinid()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:1026
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000002   return s:pum_window

FUNCTION  easycomplete#FirstSelectedWithOptDefaultSelected()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:576
Called 45 times
Total time:   0.003626
 Self time:   0.001378

count  total (s)   self (s)
   45              0.000057   if g:easycomplete_pum_noselect
                                return v:false
   45              0.000016   endif
   45              0.000056   if g:env_is_vim && !pumvisible()
                                return v:false
   45              0.000014   endif
   45   0.000841   0.000279   if g:env_is_nvim && !easycomplete#pum#visible()
                                return v:false
   45              0.000015   endif
   45   0.001275   0.000231   if !easycomplete#CompleteCursored()
                                return v:false
   45              0.000016   endif
   45   0.001046   0.000404   let l:selected = g:env_is_nvim ? easycomplete#pum#CompleteInfo()['selected'] : complete_info()['selected']
   45              0.000042   if l:selected == 0
   45              0.000031     return v:true
                              endif
                              return v:false

FUNCTION  <SNR>78_GetLspCompletionResult()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/action/completion.vim:66
Called 1 time
Total time:   0.027493
 Self time:   0.012394

count  total (s)   self (s)
    1              0.000002   let l:result = a:data['response']['result']
    1              0.000001   let l:response = a:data['response']
                            
                              " 这里包含了 info document 和 matches
                              " 性能：
                              " 2025年5月2日：
                              "   192 个元素
                              "     vim 用时 55 ms
                              "     lua 用时 29 ms
                              " 2025年7月27日更新：192 个元素 lua 耗时减少到 18ms
    1              0.000002   let tt = reltime()
    1              0.000001   if g:env_is_nvim
    1   0.027473   0.012375     let l:completion_result = s:util_toolkit.get_vim_complete_items(l:response, a:plugin_name, a:word)
                              else
                                let l:completion_result = easycomplete#util#GetVimCompletionItems(l:response, a:plugin_name, a:word)
    1              0.000000   endif
                              " call s:console(reltimestr(reltime(tt)), len(l:completion_result['items']))
                              " call v:lua.require("easycomplete.util").get_plain_items(l:completion_result["items"])
    1              0.000004   return {'matches': l:completion_result['items'], 'incomplete': l:completion_result['incomplete'] }

FUNCTION  easycomplete#pum#CompleteCursored()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/pum.vim:420
Called 254 times
Total time:   0.000506
 Self time:   0.000506

count  total (s)   self (s)
  254              0.000412   return s:selected_i == 0 ? v:false : v:true

FUNCTION  <SNR>49_CombineAllMenuitems()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete.vim:1931
Called 3 times
Total time:   0.000701
 Self time:   0.000701

count  total (s)   self (s)
    3              0.000005   let result = []
   93              0.000092   for name in keys(g:easycomplete_source)
  177              0.000118     if name == "tn" | continue | endif
   87              0.000366     call extend(result, get(g:easycomplete_source[name], 'complete_result', []))
   90              0.000038   endfor
    3              0.000004   return result

FUNCTION  <SNR>40_errlog()
    Defined: ~/.local/share/nvim/site/pack/packer/start/vim-easycomplete/autoload/easycomplete/util.vim:2428
Called 6 times
Total time:   0.013643
 Self time:   0.012961

count  total (s)   self (s)
    6              0.000008   let max_line = 1000
    6   0.000313   0.000044   let logfile = easycomplete#util#ConfigRoot() . "/errlog"
    6              0.000025   if !exists("g:easy_log_file_exists") && !easycomplete#util#FileExists(logfile)
                                call writefile(["----- Easycomplete Errlog ------"], logfile, "a")
    6              0.000003   endif
    6              0.000009   let g:easy_log_file_exists = 1
    6   0.000489   0.000076   let l:res = call('s:NormalizeLogMsg', a:000)
    6              0.000014   if type(l:res) != type([])
    6              0.000009     let l:res = [l:res]
    6              0.000002   endif
    6              0.000086   let time_stamp = strftime("%Y %b %d %X")
    6              0.000029   let buf_name = fnamemodify(expand('%'), ':f:h')
    6              0.000038   call map(l:res, 'time_stamp . " " . buf_name . v:val')
    6              0.004900   let old_content = readfile(logfile, "", -1 * max_line)
    6              0.001103   let new_content = old_content + l:res
    6              0.006572   call writefile(new_content, logfile, "S")

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   30   0.395221   0.215253  easycomplete#util#GetInfoByCompleteItem()
   26   0.272097   0.009622  easycomplete#pum#complete()
   20   0.268594   0.001076  easycomplete#ShowCompleteInfoByItem()
   25   0.160631   0.003382  easycomplete#TextChangedI()
   23   0.152214   0.003371  easycomplete#TextChangedP()
 9387   0.149464   0.088340  easycomplete#util#GetSha256()
   10   0.138729   0.000820  <SNR>49_ShowCompleteInfoWithoutTimer()
   26   0.137564   0.005765  <SNR>52_NormalizeItems()
   26   0.123953   0.003500  <SNR>52_OpenPum()
   11   0.122486   0.007602  <SNR>49_CompleteMatchAction()
    9   0.115035   0.000870  easycomplete#_complete()
   17   0.113820   0.113609  easycomplete#util#CompleteMenuFilter()
   11   0.111830   0.009026  <SNR>49_CompleteTypingMatch()
    5   0.091574   0.000533  <SNR>63_on_stdout()
    5   0.091041   0.002549  <SNR>62_on_stdout()
   26   0.073441   0.000364  <SNR>52_GetBufSize()
   26   0.073076             <SNR>52_MaxLength()
    5   0.071130   0.000233  easycomplete#complete()
    5   0.069974   0.002012  <SNR>49_CompleteAdd()
   26   0.069294   0.050741  <SNR>52_GetFullfillItems()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   30   0.395221   0.215253  easycomplete#util#GetInfoByCompleteItem()
   17   0.113820   0.113609  easycomplete#util#CompleteMenuFilter()
 9387   0.149464   0.088340  easycomplete#util#GetSha256()
   26              0.073076  <SNR>52_MaxLength()
 9752              0.065208  easycomplete#util#GetUserData()
 1077              0.062504  <SNR>52_MapFunction()
   26   0.069294   0.050741  <SNR>52_GetFullfillItems()
 9387              0.030504  <SNR>40_GetPluginNameFromUserData()
    3   0.021258   0.017174  <SNR>49_NormalizeMenulist()
  246              0.015684  easycomplete#util#GetTypingWord()
    6   0.013643   0.012961  <SNR>40_errlog()
    1   0.027493   0.012394  <SNR>78_GetLspCompletionResult()
    8   0.034202   0.011617  <SNR>57_makeSubjectFactory()
 2154              0.011085  <SNR>52_fullfill()
  170   0.011786   0.010891  easycomplete#util#FunctionSurffixMap()
   26   0.272097   0.009622  easycomplete#pum#complete()
   11   0.111830   0.009026  <SNR>49_CompleteTypingMatch()
  202   0.021509   0.008264  easycomplete#context()
   11   0.011780   0.008180  <SNR>49_SecondComplete()
   21              0.007667  <SNR>52_ComputeHLPositions()

